<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>克疾文轩</title>
  
  <subtitle>徐思远的记录空间</subtitle>
  <link href="https://github.com/XuSiyuan-cn/atom.xml" rel="self"/>
  
  <link href="https://github.com/XuSiyuan-cn/"/>
  <updated>2021-05-08T07:47:40.444Z</updated>
  <id>https://github.com/XuSiyuan-cn/</id>
  
  <author>
    <name>XuSiyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>行路难</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/08/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/18%20%E8%A1%8C%E8%B7%AF%E9%9A%BE/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/08/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/18%20%E8%A1%8C%E8%B7%AF%E9%9A%BE/</id>
    <published>2021-05-07T22:37:23.000Z</published>
    <updated>2021-05-08T07:47:40.444Z</updated>
    
    <content type="html"><![CDATA[<p>记录一波自己的心路历程</p><a id="more"></a><h1 id="2021-04-19关于学习方法的讨论"><a href="#2021-04-19关于学习方法的讨论" class="headerlink" title="2021.04.19关于学习方法的讨论"></a><FONT COLOR = SpringGreen>2021.04.19关于学习方法的讨论</font></h1><p>感触很深的一篇文章，本文来自公众号粉丝群“启明小迷弟”同学的投稿</p><p>　　今天又研读了启明学长的文章，我对人的惰性有了一些思考，很多人包括我自己<Font Color = LimeGreen Face = 楷体 Size = 4><strong>在复习的时候总是喜欢边听讲边记笔记，其实这是一种大脑的惰性行为</strong></font>。人的大脑总是倾向于做一些简单机械的事情，所以<Font Color = LimeGreen Face = 楷体 Size = 4><strong>我们很多人喜欢花很多时间听网课，然后笔耕不辍地在本子上记笔记，完事后一种满足感跃上心头，感觉今天自己学习很努力</strong></font>。其实这是在用战术上的勤奋来掩盖战略上的懒惰，因为在这个过程中我的们的大脑对知识点理解和消化是很少的，这就像骑自行车行驶在一条平坦的大道上，毫无坎坷自然让人感觉很舒服，而<Font Color = LimeGreen Face = 楷体 Size = 4><strong>真正要学习东西，那就需要大脑调用更多的神经元，进行更多的活动，这就像骑车冲击陡坡，很吃力，在这个过程中你会感到一些难受、甚至痛苦</strong></font>，所以古人才云：学海无涯苦作舟。但是学习并不是一个只有痛苦的过程，<strong>当你冲过上顶峰，学懂知识后的那种正向反馈的喜悦感、成就感是一种高级的快乐，不是玩“表面式”努力带来的快乐和玩游戏带来的兴奋所能比的。</strong></p><p>　　我小时候一直疑惑：既然学习和工作那么苦，为什么那些行业大牛、科学家还是孜孜不倦的学习呢？那一定是<strong>他们在学习工作中不断得到正向的反馈，大脑获得的快乐远大于痛苦</strong>，而自习室中一些考研“气氛组”总是盼望着什么时候这一天能结束，然后回宿舍痛快的打游戏；社会上一些较为底层的人朝九晚五，上班的时候总掐着手表、数着日子盼着下班、放假，这都是因为他们没有克服大脑的惰性，<strong>很少从学习或者工作中得到正向的反馈，于是对自己所从事的事情渐渐失去兴致</strong>。</p><h1 id="2021-05-08怎么样才能提升自己"><a href="#2021-05-08怎么样才能提升自己" class="headerlink" title="2021.05.08怎么样才能提升自己"></a><FONT COLOR = SpringGreen>2021.05.08怎么样才能提升自己</font></h1><p>如何判断一个人的实力？或者说，厉害的人都有哪些共同的特点？</p><h2 id="超强的学习欲望"><a href="#超强的学习欲望" class="headerlink" title="超强的学习欲望"></a><FONT COLOR = Cyan>超强的学习欲望</font></h2><p>　　不仅仅是学习知识，还有其他各个方面。有实力的牛人往往都有超强的学习欲望，这种欲望可能体现在动作细节上，比如一边打电话一边做记录，比如当着你的面拿出笔记本；可能是非常虚心的向下级求教，对各种问题刨根问底。<br>　　不断地向形形色色的人学习，是牛人的共性。</p><h2 id="极度专注"><a href="#极度专注" class="headerlink" title="极度专注"></a><FONT COLOR = Cyan>极度专注</font></h2><p>　　<Font Color = LimeGreen Face = 楷体 Size = 4>我们这辈子能取得的成就高低，不取决于时间，而取决于注意力。 </font></p><h2 id="理解与表达"><a href="#理解与表达" class="headerlink" title="理解与表达"></a><FONT COLOR = Cyan>理解与表达</font></h2><p>　　拽大词、扯概念，让人听不懂参不透，表面上看起来很厉害，但实际上这只能掩饰自己的拉胯。真正的表达者，需要有<Font Color = LimeGreen Face = 楷体 Size = 4>用户思维</font>——弄清别人是怎么想的。<br>　　从表达上来说，有实力的人都是把复杂的概念用极其接地气的话讲出来，<Font Color = LimeGreen Face = 楷体 Size = 4>把复杂问题用简单话语表达出来</font>。还辅以例子、类比的使用。<br>　　从理解上来说，<Font Color = LimeGreen Face = 楷体 Size = 4>把复杂问题简单化</font>可以真正体现出把问题给研究透了。</p><p>　　说出一个概念的名字、用大白话解释这个概念、举一个例子或类比。</p><h2 id="避免"><a href="#避免" class="headerlink" title="避免"></a><FONT COLOR = Cyan>避免</font></h2><p><Font Color = LimeGreen Face = 楷体 Size = 4>　　只罗列概念，不讲亲自做事的细节和数据</font></p><hr><p>　　最近有句话很流行，“我们对国家的未来充满信心，但对自己的未来充满了迷茫。”迷茫，其实是人生的一种常态，不管沸腾的视频多么宏伟，但人依旧要过好自己的小生活。<br><Font Color = LimeGreen Face = 楷体 Size = 4>　　不要把自己代入到“国家伟大”这种宏大的叙事当中，把注意力放到小事情的优化上。5G的大势跟大多数人都没啥关系，多读两篇本专业的论文可能更有用；新基建、大数据、云计算也跟大多数人没关系，多提升一下沟通技巧待人接物更实在。</font>不要总想着在这些大趋势、大风口里我能分一杯羹，占个红利什么的，每个人能力有限，术业有专攻，当在某一个行业干了一段时间，这个行业有哪些发展趋势，自己是清楚的。<Font Color = LimeGreen Face = 楷体 Size = 4>没必要怕自己错过什么别的行业里的东西，有些机会本就不属于你，而是属于那些有沉淀有积累的人。</font>从身边的小事做起。<br>　　<Font Color = LimeGreen Face = 楷体 Size = 4>不要动不动就呻吟抱怨，展现自己脆弱的话，不要发朋友圈，更不要在那些非知心朋友面前讲述，因为在真实的世界里，人们都是慕强的。</font>合作都喜欢挑央企、上市公司、大V合作；招聘也喜欢找名校毕业、不怕吃苦，自信的人。<br>　　来点政治不正确的话，这个世界上只有两种人：winner &amp; loser。别扯什么每个人都有定义自己成功的权力，这句话只有那些取得世俗意义上成功的人，他在决定退休的时候才有资格说。<Font Color = LimeGreen Face = 楷体 Size = 4>很多人自以为看透了这个世界，满口资本、阶级、剥削、阴谋，处处透露着我已经被打败了这种 loser 心态，整天这么说，只会吸引来同样喜欢这类言论的人。</font>算法会快速捕捉到你的这个倾向，然后疯狂推送有类似观点的人，这个想法会被进一步地强化，原来可能只是发泄一下情绪，后来就可能真的变成了这样的一个人。</p><h1 id="5月的计划"><a href="#5月的计划" class="headerlink" title="5月的计划"></a><FONT COLOR = SpringGreen>5月的计划</font></h1><p>201：</p><ul><li><input disabled="" type="checkbox"> 新3 裕兴</li><li><input disabled="" type="checkbox"> 新3 北外</li><li><input disabled="" type="checkbox"> 新4 蒋</li><li><input disabled="" type="checkbox"> 新4 北外</li><li><input disabled="" type="checkbox"> 每天背单词300个</li><li><input disabled="" type="checkbox"> 每天做听写两篇</li><li><input disabled="" type="checkbox"> 语法初级</li><li><input disabled="" type="checkbox"> 语法中级</li><li><input disabled="" type="checkbox"> 语法高级</li></ul><p>301：</p><ul><li><input disabled="" type="checkbox"> 北大数分课本</li><li><input disabled="" type="checkbox"> 苏德矿课程</li><li><input disabled="" type="checkbox"> 狮子微积分</li><li><input disabled="" type="checkbox"> 浙大辅导书</li><li><input disabled="" type="checkbox"> 徐森林数分、史贤林、清华丘班讲义看一遍</li><li><input disabled="" type="checkbox"> 史老师数分课</li><li><input disabled="" type="checkbox"> MIT单变量微积分</li><li><input disabled="" type="checkbox"> MIT多变量微积分</li><li><input disabled="" type="checkbox"> 微积分重点</li><li><input disabled="" type="checkbox"> 微分方程</li><li><input disabled="" type="checkbox"> 单变量微积分习题课</li><li><input disabled="" type="checkbox"> 多变量微积分习题课</li></ul><p>912：</p><ul><li><input disabled="" type="checkbox"> 浙大翁恺C，第二遍</li><li><input disabled="" type="checkbox"> 浙大PTA题目刷完</li><li><input disabled="" type="checkbox"> 《C primer plus》</li><li><input disabled="" type="checkbox"> B站VS C <a href="https://www.bilibili.com/video/BV1qE411d7Zx">https://www.bilibili.com/video/BV1qE411d7Zx</a></li><li><input disabled="" type="checkbox"> 经典100题</li><li><input disabled="" type="checkbox"> 谭浩强C</li><li><input disabled="" type="checkbox"> 贪吃蛇</li><li><input disabled="" type="checkbox"> 浙大，零基础学Java语言</li><li><input disabled="" type="checkbox"> 浙大，面向对象程序设计——Java语言</li><li><input disabled="" type="checkbox"> 浙大，Python程序设计</li><li><input disabled="" type="checkbox"> Python语言程序设计:AV77405880</li><li><input disabled="" type="checkbox"> 数据分析与展示:AV73025184</li><li><input disabled="" type="checkbox"> 科学计算三维可视化:AV73059189</li><li><input disabled="" type="checkbox"> 机器学习应用:AV73055836</li><li><input disabled="" type="checkbox"> 网络爬虫与信息提取:AV73060821</li><li><input disabled="" type="checkbox"> 云端系统开发:AV73032036</li><li><input disabled="" type="checkbox"> 游戏开发:AV73028956</li><li><input disabled="" type="checkbox"> MIT 6.0001</li><li><input disabled="" type="checkbox"> 《C++ Primier》《effective c++》</li><li><input disabled="" type="checkbox"> 北大，计算概论</li><li><input disabled="" type="checkbox"> 北大，程序设计与算法（一）（二）（三）</li><li><input disabled="" type="checkbox"> 北大，程序设计实习</li><li><input disabled="" type="checkbox"> 清华：面向对象程序设计（C++）</li><li><input disabled="" type="checkbox"> 清华，VC++面向对象与可视化程序设计（上）：Windows编程基础</li><li><input disabled="" type="checkbox"> 清华，VC++面向对象与可视化程序设计（下）：MFC编程基础</li><li><input disabled="" type="checkbox"> 侯捷 C++：BV1Ce411x77G  BV1tg4y1872m </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一波自己的心路历程&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>博客设置记录</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/08/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/17%20%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/08/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/17%20%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2021-05-07T22:37:23.000Z</published>
    <updated>2021-05-07T22:45:06.917Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>备忘一波</FONT></p><a id="more"></a><h2 id="下载-node-js"><a href="#下载-node-js" class="headerlink" title="下载 node.js"></a><FONT COLOR = Cyan>下载 node.js</font></h2><p>　　win7 不能用最新版，用 node-v10.24.0-x64</p><h2 id="下载-Git-for-Windows"><a href="#下载-Git-for-Windows" class="headerlink" title="下载 Git for Windows"></a><FONT COLOR = Cyan>下载 Git for Windows</font></h2><p>　　下载安装结束后，打开 git-bash 输入命令</p><blockquote><p>ssh-keygen -t rsa -C “<a href="mailto:&#122;&#x65;&#x72;&#x6f;&#x78;&#x75;&#x73;&#105;&#121;&#x75;&#97;&#110;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;">&#122;&#x65;&#x72;&#x6f;&#x78;&#x75;&#x73;&#105;&#121;&#x75;&#97;&#110;&#x40;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a>”</p></blockquote><p>　　回车，直到命令结束。</p><p>　　然后打开 GitHub ，在设置里找到 SSH and GPG，新建一个 SSH，其中 Key 文件在  C:\Users\Administrator.ssh</p><p>　　特别注意：Github 从2021年8月13日开始，不接受用户密码的方式进行 git 操作验证。用个人令牌代替密码：<br>　　进入网页 GitHub → settings → Developer settings → Personal access tokens → Generate new token<br>　　选择要授予此令牌的作用域或权限。 要使用令牌从命令行访问仓库，选择 repo（仓库）<br>　　最后赋值个人令牌，然后点开 git 全局设定，设定密码：</p><blockquote><p>查看原用户名<br>　　$ git config user.name<br>修改用户名<br>　　$ git config –global user.name “you name”<br>修改邮箱<br>　　$ git config –global user.email “you email”<br>修改密码<br>　　$ git config –global user.password “personal access token”<br>查看你新的用户名<br>　　$ git config user.name<br>查看你的新邮箱<br>　　$ git config user.email</p></blockquote><h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a><FONT COLOR = Cyan>安装 hexo</font></h2><p>　　打开一个文件夹（blog），然后命令行 cd 到这个文件夹下，然后去hexo 官网上用命令 安装 hexo </p><blockquote><ul><li>npm install hexo-cli -g</li><li>hexo init blog</li><li>cd blog</li><li>npm install</li><li>hexo server</li></ul></blockquote><p>安装完毕hexo后，就可以直接部署了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;备忘一波&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2022的春天</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/16%202022%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/16%202022%E7%9A%84%E6%98%A5%E5%A4%A9/</id>
    <published>2021-05-06T21:00:00.000Z</published>
    <updated>2021-05-08T08:46:05.524Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>期待这一天</FONT></p><a id="more"></a><h1 id="元旦"><a href="#元旦" class="headerlink" title="元旦"></a><FONT COLOR = SpringGreen>元旦</font></h1><ul><li>参加学堂在线 Code+比赛</li><li>看看coding收藏夹里面历年机试题</li><li>咨询一下过来人，去做一些通用的项目。ML、DL、CV、NLP之类的</li><li>阅读一些高水平论文，复现论文</li><li>编CV：个人陈述（中英文） 网上搜索模板 花几块钱买个好看的。简历要简洁，突出重点，主观描述少。找亮点、初试成绩、项目经历。自我评价、自学能力、执行能力。生涯规划，根据研究对象研究方向，设计自己的规划。<br>PS1：简历里要有一张好看的正装照。哪怕多花点钱也是值得的。<br>PS2：简历最好只写1页<br>PS3：过往经历要有数据和细节，注意数据优化</li></ul><h1 id="TP信息"><a href="#TP信息" class="headerlink" title="TP信息"></a><FONT COLOR = SpringGreen>TP信息</font></h1><p>计应=计算所+计算中心+数媒所<br>软理=软工所+信息安全实验室+图形实验室+语言研究所+网络所<br>结构=网络所+结构所+高能效所<br>智能=视感知 CV+计算智能+听感知与感知机理</p><p>　　谷歌教授主页，各大实验室和研究中心的官网。去各个所的官网或者套路前人们，获得有名额的老师名单。找项目、找论文。<br>　　下载一个 HistCite ，定位精品论文和明星科学家</p><p>TP上岸：公众号启明笔记</p><h1 id="碰瓷"><a href="#碰瓷" class="headerlink" title="碰瓷"></a><FONT COLOR = SpringGreen>碰瓷</font></h1><p>　　初试成绩出来后就联系老师，争取实习的机会。否则，就做通用的项目。<br>　　成绩出来后，当晚联系导师，联系老师只需要清楚地介绍好自己，表明想跟老师做就可以（附上简历），有一些老师会有特殊的要求（如张健老师），在提前联系老师前务必到学院官网查看他的个人主页。<br>　　发邮件的时候附上CV，邮件正文不要空着，写简历高光亮点，写对老师课题的了解，可以 附带一封自荐书。</p><p>　　<u>本科成绩单</u>：务必提前准备好本科的成绩单，章必须红色。多准备几份成绩单，因为调剂也是必须要成绩单的，没有多的成绩单无法参加调剂面试。<br>　　<u>初试准考证</u><br>　　<u>CV</u>：准备多份简历，分发给老师，鞠躬</p><h1 id="提升实力"><a href="#提升实力" class="headerlink" title="提升实力"></a><FONT COLOR = SpringGreen>提升实力</font></h1><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a><FONT COLOR = Cyan>英语</font></h2><p>找NLP 或者机器学习，研究项目相关的英文著作，仔细阅读。<br>阅读几篇高水平的论文。</p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a><FONT COLOR = Cyan>数学</font></h2><p>高级统计学（李航统计书）</p><h2 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a><FONT COLOR = Cyan>代码能力</font></h2><ul><li>coding收藏夹里面历年机试题</li><li>之前没看完的算法书</li></ul><h2 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a><FONT COLOR = Cyan>项目经验</font></h2><p>简历和老师研究方向相匹配</p><ul><li>西瓜书</li><li>花书</li></ul><h2 id="科研能力"><a href="#科研能力" class="headerlink" title="科研能力"></a><FONT COLOR = Cyan>科研能力</font></h2><ul><li><p>阅读老师的论文</p></li><li><p>阅读行业经典论文</p></li><li><p>复现论文（看有没有复现论文的培训班报一个）</p><p>OS顶级论文：<a href="https://www.sigops.org/awards/hof/">https://www.sigops.org/awards/hof/</a><br>NLP、ML：<a href="https://github.com/XuSiyuan-cn/CNSurvey">https://github.com/XuSiyuan-cn/CNSurvey</a></p></li></ul><p>For NLP:</p><p>　　Efficient Estimation of Word Representation in Vector Space, 2013 ( birth of word2vec)</p><p>　　Convolutional Sequence to Sequence Learning, facebook AI Research 2017 (Machine translation)</p><p>For CV:</p><p>　　ImageNet Classification with Deep Convolutional Neural Networks (birth of AlexNet)</p><p>　　Deep Residual Learning for Image Recognition (Kaiming’s biggest Contribution)</p><p>　　Faster R-CNN: Towards real-time object detection with region proposal networks (Detection breakthrough)</p><p>For video:</p><p>　　<a href="https://zhuanlan.zhihu.com/wzmsltw">https://zhuanlan.zhihu.com/wzmsltw</a> (上交林天威的博客)</p><p>　　<a href="https://zhuanlan.zhihu.com/qijiezhao">https://zhuanlan.zhihu.com/qijiezhao</a> （我自己的博客）</p><p>AI顶会：</p><table><thead><tr><th>领域</th><th>期刊/会议</th></tr></thead><tbody><tr><td>经典</td><td>AAAI Conference on Artificial Intelligence (AAAI)</td></tr><tr><td></td><td>International Joint Conference on Artificial Intelligence (IJCAI)</td></tr><tr><td>机器学习</td><td>Annual Conference on Neural Information Processing Systems (NeurIPS)</td></tr><tr><td></td><td>International Conference on Machine Learning (ICML)</td></tr><tr><td></td><td>International Conference on Learning Representations (ICLR)</td></tr><tr><td>计算机视觉</td><td>IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</td></tr><tr><td></td><td>IEEE International Conference on Computer Vision (ICCV)</td></tr><tr><td></td><td>European Conference on Computer Vision (ECCV)</td></tr><tr><td>自然语言处理</td><td>Annual Meeting of the Association for Computational Linguistics (ACL)</td></tr><tr><td></td><td>Conference on Empirical Methods in Natural Language Processing (EMNLP)</td></tr><tr><td></td><td>North American Chapter of the Association for Computational Linguistics (NAACL)</td></tr><tr><td>机器人</td><td>IEEE International Conference on Robotics and Automation (ICRA)</td></tr><tr><td></td><td>IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)</td></tr><tr><td>知识工程</td><td>International Semantic Web Conference (ISWC)</td></tr><tr><td></td><td>International Conference on Principles of Knowledge Representation and Reasoning (KR)</td></tr><tr><td>语音识别</td><td>IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)</td></tr><tr><td>数据挖掘</td><td>ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD)</td></tr><tr><td></td><td>ACM International Conference on Web Search and Data Mining (WSDM)</td></tr><tr><td>信息检索与推荐</td><td>International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR)</td></tr><tr><td></td><td>ACM Recommender Systems (RecSys)</td></tr><tr><td></td><td>International World Wide Web Conference (WWW)</td></tr><tr><td>数据库</td><td>ACM SIGMOD International Conference on Management of Data (SIGMOD)</td></tr><tr><td></td><td>International Conference on Very Large Data Bases (VLDB)</td></tr><tr><td>人机交互</td><td>ACM CHI Conference on Human Factors in Computing Systems (CHI)</td></tr><tr><td></td><td>ACM Conference on Computer-Supported Cooperative Work &amp; Social Computing (CSCW)</td></tr><tr><td>计算机图形</td><td>ACM SIGGRAPH Conference (SIGGRAPH)</td></tr><tr><td>多媒体</td><td>ACM International Conference on Multimedia (MM)</td></tr><tr><td>可视化</td><td>IEEE Transactions on Visualization &amp; Computer Graphics (TVCG)</td></tr><tr><td></td><td>IEEE Visualization Conference (IEEE VIS)</td></tr><tr><td>安全与隐私</td><td>ACM Conference on Computer and Communications Security (CCS)</td></tr><tr><td></td><td>IEEE Symposium on Security and Privacy (S&amp;P)</td></tr><tr><td></td><td>USENIX Security Symposium (USS)</td></tr><tr><td>计算机网络</td><td>ACM International Conference on Mobile Computing and Networking (MobiCom)</td></tr><tr><td></td><td>ACM SIGCOMM Conference (SIGCOMM)</td></tr><tr><td>计算机系统</td><td>ACM Symposium on Operating Systems Principles (SOSP)</td></tr><tr><td></td><td>USENIX Symposium on Operating Systems Design and Implementation (OSDI)</td></tr><tr><td>计算理论</td><td>ACM Symposium on Theory of Computing (STOC)</td></tr><tr><td></td><td>IEEE Annual Symposium on Foundations of Computer Science (FOCS)</td></tr><tr><td>芯片技术</td><td>IEEE International Solid-State Circuits Conference (ISSCC)</td></tr><tr><td></td><td>Design Automation Conference (DAC)</td></tr><tr><td></td><td>Symposium on Field Programmable Gate Arrays (FPGA)</td></tr><tr><td>物联网</td><td>IEEE Internet of Things Journal (IoT-J)</td></tr><tr><td></td><td>IEEE Transactions on Wireless Communications (TWC)</td></tr></tbody></table><h2 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a><FONT COLOR = Cyan>面试技巧</font></h2><p>　　个人陈述：不要挖坑，扬长避短、熟悉项目。自我介绍中英文都要。个人陈述写到的东西80%的可能会问到，请认真准备。</p><p>　　初试专业课，复习熟悉</p><p> 　　去打听面试内容</p><p>　　自我介绍：给目标的老师或者研究方向定制一份自我介绍，背下来。自我介绍的目的：说明我对这个项目组有什么用！遵循三个原则：<br>　　F - feature - 属性：经历和能力<br>　　A - advantage - 优势：做出的成绩<br>　　B - benefit - 好处：对公司的好处</p><blockquote><p>英文好：可以流畅阅读英文文献，或者和老外交流。<br>学习能力强：一年内完成疾风计划，在从0到1做一个项目方面，自己有信心也有恒心。<br>做过的项目好：可以快速上手相关项目，有发文章的欲望，balabala<br>向往TP：非常期待在TP的日子。</p></blockquote><p>　<Font Color = LimeGreen Face = 楷体 Size = 4>说一件你做过的最骄傲的事情</font>&amp;<Font Color = LimeGreen Face = 楷体 Size = 4>故事情节的模板</font></p><blockquote><p>目标：一年之内完成雅思、疾风计划、TP计划<br>阻碍：基础差，周围人不支持<br>努力：<br>失败：中途因为缺乏系统的指导，导致学习效率低下，抓不住重点，曾经一度想要放弃TP<br>意外：学堂在线的疾风计划帮助了我很多<br>转机：在疾风计划的帮助下，成功打下了CS的基础<br>结局：初试第一，来到这里。</p></blockquote><blockquote><p>目标：10天之内组织一个促销活动<br>阻碍：公司资源少，人手不足，大部分活要自己干<br>努力：连续10天睡眠不足超过4h<br>失败：隔壁部门掉链子，活动吃吃无法上限<br>意外：万般无奈之下，想到补救措施，不完美上限<br>转机：反馈相当不错，是平常订单的十倍<br>结局：10个人的团队，三天销售额达到70W</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;期待这一天&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021下半年TU计划</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/15%202021%E4%B8%8B%E5%8D%8A%E5%B9%B4TU%E8%AE%A1%E5%88%92/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/15%202021%E4%B8%8B%E5%8D%8A%E5%B9%B4TU%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-06T20:00:00.000Z</published>
    <updated>2021-05-07T21:44:25.166Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！髀肉复生，搞个大新闻！</FONT></p><a id="more"></a><h1 id="101"><a href="#101" class="headerlink" title="101"></a><FONT COLOR = SpringGreen>101</font></h1><ul><li>核心考案+1000题（铅笔做题，水笔记笔记+大牙考研视频）+思维导图</li><li>1000题第二遍</li><li>冲刺背诵手册（看大牙推荐谁的，陆寓丰 or 徐涛）</li><li>1000题第三遍</li><li>看一下公众号：木易木子的肖4、肖8辅助背诵资料</li><li>肖8（选择题考试 + 分析题自己整理模板），背诵肖8分析题</li><li>肖4</li><li>在记乎app上背诵各路老师的政治预测卷的选择题</li></ul><h1 id="201"><a href="#201" class="headerlink" title="201"></a><FONT COLOR = SpringGreen>201</font></h1><ul><li>考研英语真题手译：阅读+翻译+长难句</li><li>于慧真题100篇</li><li>考研英语阅读理解蓝皮书</li><li>黄皮书真题解析</li><li>新东方真题解析</li><li>英语二试卷模考</li><li>英语一试卷模考</li></ul><h1 id="301"><a href="#301" class="headerlink" title=" 301"></a><FONT COLOR = SpringGreen> 301</font></h1><ul><li>660</li><li>狮子AB</li><li>李正元复习全书</li><li>陈文灯复习全书（到时候淘宝买一本）</li><li>李永乐线代讲义</li><li>张宇概率论讲义</li><li>狮子真题+狮子真题串讲梳理视频</li><li>狮子分考点真题解析</li><li>李永乐真题，重点关注薄弱章节</li><li>蔡燧林《考研数学辅导讲义》</li><li>陈维新《线性代数专题剖析》</li><li>余丙森《概率论辅导讲义》</li><li>李林880</li><li>1100题</li><li>各种试卷：合工大往年共创+超越；重点关注薄弱章节</li><li>考研数学笔记</li></ul><h1 id="912预习"><a href="#912预习" class="headerlink" title="912预习"></a><FONT COLOR = SpringGreen>912预习</font></h1><ul><li>王道历年真题</li><li>王道模拟题、天勤模拟题</li><li>王道——计算机专业基础综合考试名校真题解析</li></ul><h1 id="912"><a href="#912" class="headerlink" title="912"></a><FONT COLOR = SpringGreen>912</font></h1><h2 id="数算70"><a href="#数算70" class="headerlink" title="数算70"></a><FONT COLOR = Cyan>数算70</font></h2><p>　　往年的真题和一些清华的期中期末试题，清华课上内容，清华PPT，清华教材与辅导书</p><p>　　说明：往年的真题以及清华的其中期末试题都可以在一些论坛以及github上找到，大家不需要到淘宝上购买。以上罗列的资料非常重要，需要重点学习。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>BBST（红黑 / AVL/Splay/B 树）</td><td>★★★</td><td>★★</td><td>★★★★</td><td>★★</td><td>★★</td></tr><tr><td>散列表</td><td>★</td><td>★</td><td>★★</td><td>★</td><td>★★★</td></tr><tr><td>BST 遍历 / PFS</td><td>★★★★x2</td><td>★★★★★★</td><td></td><td>★★★★★★</td><td>★★★×3</td></tr><tr><td>排序（冒 / 插 / 选 / 基 / 归 / 锦 / 败、CBA）</td><td>★★★★</td><td>★★★★★</td><td>★★</td><td>★★★★</td><td>★★</td></tr><tr><td>串匹配（KMP/BM）</td><td>★★</td><td>★★</td><td>★★</td><td>★</td><td></td></tr><tr><td>复杂度</td><td>★</td><td>★</td><td>★★</td><td>★</td><td></td></tr><tr><td>编码树（Huffman/PFC）</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>RPN</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>减治</td><td></td><td></td><td>★★★</td><td></td><td>★★★</td></tr><tr><td>Catalan</td><td>★</td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>堆（完全、左式堆）</td><td>★★★★★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>栈（调用栈、栈混洗）</td><td></td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>Dijkstra 算法</td><td></td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>跳转表</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>二分、Fib 查找</td><td></td><td></td><td>★★★★★</td><td></td><td></td></tr><tr><td>最小生成树（Prim）</td><td></td><td></td><td></td><td></td><td>★★★</td></tr><tr><td>非法表达式</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>逻辑地址</td><td></td><td></td><td></td><td></td><td>★</td></tr></tbody></table><h2 id="操作系统30"><a href="#操作系统30" class="headerlink" title="操作系统30"></a><FONT COLOR = Cyan>操作系统30</font></h2><p>　　期中期末考题与课件：<a href="http://os.cs.tsinghua.edu.cn/oscourse/FrontPage">http://os.cs.tsinghua.edu.cn/oscourse/FrontPage</a></p><p>　　期中期末考试答案：<a href="https://zhanghuimeng.github.io/">https://zhanghuimeng.github.io</a></p><p>　　simple_os_book、ucore_os_docs、操作系统课程练习：<a href="https://legacy.gitbook.com/@chyyuu">https://legacy.gitbook.com/@chyyuu</a></p><p>　　管程：在912中不止一次考过管程的详细知识。在课程中陈渝老师提到管程是可以让同步互斥的代码不用分散在四处，但是代码中还是两个部分，这里有很多同学产生了困惑，因为这里看起来和PV操作没有什么区别，如<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/kkkkkk/p/5543799.html">这位同学在博客中提到</a></p><p>　　后来经过阅读指导手册的<a href="https://link.zhihu.com/?target=https://chyyuu.gitbooks.io/ucore_os_docs/content/lab7/lab7_3_4_monitors.html">管程和条件变量</a>这一节，我才恍然大悟：管程就是一个类，把所有的同步互斥都当成类方法写在这个类里，类外面加一个锁，只有一个线程能进来。后来又翻到网友写的<a href="https://link.zhihu.com/?target=https://blog.csdn.net/ljbdream00/article/details/83501948">信号量和管程区别</a>也可以帮助理解。</p><p>　　说明：操作系统课程难度大，想要得高分需要投入巨大的时间和精力。其ucore实验部分对于跨考生是极不友好的，大家量力而行，合理取舍。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>uCore 代码</td><td>★★★</td><td>★★★★</td><td>★★★</td><td>★★★</td><td></td></tr><tr><td>虚 / 实地址 (转换 / 扩展)</td><td></td><td>★★★</td><td>★★★</td><td>★★★</td><td></td></tr><tr><td>进程控制 / 系统调用</td><td>★★★★</td><td></td><td>★★★</td><td>★</td><td>★</td></tr><tr><td>管程</td><td></td><td></td><td>★★★★★</td><td>★</td><td></td></tr><tr><td>belady</td><td>★</td><td></td><td>★★★</td><td>★</td><td></td></tr><tr><td>x86 硬件</td><td>★</td><td>★★</td><td></td><td>★</td><td></td></tr><tr><td>信号量</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>死锁</td><td>★</td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>线程</td><td></td><td>★</td><td></td><td>★</td><td>★</td></tr><tr><td>文件系统</td><td>★★★</td><td></td><td></td><td></td><td>★★★</td></tr><tr><td>调度算法</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>僵尸 / 孤儿进程</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>中断</td><td></td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>Cache</td><td>★</td><td></td><td></td><td></td><td>★</td></tr><tr><td>哲学家就餐</td><td></td><td></td><td>★★★</td><td></td><td></td></tr><tr><td>硬 / 软链接</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>stride 算法</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>x86 特权级</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>优先级反置</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>伙伴系统</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>自旋锁</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>动态分区算法</td><td></td><td></td><td></td><td>★</td><td></td></tr><tr><td>RAID</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><h2 id="组原30’"><a href="#组原30’" class="headerlink" title="组原30’"></a><FONT COLOR = Cyan>组原30’</font></h2><p>　　往年真题与清华期中期末试题，刘卫东PPT</p><p>说明：MIPS汇编和流水线时间计算是组成原理中的难点，但又是考察的重点。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>流水线相关计算</td><td>★★★★</td><td>★★★</td><td>★★★</td><td></td><td>★★★</td></tr><tr><td>流水线冲突</td><td>★</td><td>★★★</td><td>★★</td><td>★★★</td><td></td></tr><tr><td>浮点数表示</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>Cache 缺失 / 映射</td><td>★★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>RAID</td><td>★</td><td>★★</td><td>★</td><td></td><td></td></tr><tr><td>补码表示</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>CPU 指标 (CPI / 主频)</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>Cache 相关计算</td><td>★★</td><td></td><td></td><td>★★★</td><td></td></tr><tr><td>指令的概念</td><td>★</td><td></td><td></td><td>★★</td><td></td></tr><tr><td>异常处理 / 中断</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>虚拟内存</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>C 语言</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>总线</td><td></td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>显存带宽计算</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>RAM</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>冯诺依曼架构</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>时序 / 组合逻辑</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>海明码检错 / 纠错</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><h2 id="网络原理20’"><a href="#网络原理20’" class="headerlink" title="网络原理20’"></a><FONT COLOR = Cyan>网络原理20’</font></h2><p>往年的912真题和清华期中期末考题</p><p>说明：这一部分分值不高但是考察的简单，投入较少的时间便能拿到很好的分数。</p><p> 海明码的计算</p><p>统考中3个校验位，4个数据位</p><p>清华考试：4个校验位（包含一个总校验位），3个数据位</p><p>流水线时间</p><p>统考中只有每段的流水时间</p><p>清华这里考虑了每段中间的寄存器时间</p><p>RIP路由协议</p><p>清华这里在RIP协议中有一个水平分割技术：路由器从某个接口接收到的更新信息不允许再从这个接口发回去</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>TCP (拥塞 / 握手 / 报文等)</td><td>★★★</td><td>★★</td><td>★★</td><td></td><td>★★★</td></tr><tr><td>路由器计算</td><td></td><td>★★★</td><td>★★★</td><td>★★★</td><td>★★★</td></tr><tr><td>信道利用率</td><td></td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>ARQ (停等 / 后退 / 选择)</td><td>★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>HTTP</td><td></td><td>★★★</td><td></td><td>★</td><td></td></tr><tr><td>网桥转发</td><td>★</td><td></td><td>★★★</td><td></td><td></td></tr><tr><td>ARP</td><td>★★★</td><td></td><td></td><td></td><td></td></tr><tr><td>物理层设备</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>调制 / 解调</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>水平分裂</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>蜂窝</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>最小帧长</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>以太网</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>分组转发</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>OSI&amp;TCP/IP</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>奈奎斯特定理</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>数据链路层概念</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>DNS</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>SMTP</td><td></td><td></td><td></td><td>★</td><td></td></tr><tr><td>SNMP</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><hr><p>各个学校考研真题：<a href="https://github.com/csseky/cskaoyan">https://github.com/csseky/cskaoyan</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！髀肉复生，搞个大新闻！&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年疾风计划</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/14%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%96%BE%E9%A3%8E%E8%AE%A1%E5%88%92/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/14%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%96%BE%E9%A3%8E%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-06T19:00:00.000Z</published>
    <updated>2021-05-07T22:35:42.831Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！注重效率</FONT></p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><FONT COLOR = SpringGreen>基础</font></h1><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a><FONT COLOR = Cyan>语言基础</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>C</strong></font></p><p>《C primer plus》</p><ul><li>浙大，程序设计入门C语言</li><li>浙大，C语言程序设计进阶</li><li>B站 VS C</li><li>经典 100题</li><li>谭浩强</li><li>贪吃蛇</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Java</strong></font></p><ul><li>浙大，零基础学Java语言</li><li>浙大，面向对象程序设计——Java语言</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Python</strong></font></p><ul><li><p>浙大，Python程序设计</p></li><li><p>北理，Python全家桶</p></li><li><p>Python语言程序设计:AV77405880</p></li><li><p>数据分析与展示:AV73025184</p></li><li><p>科学计算三维可视化:AV73059189</p></li><li><p>机器学习应用:AV73055836</p></li><li><p>网络爬虫与信息提取:AV73060821</p></li><li><p>云端系统开发:AV73032036</p></li><li><p>游戏开发:AV73028956</p></li><li><p>MIT 6.0001</p></li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>C/C++</strong></font></p><p>《C++ Primier》《effective c++》</p><ul><li>北大，计算概论</li><li>北大，程序设计与算法（一）（二）（三）</li><li>北大，程序设计实习</li><li>清华：面向对象程序设计（C++）</li><li>清华，VC++面向对象与可视化程序设计（上）：Windows编程基础</li><li>清华，VC++面向对象与可视化程序设计（下）：MFC编程基础</li><li>侯捷 C++：BV1Ce411x77G  BV1tg4y1872m </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>经典总结</strong></font></p><ul><li>《计算机程序的构造和解释》 + Berkeley 61A，</li><li>Brian Harvey ：BV1Xx41117tr</li><li>学习资料：<a href="https://github.com/DeathKing/Learning-SICP">https://github.com/DeathKing/Learning-SICP</a></li></ul><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a><FONT COLOR = Cyan>汇编基础</font></h2><ul><li>清华 学堂在线 汇编语言程序设计　　</li></ul><h2 id="数电模电"><a href="#数电模电" class="headerlink" title="数电模电"></a><FONT COLOR = Cyan>数电模电</font></h2><p>阎石 《数字电子技术基础》</p><ul><li>国防科大 数字电子技术基础 </li><li>华科 数字电路与逻辑设计</li><li>华科 数字电子技术基础</li><li>华科 模拟电子技术基础</li><li>清华王红 数字电路 BV1F5411t7Cj</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><FONT COLOR = Cyan>补充</font></h2><ul><li><p>万门 大学 计算机科学一月特训班</p></li><li><p>万门大学人工智能一月特训班</p></li><li><p>万门大学数据挖掘一月特训班</p></li></ul><h2 id="912预习"><a href="#912预习" class="headerlink" title="912预习"></a><FONT COLOR = Cyan>912预习</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数据结构预习</strong></font></p><ul><li>阅读：《大话数据结构》、《算法图解》</li><li>武大数据结构教材+浙大数据结构慕课+浙大编程题</li><li>《算法设计手册》 + 斯坦福算法专项 <a href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>组成原理预习</strong></font></p><p>《组成原理黑书》</p><ul><li>华科计算机组成原理</li><li>华科计算机系统结构</li><li>华科慕课计算机硬件系统设计</li><li>计算机原理 国防科技大学 唐玉华</li><li>计算机组成原理 哈工大 刘宏伟 </li><li>北大 组成原理</li><li>袁春风两本书：《计算机组成与系统结构》+《计算机系统基础》+南大袁春风三门课+唐朔飞习题指导+袁春风教材课后练习题</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>操作系统预习</strong></font></p><p>《操作系统导论》《现代操作系统》</p><ul><li>计算机操作系统 南大 骆斌</li><li>操作系统 浙江大学 MOOC</li><li>操作系统原理 哈工大  </li><li>操作系统实验：<a href="https://www.lanqiao.cn/courses/115">https://www.lanqiao.cn/courses/115</a></li><li>伯克利 CS 162</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>计网预习</strong></font></p><p>《自顶向下》</p><ul><li>网络技术与应用 南京邮电</li><li>计算机网络 哈工大 李全龙</li><li>中科大自顶向下：BV1JV411t7ow</li><li>斯坦福计算机网络：BV1wt41167iN</li></ul><h1 id="专业基础课"><a href="#专业基础课" class="headerlink" title="专业基础课"></a><FONT COLOR = SpringGreen>专业基础课</font></h1><h2 id="程序设计基础"><a href="#程序设计基础" class="headerlink" title="程序设计基础"></a><FONT COLOR = Cyan>程序设计基础</font></h2><p>C++语言程序设计基础</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><FONT COLOR = Cyan>面向对象</font></h2><ul><li>C++语言程序设计进阶</li><li>面向对象程序设计（C++）</li></ul><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a><FONT COLOR = Cyan>离散数学</font></h2><h1 id="专业必修"><a href="#专业必修" class="headerlink" title="专业必修"></a><FONT COLOR = SpringGreen>专业必修</font></h1><h2 id="⭐数据结构"><a href="#⭐数据结构" class="headerlink" title="⭐数据结构"></a><FONT COLOR = Cyan>⭐数据结构</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习段</strong></font>：</p><ul><li>新东方（淘宝、PDD、咸鱼，买去年的）：数算巩固阶段（赵海英）+巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华段</strong></font>：</p><ul><li>清华教材+清华的课+武大教材+清华习题解析</li><li>visualgo可视化学习算法、实验楼动手实验</li><li>清华电子稿与示例代码:<a href="https://link.zhihu.com/?target=https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp</a></li><li>注意看学堂在线慕课讨论区</li><li>《数据结构精讲与习题详解——考研辅导与答疑解惑 殷人昆》</li><li>《数据结构习题解析第二版（殷人昆）》</li><li>邓俊辉个人网站：<a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/index.htm">https://dsa.cs.tsinghua.edu.cn/~deng/ds/index.htm</a></li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐算法设计与分析"><a href="#⭐算法设计与分析" class="headerlink" title="⭐算法设计与分析"></a><FONT COLOR = Cyan>⭐算法设计与分析</font></h2><ul><li>北大慕课屈婉玲 + 清华学堂在线王振波 </li><li>《算法笔记》</li><li>《具体数学》</li><li>《算法导论》 MIT算法导论： BV1Tb411M7FA</li><li>《算法》普林斯顿 算法上：BV1Jt411P77c 普林斯顿算法下：BV1M741177FX</li><li>算法训练营</li><li>acwing：y总的《算法基础课》《算法提高课》</li></ul><h2 id="⭐计算机组成原理"><a href="#⭐计算机组成原理" class="headerlink" title="⭐计算机组成原理"></a><FONT COLOR = Cyan>⭐计算机组成原理</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方组成原理（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>《深入理解计算机系统（CSAPP）》，配合B站的课BV1iW411d7hd，实验：<a href="https://github.com/Exely/CSAPP-Labs">https://github.com/Exely/CSAPP-Labs</a></li><li>伯克利 CS61C</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华：</strong></font></p><p>　　清华刘卫东老师的计算机组成原理课的视频与课件</p><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐操作系统"><a href="#⭐操作系统" class="headerlink" title="⭐操作系统"></a><FONT COLOR = Cyan>⭐操作系统</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方操作系统（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>黑书+双汤学习指导</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>基础</strong></font>：</p><ul><li>《Orange’S：一个操作系统的实现》</li><li>《操作系统真象还原》</li><li>《x86汇编语言-从实模式到保护模式》</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华：</strong></font></p><ul><li>清华学堂在线上陈渝和向勇老师讲授的《操作系统》网课</li><li>期中期末考题与课件：<a href="http://os.cs.tsinghua.edu.cn/oscourse/FrontPage">http://os.cs.tsinghua.edu.cn/oscourse/FrontPage</a></li><li>清华simple OS Book：<a href="https://chyyuu.gitbooks.io/simple_os_book/content/">https://chyyuu.gitbooks.io/simple_os_book/content/</a></li><li>OSppt：<a href="https://github.com/LearningOS/os-lectures">https://github.com/LearningOS/os-lectures</a></li><li>清华课程介绍：<a href="https://chyyuu.gitbooks.io/os_course_info/content/">https://chyyuu.gitbooks.io/os_course_info/content/</a></li><li>学习建议：<a href="https://github.com/chyyuu/os_course_info">https://github.com/chyyuu/os_course_info</a></li><li>清华操作系统老版：<a href="https://www.xuetangx.com/course/THU08091000267/5883104">https://www.xuetangx.com/course/THU08091000267/5883104</a></li><li>清华操作系统新版：<a href="https://www.xuetangx.com/course/thu08091002729/3175284">https://www.xuetangx.com/course/thu08091002729/3175284</a></li><li>操作系统实验书：<a href="https://chyyuu.gitbooks.io/simple_os_book/content/">https://chyyuu.gitbooks.io/simple_os_book/content/</a></li><li>清华ucore实验指导书（2015）：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a></li><li>清华ucore实验指导书（2020）：<a href="https://learningos.github.io/ucore_os_webdocs/">https://learningos.github.io/ucore_os_webdocs/</a></li><li>ucore在线实验：<a href="https://www.lanqiao.cn/courses/221/?show_merge_modal=true">https://www.lanqiao.cn/courses/221/?show_merge_modal=true</a></li><li>rcore参考书第二版：<a href="https://rcore-os.github.io/rCore_tutorial_doc/">https://rcore-os.github.io/rCore_tutorial_doc/</a></li><li>rcore参考书第三版：<a href="https://rcore-os.github.io/rCore-Tutorial-deploy/">https://rcore-os.github.io/rCore-Tutorial-deploy/</a></li><li>清华教务处课程主页（期中期末题目）：<a href="http://os.cs.tsinghua.edu.cn/oscourse/">http://os.cs.tsinghua.edu.cn/oscourse/</a></li><li>清华期中期末习题解析，张木辉博客：<a href="https://zhanghuimeng.github.io/">https://zhanghuimeng.github.io</a></li><li>操作系统习题集：<a href="https://chyyuu.gitbooks.io/os_course_exercises/content/">https://chyyuu.gitbooks.io/os_course_exercises/content/</a></li><li>操作系统题库：<a href="https://github.com/chyyuu/os_course_exercise_library">https://github.com/chyyuu/os_course_exercise_library</a></li><li>清华ucore笔记：<a href="https://github.com/XuSiyuan-cn/lcore">https://github.com/XuSiyuan-cn/lcore</a></li><li>注意看学堂在线慕课讨论区：pizza</li><li>清华操作系统课程问答：<a href="https://xuyongjiande.gitbooks.io/os-qa/content/index.html">https://xuyongjiande.gitbooks.io/os-qa/content/index.html</a></li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐计算机网络"><a href="#⭐计算机网络" class="headerlink" title="⭐计算机网络"></a><FONT COLOR = Cyan>⭐计算机网络</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方操作系统（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>黑书+《TCP/IP详解卷1：协议》+谢希仁学习指导</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华</strong></font>：</p><ul><li>清华大学徐明伟老师的计算机网络课程的课件</li><li>MIT6.033</li><li>斯坦福大学计算机网络 CS144</li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="912阶段性总结"><a href="#912阶段性总结" class="headerlink" title="912阶段性总结"></a><FONT COLOR = Cyan>912阶段性总结</font></h2><ul><li>N诺专业题库</li><li>N诺兑换中心机考两本书</li><li>N诺历年真题</li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><FONT COLOR = Cyan>数据库系统</font></h2><ul><li>疾风计划</li><li>数据库系统原理与开发</li><li>哈工大 数据库系统概念</li><li>尚硅谷：BV12b411K7Zu</li><li>伯克利 CS186 BV12x411n7AC</li><li>前沿论文集锦：《Architecture of a Database System》</li></ul><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a><FONT COLOR = Cyan>编译原理</font></h2><p>《Crafting Interpreters》：<a href="https://craftinginterpreters.com/contents.html">https://craftinginterpreters.com/contents.html</a></p><ul><li>疾风计划</li><li>哈工大慕课</li></ul><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a><FONT COLOR = Cyan>软件工程</font></h2><h2 id="算法竞赛预备"><a href="#算法竞赛预备" class="headerlink" title="算法竞赛预备"></a><FONT COLOR = Cyan>算法竞赛预备</font></h2><ul><li>刘汝佳算法三件套  </li><li>《剑指offer》 牛客网上有OJ  </li><li>《编程珠玑》  </li><li>《编程之美》</li><li>LeetCode 刷题+《LeetCode刷题手册（@ PC）》</li><li>考浙大PAT、CCF认证，PAT笔记：<a href="https://ivenwang.com/2019/09/05/pat/">https://ivenwang.com/2019/09/05/pat/</a></li><li>入门《算法笔记》</li><li>强化《挑战程序设计竞赛》</li><li>必刷《程序设计导引及在线实践》</li><li>清北OJ：<a href="https://github.com/jiahao1001/OJ_Guide">https://github.com/jiahao1001/OJ_Guide</a></li><li>清华机试2017-2019真题：<a href="https://xuanxuanblingbling.github.io/life/study/2019/03/11/TUOJ/">https://xuanxuanblingbling.github.io/life/study/2019/03/11/TUOJ/</a></li><li>C++机试技巧：<a href="https://xuanxuanblingbling.github.io/life/study/2019/03/20/oj/">https://xuanxuanblingbling.github.io/life/study/2019/03/20/oj/</a></li><li>C++机试重点：<a href="https://xuanxuanblingbling.github.io/life/study/2019/03/20/STL/">https://xuanxuanblingbling.github.io/life/study/2019/03/20/STL/</a></li></ul><h1 id="专业选修"><a href="#专业选修" class="headerlink" title="专业选修"></a><FONT COLOR = SpringGreen>专业选修</font></h1><h2 id="linux操作系统"><a href="#linux操作系统" class="headerlink" title="linux操作系统"></a><FONT COLOR = Cyan>linux操作系统</font></h2><ul><li>《C语言中文网学学linux教程》   </li><li>慕课：操作系统与Linux内核</li><li>学堂在线：Linux内核分析与应用</li><li>疾风计划</li><li>《linux内核设计与实现》<br>《鸟哥的linux私房菜》   </li></ul><h2 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a><FONT COLOR = Cyan>嵌入式系统</font></h2><p>　　微控制器与嵌入式系统</p><h2 id="网络安全技术"><a href="#网络安全技术" class="headerlink" title="网络安全技术"></a><FONT COLOR = Cyan>网络安全技术</font></h2><h2 id="软件理论基础"><a href="#软件理论基础" class="headerlink" title="软件理论基础"></a><FONT COLOR = Cyan>软件理论基础</font></h2><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a><FONT COLOR = Cyan>软件测试</font></h2><h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a><FONT COLOR = Cyan>数据挖掘</font></h2><p>　　数据挖掘：理论与算法</p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a><FONT COLOR = Cyan>人工智能</font></h2><p>《人工智能 一种现代方法》 + 伯克利AI：<a href="http://ai.berkeley.edu/home.html">http://ai.berkeley.edu/home.html</a>  </p><ul><li>大数据机器学习</li><li>人工智能原理</li><li>深度学习基础</li></ul><h2 id="大数据系统"><a href="#大数据系统" class="headerlink" title="大数据系统"></a><FONT COLOR = Cyan>大数据系统</font></h2><p>　　大数据平台核心技术</p><h2 id="物联网概论"><a href="#物联网概论" class="headerlink" title="物联网概论"></a><FONT COLOR = Cyan>物联网概论</font></h2><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a><FONT COLOR = Cyan>组合数学</font></h2><h1 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a><FONT COLOR = SpringGreen>综合实践</font></h1><h2 id="科研预备"><a href="#科研预备" class="headerlink" title="科研预备"></a><FONT COLOR = Cyan>科研预备</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>西瓜书</strong></font>：  </p><ul><li>《西瓜书手推笔记》（@PC）</li><li>一起啃书：BV17J411C7zZ  </li><li>南瓜书： <a href="https://github.com/datawhalechina/pumpkin-book%E3%80%81">https://github.com/datawhalechina/pumpkin-book、</a>  </li><li>吴恩达机器学习：<a href="https://study.163.com/course/courseLearn.htm?courseId=1004570029#/learn/video?lessonId=1049052745&amp;courseId=1004570029">https://study.163.com/course/courseLearn.htm?courseId=1004570029#/learn/video?lessonId=1049052745&amp;courseId=1004570029</a>  </li><li>吴恩达笔记：<a href="https://github.com/fengdu78/deeplearning_ai_books">https://github.com/fengdu78/deeplearning_ai_books</a>  </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>统计学习方法</strong></font>：  </p><ul><li>算法实现：<a href="https://github.com/WenDesi/lihang_book_algorithm">https://github.com/WenDesi/lihang_book_algorithm</a>  </li><li>深度之眼视频：BV1i4411G7Xv  </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>花书</strong></font>：  </p><ul><li>一起啃书：BV1HJ41177E9  </li><li>深度之眼：BV1kE4119726  </li><li>李宏毅的《深度学习》  +《李宏毅深度学习PPT》@PC+《一天搞懂深度学习（台大李宏毅）》@PC</li></ul><h2 id="斯坦福套餐："><a href="#斯坦福套餐：" class="headerlink" title="斯坦福套餐："></a><FONT COLOR = Cyan>斯坦福套餐</font>：</h2><ul><li>CS231N(计算机视觉)<br>计算机图形学：伯克利CS 184；《计算机图形学 原理及实践》</li><li>CS224D(自然语言处理)</li><li>CS229(机器学习)</li><li>CS230（深度学习）</li><li>CS234（强化学习）</li></ul><h2 id="算法提升"><a href="#算法提升" class="headerlink" title="算法提升"></a><FONT COLOR = Cyan>算法提升</font></h2><ul><li>邓俊辉算法训练营第一期（PC）</li><li>北大算法专项课程（收藏夹）</li><li>斯坦福数算专项（收藏夹）</li><li>加州大学数算专项（收藏夹）</li><li>约翰霍普金斯数据科学专项课程（收藏夹）</li><li>华盛顿大学机器学习专项（收藏夹）</li><li>密歇根大学Python应用专项（收藏夹）</li><li>MIT：算法设计与分析、算法导论、高级数据结构、MIT高级算法</li><li>普林斯顿：算法</li></ul><h1 id="算法竞赛"><a href="#算法竞赛" class="headerlink" title="算法竞赛"></a><FONT COLOR = SpringGreen>算法竞赛</font></h1><p>　　比如参加一个data mining相关的比赛：上天池大数据，Kaggle，KDD等参加一个或两个比赛。最简单快速的方法是：找到案例代码，先搞懂别人的算法是怎么做的，然后再自己去尝试一些方法，这期间能帮助你掌握很多东西。我举个例子：拿到已有的特征，你可以尝试朴素贝叶斯，决策树，SVM，随机森林，梯度提升树等等方法。如果案例已经有了，你可以在github上面找到更多的开源工具去尝试新的方法，并掌握其原理。这一个比赛，你可以记录整个过程你尝试过的算法。对于充实简历非常有效。比赛驱动是我认为最有效，最快速上手的办法。</p><p>　　参加天池、Kaggle竞赛，去阴阳网搜BRYAN&amp;收藏夹，取经 去GitHub学习冠军代码</p><h2 id="竞赛项目"><a href="#竞赛项目" class="headerlink" title="竞赛项目"></a><FONT COLOR = Cyan>竞赛项目</font></h2><p>Kaggle：<a href="https://www.kaggle.com/">https://www.kaggle.com</a><br>天池：<a href="https://tianchi.aliyun.com/home">https://tianchi.aliyun.com/home</a><br>DataCastle：<a href="http://www.pkbigdata.com/">http://www.pkbigdata.com</a><br>Datafountain：<a href="https://www.datafountain.cn/">https://www.datafountain.cn</a><br>Biendata：<a href="https://www.biendata.com/">https://www.biendata.com</a><br>AI Challenger：<a href="https://challenger.ai/">https://challenger.ai</a><br>Kesci：<a href="https://www.kesci.com/">https://www.kesci.com</a><br>FlyAI：<a href="https://www.flyai.com/">https://www.flyai.com</a><br>腾讯广告算法大赛<br>之江杯<br>KDD-CUP<br>工业大数据产业创新平台<br>JDDC（京东）京东：<a href="https://jdata.jd.com/">https://jdata.jd.com/</a><br>Google Code Jam<br>Facebook 举办的 hackercup<br>Topcoder 举办的 TCO 比赛<br>百度每年举办的百度之星<br>微软举办的编程之美<br>华为每年都会举办一个全国性的软件精英挑战赛</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！注重效率&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年301数学</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/13%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4301%E6%95%B0%E5%AD%A6/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/13%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4301%E6%95%B0%E5%AD%A6/</id>
    <published>2021-05-06T18:00:00.000Z</published>
    <updated>2021-05-07T08:12:54.042Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！学好数学</FONT></p><a id="more"></a><h1 id="数分"><a href="#数分" class="headerlink" title="数分"></a><FONT COLOR = SpringGreen>数分</font></h1><ul><li>北大教材（配徐森林、史贤林、清华丘班讲义）</li><li>浙大课程</li><li>狮子课程+狮子讲义</li><li>浙大辅导书</li><li>史老师数分课</li><li>MIT全家桶（单变量微积分、多变量微积分、微积分重点、微分方程、单变量微积分习题课、多变量微积分习题课）</li></ul><h1 id="线代"><a href="#线代" class="headerlink" title="线代"></a><FONT COLOR = SpringGreen>线代</font></h1><ul><li>复旦教材</li><li>科大课程</li><li>狮子课程+狮子讲义</li><li>人大辅导书</li><li>复旦课程+复旦习题课</li><li>MIT全家桶（线性代数、线性代数习题课）</li></ul><h1 id="概统"><a href="#概统" class="headerlink" title="概统"></a><FONT COLOR = SpringGreen>概统</font></h1><ul><li>科大教材+科大课程</li><li>狮子课程+狮子讲义</li><li>北大辅导书（哈佛统计：BV124411P7Rj）</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a><FONT COLOR = SpringGreen>补充</font></h1><ul><li>高昆仑18讲</li><li>李永乐线代</li><li>方浩概统</li><li>高数证明题专题</li><li>主观综合题串讲</li><li>排位考</li><li>3Blue1Brown 的视频</li></ul><h1 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a><FONT COLOR = SpringGreen>数值分析</font></h1><ul><li>华科教材+华科研究生视频</li><li>清华学堂在线，数值分析与算法</li></ul><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a><FONT COLOR = SpringGreen>数学建模</font></h1><ul><li>谢金星教材+清华B站课程</li></ul><h1 id="复变函数"><a href="#复变函数" class="headerlink" title="复变函数"></a><FONT COLOR = SpringGreen>复变函数</font></h1><ul><li>华科教材+华科复变函数的课</li></ul><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a><FONT COLOR = SpringGreen>离散数学</font></h1><ul><li>北大教材+北大视频</li><li>《计算机科学中的数学》：BV1nx411D7xz，MIT</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！学好数学&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年201英语</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/12%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4201%E8%8B%B1%E8%AF%AD/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/12%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4201%E8%8B%B1%E8%AF%AD/</id>
    <published>2021-05-06T17:00:00.000Z</published>
    <updated>2021-05-07T08:12:53.027Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！从认真学英语开始！</FONT></p><a id="more"></a><h1 id="基础段"><a href="#基础段" class="headerlink" title="基础段"></a><FONT COLOR = SpringGreen>基础段</font></h1><p>预习→听课→听写→复习笔记</p><ul><li>新3 裕兴</li><li>新4 蒋军虎</li><li>英语语法新思维初级、中级、高级 课+教材</li></ul><h1 id="考研段"><a href="#考研段" class="headerlink" title="考研段"></a><FONT COLOR = SpringGreen>考研段</font></h1><ul><li>商志传奇背词班+蓝皮书</li><li>商志翻译精讲、陈正康翻译+蓝皮书</li><li>李玉技完型、商志完型+蓝皮书</li><li>商志新题型、李玉技新题型+蓝皮书</li><li>石雷鹏作文+商志作文书+朱伟写作宝典+潘赟九宫格+《见山作文模板》。总结出自己的写作模板</li><li>慕课阅读：英语科技文献阅读、大学英语学术阅读、科技英语语法、科技英语</li><li>慕课写作：大学英语写作基础、英语语法与写作、大学英语过程写作</li><li>慕课口语：大学英语（口语）、学术交流英语、通用学术英语</li><li>自学顾家北雅思写作两本书</li></ul><h1 id="雅思段"><a href="#雅思段" class="headerlink" title="雅思段"></a><FONT COLOR = SpringGreen>雅思段</font></h1><ul><li>王陆听力</li><li>剑雅口语</li><li>新东方雅思7分直达（百度网盘）</li><li>万门大学雅思课（百度网盘）</li><li>剑桥雅思10本书，一周精读一本</li></ul><p><strong>学完后去考雅思，目标7.5分</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！从认真学英语开始！&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021全年打算</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/11%202021%E5%85%A8%E5%B9%B4%E6%89%93%E7%AE%97/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/11%202021%E5%85%A8%E5%B9%B4%E6%89%93%E7%AE%97/</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-07T21:41:56.479Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！</FONT></p><a id="more"></a><h1 id="健康生活"><a href="#健康生活" class="headerlink" title="健康生活"></a><FONT COLOR = SpringGreen>健康生活</font></h1><p><strong>高效学习的前提是健康的身体</strong></p><p>　　睡眠一定要好<br>　　保持饮食清淡，吃低糖，高蛋白，高维生素<br>　　每天有氧运动 1 h<br>　　躺在床上不能玩手机<br>　　早上起来晒太阳  </p><h1 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a><FONT COLOR = SpringGreen>刻意练习</font></h1><p><strong>刻意去练习自己的大脑</strong></p><p>　　让大脑去做更费力的事情<br>　　每一次感到大脑在很吃力地思考时，大脑都在不知不觉间比以前更聪明一点  </p><h1 id="高效学习"><a href="#高效学习" class="headerlink" title="高效学习"></a><FONT COLOR = SpringGreen>高效学习</font></h1><h2 id="检索式练习"><a href="#检索式练习" class="headerlink" title="检索式练习"></a><FONT COLOR = Cyan>检索式练习</font></h2><p>　　反复阅读教材是十分低效的。与其一遍遍看书，不如在大脑中进行检索式练习，检索可以强化记忆，并阻止遗忘。<br>　　<FONT COLOR = LimeGreen>检索式练习，是指回想事实、概念或事件，也就是将存储在记忆中的知识点提取到意识中的过程。</font>通过检索练习，相应的神经回路会被强化，该知识点会在我们的记忆中储存得更久，同时日后回想该知识点也会更迅速。我们在提取记忆时付出的努力越大，在想起来后，这项记忆的提取能力和储存能力得到的提高也就会越大，这是因为费劲回忆的过程本身，就是对记忆的储存能力和提取能力的强化。<br>　　总的来说，越是费脑的学习方法，比如回忆知识点、背诵默写、做题、考试、把新学的知识点讲给别人听，越是能帮我们掌握知识、保持长期记忆，而轻松的不用动脑筋的学习方法，比如翻来覆去地看书、看视频，则通常很快就会将知识完全忘掉。  </p><p>　　具体来说，可以在学完新的章节后合上书本（或者看完一集学习视频后暂停播放），一边回忆一边画出这一章节的脑图，回想刚刚学过的所有知识点和概念（检索式练习），用自己的语言将新学的知识点表达出来，也就是假想我们正在给别人讲解这个知识点<strong>（</strong>费曼学习法），并与以前学过的知识点相联系（将知识细化、建立联系），新旧知识的关联越多，越能掌握新知识。（从新知识中提取关键概念，组织成心智模型，并与大脑中已有的心智模型联系起来）</p><p>　　<FONT COLOR = LimeGreen>检索记忆 + 做习题 + 考试自测，是高效学习，对抗遗忘的最好办法。</font></p><h2 id="穿插式学习"><a href="#穿插式学习" class="headerlink" title="穿插式学习"></a><FONT COLOR = Cyan>穿插式学习</font></h2><p>　　穿插式学习会增大检索难度，但能让学习效果更持久。<br>　　<FONT COLOR = LimeGreen>穿插学习，就是把既相关、又不同的学习内容混合在一起学习。 </font><br>　　具体应用在考研数学上，可以把高数、线代、概率论的知识点混在一起交替学习，而不是先看完高数，再看线代，再看概率论，做题时也可以把高数、线代、概率的题目混在一起做而不是分开做。穿插式学习要求我们辨别不同知识的区别，深化我们对知识的理解，比起简单的重复，能让我们把知识点掌握的更牢、更持久。相应的，集中式学习、填鸭式学习，也就是大学期末两天时间集中地学完一门课的方法，虽然能取得不错的短期记忆效果，但也会很快遗忘。穿插不同内容的学习，虽然增大了学习的难度，但记忆效果更持久。  </p><h2 id="间隔式学习"><a href="#间隔式学习" class="headerlink" title="间隔式学习"></a><FONT COLOR = Cyan>间隔式学习</font></h2><p>　　学习需要有间隔，短时间内快速连续地学完一门课的效果并不好，正确的方法应当是：学习新东西——间隔几天产生遗忘——检索回忆、做习题、复习——继续学习新的章节，这样一个流程下来更容易产生长期记忆，不要害怕中间的遗忘，当我们的大脑经过中间间隔的那几天的睡眠修复和遗忘过程后，再进行检索和复习，可以让你产生新的理解，也能让你的记忆联结更牢固。也就是说，跟连续几天都学一科相比，每天学一科换着来可以记得更牢。<br>　　具体应用在专业课上，我们可以第一天学数据结构、第二天学机组、第三天学操作系统、第四天学计网、第五天继续学数据结构……循环着来，这样间隔学习的效果，比先学完数据结构、再学完机组、再依次学完操作系统和计网的记忆更牢固。通过适当的学习间隔，也就是在你完全遗忘之前所学的东西前，进行“间隔遗忘式学习”，才是符合大脑记忆机制的学习方法。  </p><h2 id="重复即真理"><a href="#重复即真理" class="headerlink" title="重复即真理"></a><FONT COLOR = Cyan>重复即真理</font></h2><p>　　记忆的终极秘诀在于“重复”，每学完新的章节，我们应该对之前学过的所有章节进行及时的复习，复习的过程同样采取“检索记忆”和“练习测验”的办法，针对检索和测验过程中发现的记忆薄弱点，再有针对性地回去看教材上的知识点讲解。这样，我们每次学习新的内容，都要花很长的时间检索记忆、练习测验和复习巩固，虽然看起来速度慢了很多，但是只要学过的就不会忘。<FONT COLOR = LimeGreen>要记住，少即是多，慢即是快，笨办法最有效。</font></p><h1 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a><FONT COLOR = SpringGreen>学习方法</font></h1><ul><li><FONT COLOR = LimeGreen>听课</font>：做好预习工作 → 听课的时候专心跟着老师的思路 → 课后整理脑图 →  再看一遍视频整理笔记。</li><li><FONT COLOR = LimeGreen>检索式练习</font>：每节课结束后，像放电影一样去回忆知识点，把定义、定理、公式具象化。也可以尝试花脑图。</li><li><FONT COLOR = LimeGreen>费曼学习法</font>：用自己的语言把知识点重新讲述一遍。</li><li><FONT COLOR = LimeGreen>冥想学习</font>：每天闲暇时间，把之前的知识点，定义、定理、证明在自己脑中推演一遍。</li><li><FONT COLOR = LimeGreen>穿插与间隔</font>：各个科目应该穿插起来，短时间内突击一个科目，学得快忘得也快。</li><li>每个章节结束后，不看书，只看目录，画一张脑图。</li></ul><p>　　总而言之，越是费脑的学习方法越有效。<FONT COLOR = LimeGreen>轻松地学习</font>——重复输入、单纯地记录而不思考，这都是伪勤奋，表面上勤奋，实际上没有锻炼大脑；倾向于轻松简单的学习方式，而不愿意真正动脑筋去思考问题——<FONT COLOR = LimeGreen>等于没学，费力地动脑子</font>——理解消化知识点、尝试提取记忆和输出——<FONT COLOR = LimeGreen>才是真正地在学</font>。<br>　　<FONT COLOR = LimeGreen>学习过程越是困难，学习方法越是费脑筋，记忆就越牢固，对知识的掌握就越深刻。轻松地学习等于没学。</font>  </p><h1 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a><FONT COLOR = SpringGreen>上半年</font></h1><ul><li>参加疾风计划，一年30+门课。给自己设置ddl开肝</li><li>可能加一个清华数据科学认证、北邮人工智能认证。</li><li>数据竞赛、程序设计竞赛。</li><li>课外学习一些东西，比如王立群和yes minister</li></ul><h1 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a><FONT COLOR = SpringGreen>下半年</font></h1><ul><li>肝T</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>3月的结束</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/</id>
    <published>2021-03-23T18:12:28.075Z</published>
    <updated>2021-03-23T18:12:28.262Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>三月快结束啦</FONT></p><a id="more"></a><p>还没准备好呢，今年就已经过去一个季度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(P的分数高&amp;&amp;科目不变)&#123;</span><br><span class="line">瞄准一波P;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;三月快结束啦&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter 16 Interactive Graphic Design</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/</id>
    <published>2021-03-16T13:59:47.000Z</published>
    <updated>2021-03-29T05:41:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>交互图形设计</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;交互图形设计&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 15 ACLLib</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/</id>
    <published>2021-03-15T13:59:47.000Z</published>
    <updated>2021-04-06T03:09:29.856Z</updated>
    
    <content type="html"><![CDATA[<p>ACLLib的基本图形函数</p><a id="more"></a><h1 id="ACLLib介绍"><a href="#ACLLib介绍" class="headerlink" title="ACLLib介绍"></a><FONT COLOR = SpringGreen>ACLLib介绍</font></h1><h1 id="Win32API"><a href="#Win32API" class="headerlink" title="Win32API"></a><FONT COLOR = SpringGreen>Win32API</font></h1><h1 id="创建ACLLIB程序"><a href="#创建ACLLIB程序" class="headerlink" title="创建ACLLIB程序"></a><FONT COLOR = SpringGreen>创建ACLLIB程序</font></h1><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a><FONT COLOR = SpringGreen>基本绘图函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;ACLLib的基本图形函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 14 Linked List</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/</id>
    <published>2021-03-14T13:59:47.000Z</published>
    <updated>2021-04-06T03:08:20.467Z</updated>
    
    <content type="html"><![CDATA[<p>链表</p><a id="more"></a><h1 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a><FONT COLOR = SpringGreen>可变数组</font></h1><h1 id="可变数组数据访问"><a href="#可变数组数据访问" class="headerlink" title="可变数组数据访问"></a><FONT COLOR = SpringGreen>可变数组数据访问</font></h1><h1 id="可变数组自动增长"><a href="#可变数组自动增长" class="headerlink" title="可变数组自动增长"></a><FONT COLOR = SpringGreen>可变数组自动增长</font></h1><h1 id="可变数组的缺陷"><a href="#可变数组的缺陷" class="headerlink" title="可变数组的缺陷"></a><FONT COLOR = SpringGreen>可变数组的缺陷</font></h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><FONT COLOR = SpringGreen>链表</font></h1><h1 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a><FONT COLOR = SpringGreen>链表的函数</font></h1><h1 id="链表的搜索"><a href="#链表的搜索" class="headerlink" title="链表的搜索"></a><FONT COLOR = SpringGreen>链表的搜索</font></h1><h1 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a><FONT COLOR = SpringGreen>链表的删除</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 13 File</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/</id>
    <published>2021-03-13T13:59:47.000Z</published>
    <updated>2021-04-06T03:06:42.074Z</updated>
    
    <content type="html"><![CDATA[<p>文件</p><a id="more"></a><h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a><FONT COLOR = SpringGreen>格式化输入输出</font></h1><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a><FONT COLOR = SpringGreen>文件输入输出</font></h1><h1 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a><FONT COLOR = SpringGreen>二进制文件</font></h1><h1 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a><FONT COLOR = SpringGreen>按位运算</font></h1><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a><FONT COLOR = SpringGreen>移位运算</font></h1><h1 id="位运算例子"><a href="#位运算例子" class="headerlink" title="位运算例子"></a><FONT COLOR = SpringGreen>位运算例子</font></h1><h1 id="位段"><a href="#位段" class="headerlink" title="位段"></a><FONT COLOR = SpringGreen>位段</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 12 Program Structure</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/</id>
    <published>2021-03-12T13:59:47.000Z</published>
    <updated>2021-04-06T03:05:10.506Z</updated>
    
    <content type="html"><![CDATA[<p>程序结构</p><a id="more"></a><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><FONT COLOR = SpringGreen>全局变量</font></h1><h1 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a><FONT COLOR = SpringGreen>静态本地变量</font></h1><h1 id="全局变量tips"><a href="#全局变量tips" class="headerlink" title="全局变量tips"></a><FONT COLOR = SpringGreen>全局变量tips</font></h1><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a><FONT COLOR = SpringGreen>宏定义</font></h1><h1 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a><FONT COLOR = SpringGreen>带参数的宏</font></h1><h1 id="大程序"><a href="#大程序" class="headerlink" title="大程序"></a><FONT COLOR = SpringGreen>大程序</font></h1><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><FONT COLOR = SpringGreen>头文件</font></h1><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><FONT COLOR = SpringGreen>声明</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序结构&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 11 Structure Type</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/</id>
    <published>2021-03-11T13:59:47.000Z</published>
    <updated>2021-04-06T03:03:15.693Z</updated>
    
    <content type="html"><![CDATA[<p>结构类型</p><a id="more"></a><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><FONT COLOR = SpringGreen>枚举</font></h1><h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a><FONT COLOR = SpringGreen>结构类型</font></h1><h1 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a><FONT COLOR = SpringGreen>结构与函数</font></h1><h1 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a><FONT COLOR = SpringGreen>结构中的结构</font></h1><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a><FONT COLOR = SpringGreen>类型定义</font></h1><h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a><FONT COLOR = SpringGreen>联合</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;结构类型&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 10 Strings</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/</id>
    <published>2021-03-11T12:59:47.000Z</published>
    <updated>2021-04-27T10:34:56.413Z</updated>
    
    <content type="html"><![CDATA[<p>字符串</p><a id="more"></a><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><FONT COLOR = SpringGreen>字符串</font></h1><p>　　首先尝试定义一个字符数组：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;&#125; ;</code>。但这个东西只能算是字符数组，不是字符串，因为不能用字符串的方式做计算。</p><img src="https://www.hualigs.cn/image/606f00ffc435f.jpg" style="zoom:50%;" /><p>　　于是在字符数组上加点东西就变成了字符串：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;,&#39;\0&#39;&#125; ;</code>    在数组初始化的最后加一个<code>&#39;\0&#39;</code>或者<code>0</code>。此时字符数组一共有七个单元，最后的单元是一个0，此时这个东西即是字符数组，也是字符串。</p><img src="https://www.hualigs.cn/image/606f017eb0c38.jpg" style="zoom:50%;" /><p>　　<FONT COLOR = LimeGreen>何为字符串</font>：</p><p>　　字符串是以 0 （整数0）结尾的一串字符。0 和 ‘\0’ 是一样的，但是和 ‘0’ 不同。非要说差别，0 表示一个 int （整数，四个字节）；‘\0’ 表示数组里面的一个元素，是一个 char ，是一个字节； ‘0’是一个字符， 这个字符表示Acall码里面的 0 ，是<code>0x30</code>，是48。<br>　　0 标志着字符串的结束，但它不是字符串的一部分。计算<u>字符串</u>长度的时候不包含这个0。<br>　　字符串在内存中以数组的形式存在，以数组或指针的形式去访问。更多的是以指针的形式。<br>　　<code>&lt;string.h&gt;</code>里有很多处理字符串的函数。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a><FONT COLOR = Cyan>字符串常量</font></h2><p>　　“hello”像这样子的东西，由双引号括起来的，就叫做字符串常量，或者字符串字面量。他会被编译器变成一个字符数组放在某处，这个数组的长度是 6 ，结尾还有表示结束的 0 。<br>　　两个相邻的字符串常量会被自动连接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，&quot;</span></span><br><span class="line"><span class="string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　<img src="https://www.hualigs.cn/image/606f08bde26b4.jpg"></p><p>　　可以看见，这是两个字符串，中间什么都没有，但是输出的时候自动连接在了一起。对于C语言来说，如果有两个相邻的字符串，中间没有任何其他符号，他会自动把这两个字符串连接起来。<br>　　也可以如此输入，将两端字符串接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，\</span></span><br><span class="line"><span class="string">如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　把第一行末尾表示字符串结束的引号去掉，加一个反斜杠，然后把下面两个 tab 去掉，然后把引号去掉，也会输入像上面那样的结果。</p><p>　　总的来说，C语言的字符串是以字符数组的形态存在的。所以不能用常规的运算符加减乘除对字符串进行运算。可以通过数组的方式来遍历字符串。<br>　　唯一特殊的地方，就是可以通过字符串字面量（双引号的东西）来初始化字符数组。</p><h1 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a><FONT COLOR = SpringGreen>字符串变量</font></h1><p>　　首先是如何定义去定义一个变量，让这个变量去表达字符串？字符串也是数组，所以下面的变量本质上也是字符数组的变量，只不过有特殊的表现形式。：<br>　　<code>char *str = &quot;hello&quot; ;</code>定义一个指针 str，初始化为指向一个字符串常量，该字符串常量里的内容是 hello。<br>　　<code>char word[] = &quot;hello&quot; ;</code>在这个地方定义一个字符数组，里面的内容是 hello<br>　　<code>char line[10] = &quot;hello&quot; ;</code>在这里定义一个字符数组 line，长度为10（10个字节），在这个数组里面放了 hello 。hello 是五个字符，在数组里要占据6个字节的空间（结尾有一个0）。<Font Size = 2>字符串变量写出来之后，编译器会自己在末尾加一个0</font></p><p>　　试图对字符串变量做一点点修改，尝试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here s[0] = %c\n&quot;</span>,s[<span class="number">0</span>]) ;</span><br></pre></td></tr></table></figure><p>　　这段代码尝试把首字母改一下，有的编译器会通过编译；有的编译器不会报错，但是运行时会出错：</p><blockquote><p>Bus error : 10 </p><p>segmentation fault</p></blockquote><p>　　尝试一件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> * s2 = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br></pre></td></tr></table></figure><p>　　此时会发现一件神奇的事情：</p><p><img src="https://www.hualigs.cn/image/606f9f6d014fe.jpg"></p><p>　　s 和 s2 指向的地址是一样的，都是<code>0x1</code>。做了两个字符串变量，用了相同的字面量来初始化，结果他们指向的地址是相同的。然后相比之下，i 的地址非常的大，而 s 的地址非常的小，相距非常远。i s s2 本身是非常正常的，紧紧挨在一起：</p><p><img src="https://ae01.alicdn.com/kf/U292c7faeb71e4800be85aead7eeac31fg.jpg"></p><p>　　i s s2 这些东西在大地址上，称之为本地变量。hello world 在一个很小的地址上，这个很小的地址叫做代码端，而且这个地址一旦定义完毕后，是只读的。如果在代码端的东西进行写入动作，比如<code>s[0] = &#39;B&#39; ;</code>，此时操作系统就会启动自动保护机制，让程序崩溃。<br>　　<FONT COLOR = LimeGreen>所以字符串常量所在的地方，实际上是<code>const char *s = “hello world” ；</code>。但是由于历史的原因，编译器接受不带<code>const</code>的写法，但是试图对 s 所指的字符串做写入，会导致严重的后果。</font></p><p>　　如果想要修改字符串，应该使用数组：<code>char s[] = &quot;hello world&quot; ;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> s2[] = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,&amp;s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,&amp;s2) ;</span><br></pre></td></tr></table></figure><p>　　这两种写法的区别就在于，定义指针的意思是，在代码端有这么个字符串常量，s 指向那里。定义数组的意思是，我这里有一个字符串常量，就在这里：</p><p><img src="https://www.hualigs.cn/image/60704315a20fe.jpg"></p><p>　　<FONT COLOR = LimeGreen>如果合理选择指针定义还是数组定义呢？</font></p><p>　　<code>char s[] = &quot;hello world&quot; ;</code>数组定义：这个字符串在这里，将来会作为本地变量空间自动被回收。<br>　　<code>char *s = &quot;hello world&quot; ;</code>指针定义：这个字符串不知道在哪里。<br>　　用来表达只读文件；<br>　　处理函数的参数。当作为函数参数时，数组 == 指针，反正进去的都是指针。<br>　　动态分配空间。如果字符串的空间是 <code>malloc</code> 得到的，此时字符串只能用指针。</p><p>　　总之，如果要构造一个字符串——数组；如果要处理一个字符串——指针。</p><p>　　有一个文字游戏，<code>char *</code>就一定是字符串吗？显然不是。<br>　　字符串可以表达为<code>char *</code>的形式。但<code>char *</code>不一定是字符串。因为它本意是指向字符的指针，可能指向的是字符的数组（和<code>int *</code>一样）。只有它所指的字符数组有结尾的 0 ，才能说它指的是字符串。</p><h1 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a><FONT COLOR = SpringGreen>字符串输入输出</font></h1><p>　　C语言对字符串的处理，是C语言最大的短板，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *t = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> *s ;</span><br><span class="line">s = t ;</span><br></pre></td></tr></table></figure><p>　　此时启示并没有产生新的字符串，只是让指针 s 指向了 t 所指的字符串，对 s 的任何操作就是对 t 做的。</p><p><img src="https://www.hualigs.cn/image/60705d3504e85.jpg"></p><h2 id="s-输入输出"><a href="#s-输入输出" class="headerlink" title="%s 输入输出"></a><FONT COLOR = Cyan>%s 输入输出</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ; <span class="comment">//定义长度为 8 的字符的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ; <span class="comment">//由于定义了数组，这里不用加 &amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##\n&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　如果输入 hello world。会看到只会输出 hello## ，而后面的 world 不会输出。而且读入hello的时候，没有包含输入的那个空格。如果稍微改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br></pre></td></tr></table></figure><p>　　如果输入<code>hello world</code>，此时会输出<code>hello##world##</code>。可以刻按到，第一个<code>scanf</code>读到的是 hello 不带空格，第二个<code>scanf</code>读到的是 world 也不带空格。因为用户输入的空格在这里是分隔符。同理，如果输入<code>hello 回车 world</code>，此时会输出<code>hello##world##</code>。因为此时的空格、回车，在 %s 眼里都只是分隔符：<br>　　<FONT COLOR = LimeGreen><code>%s</code>读入一个单词（不是语言上的单词，而是读一串字母，到空格、tab、回车为止）</font>。此时的<code>scanf</code>是非常不安全的，因为不知道要读入的内容的长度。</p><h2 id="安全输入"><a href="#安全输入" class="headerlink" title="安全输入"></a><FONT COLOR = Cyan>安全输入</font></h2><p>　　<code>scanf(&quot;%7s&quot;,string)</code>，在 % 和 s 之间的数字表示最多允许读入的字符的数量，这个数字应该要比数组的大小小1（最后一位要放0）。如果就读了那么多个，比如说此时<code>scanf</code>就读到了7个数，那么<code>scanf</code>就此停止，不再依据空格或者回车来判断单词。<br>　　如果输入的数量超过了规定的个数，那么剩下的东西交给下一个<code>scanf</code>来做。<br>　　比如上述程序，定义的字符数组是8个单位，实际上只能写入7个字符，比如输入12345678：程序可能会出现输入错误（不同编译器表现错误的方式不一样）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果是严格的编译器，此时会报错：</p><blockquote><p>about trap: 6</p><p>数组越界导致程序崩溃</p></blockquote><p>　　解决办法，限定输入大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,<span class="built_in">string</span>) ;<span class="comment">//最多只能读前 7 个字符，超过 7 个字符就不要了。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果此时输入<code>12345678</code>。会发现输出结果是<code>1234567##8##</code>。因为第一个<code>scanf</code>取了前七个数，第八个数就自动去满足下一个<code>scanf</code>。此时程序会只读入一次。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>char *</code>的本质是指针</strong></font></p><p>　　误以为，<code>char *</code>就是字符串类型，误以为这样就是定义了一个字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> ;<span class="comment">//本质是定义一个指针变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时这个指针变量没有被初始化，不知道这个指针去指向哪里，如果此时这个指针指向了“只读的地方”，这种不能写入的地方，就会出错。<br>　　此时就是有可能错，有可能正常。</p><p>　　此时应该先让指针指向一个有效的地址。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>空字符串</strong></font></p><p>　　<code>char buffer[100] = &quot;&quot; ;</code>，此时这个字符串是一个空的字符串，<code>buffer[0] == &#39;\0&#39;</code><br>　　如果写成：<code>char buffer[] = &quot;&quot; ;</code>，此时这个数组的长度只有1，<code>buffer[0] == &#39;\0&#39;</code>，除此之外就没有元素了，无法写入任何东西。</p><h1 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a><FONT COLOR = SpringGreen>字符串数组</font></h1><p>　　如果想让一个数组去表示很多字符串，如何表示？</p><h2 id="char-a"><a href="#char-a" class="headerlink" title="char **a"></a><FONT COLOR = Cyan><code>char **a</code></font></h2><p>　　这句话的意思是，a 是一个指针， 这个指针指向另一个指针，那个指针指向一个字符，或者字符串。</p><h2 id="char-a-1"><a href="#char-a-1" class="headerlink" title="char a[][]"></a><FONT COLOR = Cyan><code>char a[][]</code></font></h2><p>　　这句话是定义一个二维数组，并且根据C语言的规则，行数可以由编译器来数，但列数一定要明确给出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　此时编译器会报错：</p><blockquote><p>[Error] array type has incomplete element type</p><p>该数组没有完备的类型。</p></blockquote><p>　　所以要明确给出这个二维数组的列数，比如修改为：<code>char a[][10] ;</code><br>　　<FONT COLOR = LimeGreen>这句话的本质</font>：是定义一个数组，该数组每一个单元都是 <code>char[10]</code>，<code>a[0]</code>是一个<code>char[10]</code>，<code>a[1]</code>也是一个<code>char[10]</code>。所以就会出现下面情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line"><span class="string">&quot;world&quot;</span> ,</span><br><span class="line"><span class="string">&quot;1234567890&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　定义 hello 和 world 的时候没有错，但是在定义 <code>a[2]</code>的时候出错了：</p><blockquote><p>[Warning] initializer-string for array of chars is too long [enabled by default] 这个东西太长了<br>[Warning] (near initialization for ‘a[2]’) [enabled by default]</p></blockquote><h2 id="char-a-2"><a href="#char-a-2" class="headerlink" title="char *a[]"></a><FONT COLOR = Cyan><code>char *a[]</code></font></h2><p>　　这样写才是真正的去定义一个字符串数组，这个数组里面每一个元素都是一个<code>char *</code>：  </p><p><img src="https://gitee.com/XuSiyuan-cn/PhotosOfMyBlog/raw/master/20210420182315.png" alt="图表1"></p><p>　　在<code>switch-case</code>里面，我们曾经尝试过一个月份的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入月份\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :<span class="built_in">printf</span>(<span class="string">&quot;january&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :<span class="built_in">printf</span>(<span class="string">&quot;feb&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :<span class="built_in">printf</span>(<span class="string">&quot;march&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :<span class="built_in">printf</span>(<span class="string">&quot;april&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :<span class="built_in">printf</span>(<span class="string">&quot;may&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :<span class="built_in">printf</span>(<span class="string">&quot;june&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> :<span class="built_in">printf</span>(<span class="string">&quot;july&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> :<span class="built_in">printf</span>(<span class="string">&quot;august&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> :<span class="built_in">printf</span>(<span class="string">&quot;september&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :<span class="built_in">printf</span>(<span class="string">&quot;october&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span> :<span class="built_in">printf</span>(<span class="string">&quot;november&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span> :<span class="built_in">printf</span>(<span class="string">&quot;december&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序非常的简单，也可以用字符串数组来实现这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">10</span>] = &#123; <span class="comment">//定义字符串数组</span></span><br><span class="line"><span class="string">&quot;January&quot;</span> ,</span><br><span class="line"><span class="string">&quot;february&quot;</span> ,</span><br><span class="line"><span class="string">&quot;march&quot;</span> ,</span><br><span class="line"><span class="string">&quot;april&quot;</span> ,</span><br><span class="line"><span class="string">&quot;may&quot;</span> ,</span><br><span class="line"><span class="string">&quot;june&quot;</span> ,</span><br><span class="line"><span class="string">&quot;july&quot;</span> ,</span><br><span class="line"><span class="string">&quot;august&quot;</span> ,</span><br><span class="line"><span class="string">&quot;september&quot;</span> ,</span><br><span class="line"><span class="string">&quot;october&quot;</span> ,</span><br><span class="line"><span class="string">&quot;november&quot;</span> ,</span><br><span class="line"><span class="string">&quot;december&quot;</span> ,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">12</span> ; i++)&#123; <span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( i + <span class="number">1</span> == month )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main的真相"><a href="#main的真相" class="headerlink" title="main的真相"></a><FONT COLOR = Cyan>main的真相</font></h2><p>在比较严格的编译器中，main 的样子是这样的：<code>int main( int argc, char* argv[], char **env ) </code>。 </p><p>　　第一个参数，int型的<code>argc</code>，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，一般默认为1。  </p><p>　　第二个参数，char*型的<code>argv[]</code>，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：<br>    <code>argv[0]</code>指向程序运行的全路径名<br>    <code>argv[1]</code>指向在DOS命令行中执行程序名后的第一个字符串<br>    <code>argv[2]</code>指向执行程序名后的第二个字符串<br>    <code>argv[3]</code>指向执行程序名后的第三个字符串<br>    <code>argv[argc]</code>为NULL </p><p>　　第三个参数，char**型的<code>env</code>，为字符串数组。<code>env[]</code>的每一个元素都包含<code>ENVVAR=value</code>形式的字符串，其中<code>ENVVAR</code>为环境变量，value为其对应的值。平时使用到的比较少。</p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>,argc) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　输出为：</p><blockquote><p>argc = 1 </p><p>argument 0 is F:\Caches\desktop\Mr.Weng.exe</p></blockquote><p>　　如果在调试—命令参数中，输入多个命令参数，比如“a b c d”此时输出值就会变成</p><blockquote><p><code>argc</code> = 5<br>argument 0 is F:\Caches\desktop\Mr.Weng.exe<br>argument 1 is a<br>argument 2 is b<br>argument 3 is c<br>argument 4 is d</p></blockquote><p>　　在Unix里面，这里还有更复杂的东西</p><h1 id="单字符输入输出"><a href="#单字符输入输出" class="headerlink" title="单字符输入输出"></a><FONT COLOR = SpringGreen>单字符输入输出</font></h1><h2 id="函数putchar"><a href="#函数putchar" class="headerlink" title="函数putchar"></a><FONT COLOR = Cyan>函数<code>putchar</code></font></h2><p>　　<code>int putchar(int c) ;</code>把一个字符输出到标准输出上（终端）。但这个函数的输入参数不是<code>char</code>，而是<code>int</code>，但是这个<code>int</code>所能接受的，也仅仅是一个字符而已。这个函数返回类型也是一个<code>int</code>，表示这一次到底写出去几个字符。如果某时候这个输出不能用了，此时会返回一个 <code>EOF（-1） = end of file</code>；这个 <code>EOF</code> 是一个宏，这个宏的值是 -1 。<br>　　一般来说，不用在意<code>putchar</code>的返回。</p><h2 id="函数getchar"><a href="#函数getchar" class="headerlink" title="函数getchar"></a><FONT COLOR = Cyan>函数<code>getchar</code></font></h2><p>　　<code>int getchar(void)</code>它的作用是从终端中读入一个字符，也就是说，如果终端有数据的话不用输入它就可以直接读取了。第一次调用<code>getchar()</code>时，确实需要人工的输入，但是如果输了多个字符，以后的<code>getchar()</code>再执行时就会直接从缓冲区中读取了。<br>　　返回类型也是<code>int</code>,</p><p>　　试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != EOF )&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOF\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>ch = getchar()) != EOF </code>，首先把终端里面的字符用<code>getchar</code>读取出来，然后赋值给 ch ，然后判断这个值是不是 <code>EOF</code> 。如果不是，那么用<code>putchar</code>输出这个值。</p><h1 id="函数STRLEN"><a href="#函数STRLEN" class="headerlink" title="函数STRLEN"></a><FONT COLOR = SpringGreen>函数<code>STRLEN</code></font></h1><h1 id="函数STRCMP"><a href="#函数STRCMP" class="headerlink" title="函数STRCMP"></a><FONT COLOR = SpringGreen>函数<code>STRCMP</code></font></h1><h1 id="函数STRCPY"><a href="#函数STRCPY" class="headerlink" title="函数STRCPY"></a><FONT COLOR = SpringGreen>函数<code>STRCPY</code></font></h1><h1 id="函数STRCAT"><a href="#函数STRCAT" class="headerlink" title="函数STRCAT"></a><FONT COLOR = SpringGreen>函数<code>STRCAT</code></font></h1><h1 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a><FONT COLOR = SpringGreen>字符串搜索函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;字符串&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers II</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/</id>
    <published>2021-03-10T13:59:47.000Z</published>
    <updated>2021-04-08T10:16:01.696Z</updated>
    
    <content type="html"><![CDATA[<p>指针（下）</p><a id="more"></a><h1 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a><FONT COLOR = SpringGreen>指针与const</font></h1><p>　　C 99 only<br>　　指针和 const 在一起就有点小复杂，因为指针本身可以是 const，而指针所指向的变量的值，也可以是 const。</p><h2 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a><FONT COLOR = Cyan>指针是const</font></h2><p>　　此时表示指针一旦得到了某个变量的地址，就不能再指向其他变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = &amp;i; <span class="comment">// 此时 q 是 const，q 的值不能被改变，q 指向 i 这个事实不能被改变，q 不能再指向别的量了。</span></span><br><span class="line">*q = <span class="number">26</span> ; <span class="comment">//访问指针地址上的值，赋值，OK。因为 q 所指向的 i 不是const</span></span><br><span class="line">q++ ; <span class="comment">//改变指针的位置，ERROR</span></span><br></pre></td></tr></table></figure><h2 id="所指的是const"><a href="#所指的是const" class="headerlink" title="所指的是const"></a><FONT COLOR = Cyan>所指的是const</font></h2><p>　　表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;i ;</span><br><span class="line">*p = <span class="number">26</span> ; <span class="comment">// ERROR！因为 (*p)是const，此时不能通过指针去修改那个地址上的量，此时不能通过 *p 去赋值。</span></span><br><span class="line">i = <span class="number">26</span> ; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j ; <span class="comment">//OK，可以修改 p 的指向，让 p 指向 j</span></span><br></pre></td></tr></table></figure><h2 id="const的位置"><a href="#const的位置" class="headerlink" title="const的位置"></a><FONT COLOR = Cyan>const的位置</font></h2><p>　　const 可以一共出现三个位置，但是只有两个功能：要么是指针不可修改，要么是通过指针不可修改。<FONT COLOR = LimeGreen>判断哪个被 const 了的标志，是 const 在 * 的前面还是后面。</font>如果是指针不可修改，则 const 在变量前面，在 * 后面；如果是通过指针不可修改，则 const 在 * 前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p2 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;i ; <span class="comment">//指针不可修改</span></span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a><FONT COLOR = Cyan>转换</font></h2><p>　　总是可以把一个非 const 的值转换成 const </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * x)</span> </span>;<span class="comment">//该函数需要一个“通过指针不可修改”的指针来进行输入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line">f(&amp;a) ; <span class="comment">//此时给函数一个非 cconst 的指针，是没问题的！</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a ;</span><br><span class="line">f(&amp;b) ; <span class="comment">//此时给函数一个 const 的指针，也是没问题的。</span></span><br><span class="line">b = a + <span class="number">1</span> ;<span class="comment">//[Error] assignment of read-only variable &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数原型的意思是，给我一个指针，我保证在函数内部不会通过指针去修改地址上的值。所以至于交给他的参数是不是 const ，其实是无所谓的。</p><p>　　这种做法主要用来，当要传递的参数的类型比地址大的时候（在结构的时候常用），这是常用的手段：既能用比较少的字节数传值给参数，又能避免函数对外面的变量的修改。类似于传数组，数组可以很大，但实际上传给函数的只有一个<code>*int</code>大小的地址，传进去的实际上是指针。</p><h2 id="const数组"><a href="#const数组" class="headerlink" title="const数组"></a><FONT COLOR = Cyan>const数组</font></h2><p>　　在《指针与数组》中，我们可以看出来，数组本质上就是一个 const 的指针，那么再次对数组进行 const会发生什么？比如<code>const int a[] = &#123; 1, 2, 3, 4, 5, 6&#125; ;</code><br>　　数组变量已经是 const 的指针了，这里的const表明数组的每个单元都是 const int。所以必须通过初始化进行赋值。</p><p><FONT COLOR = LimeGreen>　　这种做法可以用来保护数组值：</font></p><p>　　因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值。为了保护数组不被破坏，可以设置函数的参数为const：</p><p>　　<code>int sum(const int a[],int length);</code><br>　　这句话的意思是要求函数接受一个const的数组，那么在函数内部，函数不会对数组有任何修改！</p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a><FONT COLOR = SpringGreen>指针运算</font></h1><h2 id="1-1-2？"><a href="#1-1-2？" class="headerlink" title="1 + 1 = 2？"></a><FONT COLOR = Cyan>1 + 1 = 2？</font></h2><p> 　　对指针变量进行自加一的话，会是什么呢？用代码尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc = ac ;<span class="comment">//&amp;可加可不加</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc  =%p\n&quot;</span>,pc) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc+1=%p\n&quot;</span>,pc+<span class="number">1</span>) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi  =%p\n&quot;</span>,pi) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi+1=%p\n&quot;</span>,pi+<span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>　　输出结果为：</p><blockquote><p>pc    = 0x22FE30<br>pc+1= 0x22FE31  此时结果相差1</p><p>pi     = 0x22FE00<br>pi+1= 0x22FE04  此时结果相差4 </p></blockquote><p>　　为什么呢？因为<code>sizeof(char) = 1 , sizeof(int) = 4</code>。所以对于指针变量 + 1，不是让地址 + 1，而是让指针 + 1个 sizeof 。 对于 char 类型，如果第一个地址在 30 上，那执行指针 +1后，地址在31上。对于 int 类型，如果第一个地址在00上，因为一个 int 型占据 4 个字节，所以执行指针 +1后，地址在 04 上。</p><p><img src="https://www.hualigs.cn/image/606d14a05b596.jpg"></p><p>　　对指针变量 + 1，本质是让指针所指向的地址往后面移动一格。这一点在数组里面体现的尤为明显：<br>　　对于 char 类型数组<code>*pc -&gt; ac[0] ; *(pc+1) -&gt; ac[1]</code>。<br>　　对于 int 类型数组<code>*pi -&gt; ai[0] ; *(pi+1) -&gt; ai[1]</code>。<br>　　对于任何类型的数组，<code>*p -&gt; a[0] ; *(p+n) -&gt; a[n]</code>。<br>　　<FONT COLOR = LimeGreen>给一个指针加1表示要让指针指向下一个变量</font>，如果指针不是指向一片连续分配的空间，如数组，则这种运算是没有意义的。</p><h2 id="指针的加减"><a href="#指针的加减" class="headerlink" title="指针的加减"></a><FONT COLOR = Cyan>指针的加减</font></h2><p>　　加减可以对指针做。<br>　　指针 + n：指针往后移 n 个<code>sizeof</code>单元<br>　　指针 - n：指针往前移 n 个<code>sizeof</code>单元<br>　　两个指针相减：类似于坐标相减，指的是他们中间有多少个<code>sizeof</code>单元。用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc1 = &amp;ac[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">char</span> *pc7 = &amp;ac[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1  =%p\n&quot;</span>,pc1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc7  =%p\n&quot;</span>,pc7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1 - pc7 = %d\n&quot;</span>,pc1-pc7) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;ai[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">int</span> *pi7 = &amp;ai[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1  =%p\n&quot;</span>,pi1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi7  =%p\n&quot;</span>,pi7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1 - pi7 = %d\n&quot;</span>,pi1-pi7) ; </span><br></pre></td></tr></table></figure><p>　　运行结果如下：</p><blockquote><p>pc1           = 0x22FE21<br>pc7           = 0x22FE27<br>pc1 - pc7 = -6</p><p>pi1           = 0x22FDF4<br>pi7           = 0x22FE0C<br>pi1 - pi7 = -6<br>在16进制下，这两个地址相差24，刚好是 6 个sizeof(int)</p></blockquote><p>　　所以两个指针相减的时候，给的不是地址差，给的是地址之间相差多少个单元，中间还能放几个这样类型的元素。</p><h2 id="p"><a href="#p" class="headerlink" title="*p++"></a><FONT COLOR = Cyan>*p++</font></h2><p>　　　<code>*</code>的优先级是非常高的，但是没有++高。所以是先进行后缀的自加1，再取<code>*</code> ，<FONT COLOR = LimeGreen>p++ 的结果，是p+1以前的结果</font>。所以这句话的操作是：<FONT COLOR = LimeGreen>取出指针 p 所指的数据，完事后顺便把 p 移到下一个位置去。</font><br>　　该操作常用于数组类的连续空间操作。比如遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;<span class="comment">//在数组末尾放一个不可能的多余数据 </span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;b[<span class="number">0</span>] ;<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>( ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果使用指针挪位的方法来遍历，则需要在遍历的数组后面加一个不可能的多余数据，达成循环终止的条件。其中指针的初始化可以用以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p  ;</span><br><span class="line"><span class="keyword">for</span>( p = b ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在上一讲提过，数组就是特殊的指针，对于初始化，以下几种方式都是可以的：<br>　　<code>int *p = b ;</code> 或者 <code>int *p ; p = b ;</code> 或者 <code>int *p = &amp;b[0] ;</code> </p><p>　　在某些CPU上，<code>*p++</code>可以直接被翻译成一条汇编指令。</p><h2 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a><FONT COLOR = Cyan>指针比较</font></h2><p>　　<code>&lt; , &lt;= , == , &gt; , &gt;= , !=</code>都可以对指针做，用来比较他们在内存中的地址。数组中的单元地址是线性递增的。</p><h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a><FONT COLOR = Cyan>0地址</font></h2><p>　　  现代的操作系统都是多进程的操作系统，对于每一个进程，操作系统会给他一个虚拟的地址空间，所以所有的程序在运行的时候都以为自己有从0开始的一片连续的地址空间。<FONT COLOR = LimeGreen>所以任何程序都有0地址，但是0地址通常是个不能随便碰的地址，所以我们的指针不应该具有0值。</font><br>　　所以可以用这个特性来做一些特殊的事情：<br>　　用 0 地址表示返回的指针是无效的，指针没有被真正的初始化（先初始化为0）……<br>　　在C语言里，有的编译器不愿意用 0 来表示 0 地址。所以使用 <code>NULL</code>为预定定义的符号，表示 0 地址。</p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a><FONT COLOR = Cyan>指针类型</font></h2><p>　　无论指向什么类型，所有的指针的大小都是一样的，他们都是地址。但是指向不同类型的指针是不能直接互相赋值的，比如上面的<code>int *pi</code>和<code>char *pc</code>。这是为了避免用错指针。<br>　　如果赋值了会怎么样？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %p\n&quot;</span>,pi) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *pc = ac ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br><span class="line"></span><br><span class="line">pi = pc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br></pre></td></tr></table></figure><p>　　此时会有一个 warning：</p><blockquote><p>[Warning] initialization from incompatible pointer type [enabled by default]</p><p>指针类型不匹配</p></blockquote><p>　　如果忽视掉 warning 强行运行的话，会发现，还是成功地把 pi 所指向的地址，赋给了 pc。所以此时 pc 和 pi 指向同一个地址。这个和数据类型不一样，比如 double 和 int。强行把 double 的值放给 int 的话，因为 double 占据空间比 int 大，所以强行放进去会出现问题。但不管是什么类型的指针，他们本质上都是地址，而且大小都相同，东西是放的进去的，这样做有问题的原因如下：</p><p><img src="https://www.hualigs.cn/image/606d53bb62f4d.jpg"></p><p> 　　如果让<code>pi = pc</code>，然后操作 *pi ，比如让<code>*pi = 0</code>，本来 pi 是指向 4 个字节，那么就会让 30、31、32、33四个位置上全部为0。 所以编译器报 warning 的原因，是为了防止用错指针。</p><h2 id="void"><a href="#void" class="headerlink" title="void *"></a><FONT COLOR = Cyan>void *</font></h2><p>　　如果想要强制让不同类型的指针去赋值，就需要强制类型转换：<br>　　<code>void *</code> 表示不知道指向什么东西的指针，先定义这个指针指向“void”，这片空间里是什么类型，是 int 还是 double，先不用去知道，不用去管。这种指针可以直接去访问内存地址，或者某个内存地址所代表的外部设备等。计算时与<code>char *</code>相同（但不相通）<br>　　指针也可以转换类型。<code>int *p = &amp;i ; void *q = (void *)p</code>这里就是把一个 int 型的指针 p ，强制转换为了 void 型，并且交给了 <code>void *p</code>。此时实际上这并没有改变 p 所指的变量的类型，p 是指向 i 的，i 也任然是 int 。只不过是通过 q 去看 i 的时候，眼光变了；通过 p 去看 i ，i 是 int ；通过 q 去看 i ，i 是 void 。</p><p>　　让后人用不同的眼光通过 p 来看它所指的变量 i，我不再当你是 int 了，我认为你就是个 void。</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><FONT COLOR = SpringGreen>动态内存分配</font></h1><p>　　如何用变量来定义数组？除了<code>const int number ； int a[number]</code>这种方法外，还有没有？利用 malloc 函数对指针进行动态内存分配，比如：<code>int *a = (int*)malloc(n*sizeof(int));</code></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><FONT COLOR = Cyan>malloc</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>属于标准库函数</strong></font></p><p>　　malloc 全称是 memory allocation ，是 C 标准库里面的函数，所以使用 malloc 前要加一个头文件<code>#include&lt;stdlib.h&gt;</code></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>描述</strong></font></p><p>　　该函数分配他想要的一个内存空间，并返回一个指向它的指针。<FONT COLOR = LimeGreen>向 malloc 申请的空间大小是以字节为单位的</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>声明</strong></font></p><p>　　下面是 malloc() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>参数</strong></font></p><p>　　size – 内存块的大小，以字节为单位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>返回值</strong></font></p><p>　　该函数返回一个指针 void * ，指向已分配大小的内存。<FONT COLOR = LimeGreen>返回的指针需要类型转换为自己需要的类型</font>比如：<code>(int *)malloc( n * sizeof(int) )</code>。<br>　　如果空间用完了，则请求分配空间失败，则返回 0，或者NULL。</p><p>　　用“变量”定义数组，方法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"><span class="keyword">int</span> a[number] ;</span><br></pre></td></tr></table></figure><p>　　用“变量”定义数组，方法2，malloc 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br></pre></td></tr></table></figure><p>　　malloc 需要的参数不是有多少个 int，不是这个数组有多少个单元，而是这个数组需要多少空间（字节），所以在括号里面需要乘以一个<code>sizeof(int)</code>。此外，malloc 他返回的是一个 void* ，而 a 是一个 int *。所以这里需要使用一下类型强制转换，前面需要一个<code>( int *)</code><br>　　指针和数组的本质是相同的，所以接下来，这个指针 a ，就可以完全当做数组来使用：</p><p>　　<Font Size = 2 color = DeepSkyBlue><strong>特别注意的是，虽然指针可以当做数组来用，但他还是指针，所以对于这种东西是不能用 <code>sizeof</code>的，如果去用 <code>sizeof</code>，得到的是指针的长度（占据多少个字节）。所以对于这种“数组”的 length 也不能使用<code>sizeof(a)/sizeof(a[0])</code>，应该直接使用 number。</strong></font></p><p>　　尝试对这种数组做点操作：遍历输入，遍历逆序输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = number - <span class="number">1</span> ; i &gt; <span class="number">-1</span> ; i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(a) ;<span class="comment">//释放内存很重要</span></span><br></pre></td></tr></table></figure><p>　　可以利用一下 malloc 看一下自己的系统能给多大的空间，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>( ( p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>)) )&#123;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配了%d00MB的空间\n&quot;</span>,count) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>1、定义指针的时候，定义的是 void 类指针，这里也可以定义 int 型，如果定义 int 型，那么后面使用 malloc 的时候前面就要加一句<code>int *</code>。<br>　　2、<code> p = malloc(100*1024*1024)</code>这句话有三个作用：<br>　　第一，利用 malloc 去申请空间，并且把字节换算成了MB，1 mb = 1024 kb = 1024 * 1024 b。所以这里没申请一次相当于申请了 100 mb。<br>　　第二，把函数返回值交给指针 p 。<br>　　第三，这句话也是循环继续的条件，如果 malloc 申请空间成功，则成功赋值；如果 malloc 申请空间失败，由 malloc 的操作手册可知，malloc 会返回 0，或者 NULL。所以这句话也可以当做循环的条件，当申请空间失败的时候，就是表达式为 0 的时候，就是循环终止的时候。</font></p><h2 id="free"><a href="#free" class="headerlink" title="free( )"></a><FONT COLOR = Cyan>free( )</font></h2><p>　　malloc 函数是向系统申请内存空间，而<code>free()</code>就是把申请来的空间还给“系统”。<br>　　申请过来的空间最终都应该归还，只能还申请来的空间的首地址，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>) ;<span class="comment">//要个100MB的空间</span></span><br><span class="line">p++ ;<span class="comment">//把指针的地址往下面去放一位</span></span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时程序会报错，有可能不报错，但程序会崩溃，也不会运行到“here”那里。如果是严格的编译器此时会编译出错：</p><blockquote><p>error: Access violation in freeing invalid address （提示非法访问）</p><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　如果 free 的指针不是 malloc 来的，也会报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时指针 p 的空间不是 malloc 来的，dev C++ 没有报错，但是程序运行时会崩溃，不会运行到 “here” 那里。如果是严格的编译器，会报错：</p><blockquote><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　由这两个错误可以看出，系统可以记住，哪些内存是 malloc 来的，必须要严格记住 malloc 的地址，对这个地址 free 才有效。<code>free(NULL)</code>也是可以执行的，就是什么都不做。</p><p>　　如果申请了内存空间，不去 free ，长时间运行的话就会使内存逐渐下降。对操作系统来说，当程序结束后，曾经使用过的内存会全部清除干净。<br>　　如果 free 过了再去 free，也会出错。</p><hr><p>指针的主要用途：</p><p>需要传入较大的数据时，用指针作为参数，比如数组。<br>传入数组后对数组做操作。<br>函数返回不止一个结果，需要用指针带出来<br>需要用函数来修改不止一个变量<br>动态申请的内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（下）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/</id>
    <published>2021-03-09T13:59:47.000Z</published>
    <updated>2021-04-06T13:47:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>指针（上）</p><a id="more"></a><h1 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a><FONT COLOR = SpringGreen>取地址运算</font></h1><h2 id="运算符-amp"><a href="#运算符-amp" class="headerlink" title="运算符&amp;"></a><FONT COLOR = Cyan>运算符&amp;</font></h2><p>　　在C里面，&amp;也是运算符，为取地址运算，最典型的就是<code>scanf(&quot;%d&quot;,&amp;i)</code>里面的 &amp;<br>　　<FONT COLOR = LimeGreen>&amp; ：作为运算符，是获得变量的地址，它的操作数必须是变量！</font>C语言里的变量是放在内存里面的，每一个变量都会在内存中占据一定的位置和大小。比如 int 是四个字节，这个变量有大小，内存需要有一个地方放置，放置变量这个地方就是地址。&amp; 就是把这个变量的地址拿出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　地址用16进制表达起来比较方便，所以在输出 %x 前面加一个<code>0x</code>，其中 %x 表示以十六进制数形式输出整数，对于地址的表达，用16进制比较方便。把 i 的地址取出来，用<code>printf</code>输出。此时程序给出的结果是：<code>0x22fe4c</code>。<br>　　有的编译器可能会给一个warning：</p><blockquote><p>warning: format specifies type ‘unsigned int’ but the argument has type ‘ int * ‘</p></blockquote><p>　　这个warning的意思是，如果你想要<code>printf</code>给你输出一个地址，输出的时候不应该用 %x ，而是使用 %p。：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen><code>%p</code>的意思是把这个值作为一个地址来输出，输出的时候自己会在前面加<code>0x</code>，是以16进制的方式输出这个地址， 如果输出数据不够8位数，则左边补零。  </font>此时输出值是：<code>000000000022fe4c</code>。<Font Size = 2>这里我补了16位数，有可能是因为的我的编译器为64位</font></p><p>　　这两个地址实际上表达的是一个位置，看起来像是一个数，尝试能不能对这个数进行操作？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时编译器会有一个 warning:</p><blockquote><p>[Warning] assignment makes integer from pointer without a cast [enabled by default]</p></blockquote><p>　　这个 warning 是需要类型转换的意思，需要从指针型转换为 int 型，若忽视 warning 强行输出，则结果为：<code>000000000022fe48</code>。解决掉这个 warning ，只需要一次强行类型转换即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;<span class="comment">//我的电脑在编译的时候这里任然有类型转换的 warning，初步认为是编译器的问题，换成更加严格的在线编译器之后通过！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时两条代码的编译结果都是<code>0x22fe48</code>。<br>　　注：<Font Size = 2>特别的，关于 &amp;i 和 int 类型的东西，在32位架构下，两者大小是相同的，但是在64位架构下，两者并不相同。</font>所以关于这段代码的编译结果，对于 32 位系统，编译结果相同；对于64位系统，编译结果可能不同，但是后 8 位是一模一样的，比如结果可能是<code>0x5c961d28</code>和<code>0x7fff5c961d28</code>。还有一个例子更好地说明在 64 位架构下，<code>int</code>和<code>&amp;i</code>的区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;i));</span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>0x22fe48、000000000x22fe48、4、8</code>。说明在64位架构下，int 的大小是4，而 &amp;i 的大小是8。在32位架构下，int 的大小是4 ，&amp;i 的大小也是4。</p><p>　　综上：一个变量，它的地址的大小是否与 int 相同取决于编译器，取决于系统是64位架构还是32位架构。地址和整数并不永远是相同的，所以对于地址的输出，我们采用 %p 的方式。</p><h2 id="不能取的地址"><a href="#不能取的地址" class="headerlink" title="不能取的地址"></a><FONT COLOR = Cyan>不能取的地址</font></h2><p>　　<FONT COLOR = LimeGreen>&amp; 不能对没有地址的东西取地址</font>。如果右边不是一个变量，则不能取地址！<br>　　<code>&amp;(a+b)</code>、<code>&amp;(a++)</code>、<code>&amp;(++a)</code>此时右边是一个表达式，所以不能取地址</p><blockquote><p>[Error] lvalue required as unary ‘&amp;’ operand</p><p>error: cannot take the address of an rvalue of type ‘int’</p></blockquote><h2 id="常见的地址"><a href="#常见的地址" class="headerlink" title="常见的地址"></a><FONT COLOR = Cyan>常见的地址</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>变量的地址</strong></font></p><p>　　上面已经阐述过，不再赘述</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的变量的地址</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br></pre></td></tr></table></figure><p>　　输出结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>可以看出来，定义的相邻的变量，地址也是相邻的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;k) ;</span><br></pre></td></tr></table></figure><p>　　输出的结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>、<code>0x22FE44</code>说明在内存里面，他们都是紧挨着的。<br>　　其中也可以看出来，最先定义的 i 占据比较位置比较大，然后是后面定义的 j 然后是后面定义的 k 。</p><p><img src="https://www.hualigs.cn/image/606930106c1cd.jpg"></p><p>　　在内存中，最先定义的 i 在最高的地方，然后是 j  最低的地方是最后定义的 k 。C 的内存模型会将本地变量分配在“堆栈 stack”，在堆栈中，分配变量是“自顶向下”分配的。先写的变量地址最高，后写的变量地址变低，依次紧挨着排列。他们的地址相差一个<code>sizeof(int)</code>。<font color = red>为什么这里相差一个<code>sizeof(int)</code>而不是一个<code>sizeof(&amp;i)</code>?</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>&amp;</code>的结果和 <code>sizeof</code></strong></font></p><p>　　前面已经讨论过，不同编译器和不同架构下，<code>sizeof</code>的结果不一样，32位占据4，64位占据8。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组单元的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的数组单元的地址</strong></font></p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;<span class="comment">//数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">0</span>]) ;<span class="comment">//数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">1</span>] );<span class="comment">//相邻的数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//试图直接把a交给printf输出地址</span></span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>22FE20、22FE20、22FE24、22FE20</code>。相邻数组单元的地址相差永远是 4 。说明他们是紧挨着的。</p><p><img src="https://www.hualigs.cn/image/606b06c98d387.jpg"></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a><FONT COLOR = SpringGreen>指针</font></h1><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a><FONT COLOR = Cyan>指针变量</font></h2><p>　　如果能够将取得的变量的地址，然后将这个地址作为一个值传递给一个函数，那么这个函数能否通过这个地址访问到这个变量呢？比如函数<code>scanf(&quot;%d&quot;,&amp;i)</code>，他到底是如何工作的？<br>　　在使用<code>scanf</code>的时候，会传给这个函数一个变量的地址，然后<code>scanf</code>拿我们传给它的这个地址，放到我们指定的变量中去。这些功能是如何实现的？<code>scanf</code>的原型应该是怎样的？如果我们需要一个参数能够保存别的变量的地址，如何表达能够保存地址的变量？</p><p>　　从分析<code>scanf</code>的功能可以看出来，<code>scanf</code>一定有办法，可以接受用户输入变量的地址。有前面尝试可以知道，不能把地址交给整数，因为 int 和 地址 长度不一样，在不同编译情况下，他们可能不相等。所以在C语言里，用指针来保存地址。</p><p>　　在C语言里，指针就是保存地址的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i ;<span class="comment">//*p就表示p是一个指针变量，用来保存 i 的地址</span></span><br><span class="line"><span class="keyword">int</span>* p,q ;<span class="comment">//*作用在p上，无法作用在q上。</span></span><br><span class="line"><span class="keyword">int</span> *p,q ;<span class="comment">//这句话和上面那句是一样的。</span></span><br></pre></td></tr></table></figure><p>　　<code>int* p = &amp;i</code> p 是指针，指向 i 的地址，如果说“ p 指向 i ”意思就是指针变量 p 里面保存的是 i 的地址。</p><p><FONT COLOR = LimeGreen>　　指针变量的值就是内存的地址。普通变量的值是实际的值，指针变量的值是具有实际值的变量的地址。</font>指针变量里面不会储存实际的值，只会放别的变量的地址。</p><h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a><FONT COLOR = Cyan>函数与指针</font></h2><p>　　如果把指针作为函数的参数会怎么样？就像<code>scanf(&quot;%d&quot;,&amp;i)</code>：<br>　　<code>void f(int *p)</code>此时表示函数 f 需要一个指针，如果要调用这个函数，就需要交给他一个地址：<code>int i = 0 ； f(&amp;i)</code>。此时不能交给 f 这个变量本身，必须要用 &amp; 取得 i 的地址交给 f ，函数才会生效。比如如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ; <span class="comment">//直接输出 i 的地址</span></span><br><span class="line">f(&amp;i) ;<span class="comment">//把 i 的地址交给 f 函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;  <span class="comment">//让函数输出 p 的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　可以看到，两个值是一样的。此时就可以说 p 是一个指针，指向 i 。此时在 f 函数里面，可以得到 main 函数里面变量的地址了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line">f(&amp;i) ;</span><br><span class="line">g(i) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; k = %d\n&quot;</span>,k) ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>　　此时 f 拿到了 i 的地址，但是 g 只拿到了 i 的值。g 这个函数里面拿到的值和 main 函数是没有关系的，g 函数无法访问 main 函数。但是 f 是可以通过指针来访问 main 函数。</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a><FONT COLOR = Cyan>访问地址</font></h2><p>　　有了指针之后，有了地址之后，如何访问这个地址上的变量呢？<FONT COLOR = LimeGreen>使用 * ，用 * 来访问指针所指向的那个地址上的变量。此时 * 是一个单目运算符，用来访问指针的值所表示的低智商的变量。</font>可以做右值，也可以做左值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i ;<span class="comment">// p 指向 i</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;<span class="comment">//查看 i 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;<span class="comment">//查看 p 的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>,&amp;p) ;<span class="comment">//查看 p 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;<span class="comment">//*p 作为一个整体，表示的是 i 的值，所以是一个整数，此时 *p 作为右值</span></span><br><span class="line">*p =  <span class="number">1</span> ;<span class="comment">//此时 *p作为左值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; i = %d\n&quot;</span>,i) ; <span class="comment">//查看 i 的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　最后的结果是：</p><blockquote><p>&amp;i = 0x100010<br> p = 0x100010<br>&amp;p = 0x100018<br>*p = 0<br>i = 1</p></blockquote><p>　　1、把 i 的地址交给 p 后，p 的值就是 i 的地址，而 p 的地址和 i 的地址不相同<br>　　2、<code>printf(&quot;*p = %d\n&quot;,*p)</code>这一步相当于是<code>int k = *p ; printf(&quot;k = %d\n&quot;,k </code>，所以也就证明了，*p 读取了 i 的值。说明 *p 可以作为右值，读取地址上的值，成功。<br>　　3、<code>*p =  1</code>就是修改地址上的值，最后可以看到<code> i = 1</code>，所以修改地址上的值也成功。</p><p>　　综上，<code>*p</code>可以访问地址上的值，也可以修改地址上的值。 </p><h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a><FONT COLOR = Cyan>左值</font></h2><p>　　在做赋值运算的时候，赋值号左边可以不是变量，左边可以是值。这种可以被赋值的值，称之为左值：<br>　　<code>a[0] = 2 ；</code>这里左边不是变量，是值，是表达式计算的结果，[ ] 是特殊的运算符，用来取数组的下标。<br>　　<code>*p = 2 ；</code>这里左边也不是变量，而是指向变量的值，是表达式计算的结果， 但是他也能赋值。<br>　　所以严格意义上来说，赋值号左边不一定是变量，所以称之为左值；赋值号右边称之为右值。</p><h2 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp; 和 *"></a><FONT COLOR = Cyan>&amp; 和 *</font></h2><p>　　在指针中，有两个运算符，他们是互为相反作用的：<br>　　&amp;：取变量的地址。*：访问地址上的变量。可以说他们是互为逆运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*a = &amp;A</span><br><span class="line">*&amp;A → *(&amp;A) → *(A的地址) → 得到那个地址上的值 → A的值      </span><br><span class="line">&amp;*a → &amp;(*a) → &amp;(地址上的值，就是A) →得到A的地址→ A的地址就是a</span><br></pre></td></tr></table></figure><h2 id="scanf的”不合理”"><a href="#scanf的”不合理”" class="headerlink" title="scanf的”不合理”"></a><FONT COLOR = Cyan><code>scanf</code>的”不合理”</font></h2><p>　　为什么像这种代码编译器不会报错：<code>int i ;scanf(&quot;%d&quot;,i);</code>。此时 i 是整数，而在32位架构下，整数和地址是一样大的，所以当这么写的时候，把一个整数传进去，或者把一个地址传进去，他们长的是一样的， <code>scanf</code>无法辨别其区别。<br>　　所以此时编译不一定会报错，但是运行一定会出错。运行一定出错是因为<code>scanf</code>把他读入的量写在了内存其他地方，写在了不该写的地方。</p><h1 id="指针应用"><a href="#指针应用" class="headerlink" title="指针应用"></a><FONT COLOR = SpringGreen>指针应用</font></h1><h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a><FONT COLOR = Cyan>返回多个值</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景1：函数需要返回多个值！</font>函数是只能返回一个值的，如果需要返回多个值，那就只能通过指针返回。传入的参数的地址，然后利用这个地址把函数里面变量的值带出来。<Font Size = 2>（这句话感觉很绕，但仔细体会体会，能明白的）</font>传入的参数，实际上是需要返回值的地址以及变量。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Exchange</strong></font></h3><p>　　当时在《函数》那章的时候，曾经有一个问题，就是是否可以编写一个函数，用来交换 a 和 b 的值。当时的答案是不行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为 main 和函数是参数和值的关系，main 提供参数给函数，而函数把值传给 main。所以当需要返回多个值的时候，单纯靠函数是做不到的，但是有了指针就不一样了！因为在函数可以利用指针来访问 main 里面变量的地址，从而达到交换变量值的目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line">exchange( &amp;a , &amp;b ) ; <span class="comment">//对于指针变量的函数，调用的时候注意，传的是地址，而不是值！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>&#123;<span class="comment">//此时函数拿到 a b 的地址</span></span><br><span class="line"><span class="keyword">int</span> t = *pb ;<span class="comment">//访问 b 地址上的值，并且把该值传给 t</span></span><br><span class="line">*pb = *pa ;<span class="comment">//访问 a 地址上的值，并且把该值传给 b</span></span><br><span class="line">*pa = t ;<span class="comment">//把 t 的值传给 a 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Max-和-Min"><a href="#Max-和-Min" class="headerlink" title="Max 和 Min"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Max 和 Min</strong></font></h3><p>　　编写一个函数，可以判断一个数组里面的最大值和最小值。此时显然函数需要返回两个结果，所以必须要用指针来完成这件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//这四个参数一个都不能少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> , <span class="number">56</span> , <span class="number">74</span> , <span class="number">12</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );<span class="comment">// &amp;min 和 &amp;max 是从 main 传进函数的参数，他们的作用是把函数里面的值带出来！！！！！！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d , min = %d&quot;</span>,max ,min) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//对于传进来的地址，定义函数的时候得是指针变量</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;<span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q 1：能不能不要 length ，直接在函数里面使用<code>sizeof(a)/sizeof(a[0])</code>？<br>　　不能，如果调用函数的时候，参数没有<code>sizeof(a)/sizeof(a[0])</code>，那么函数里面是访问不了 a 的。</p><blockquote><p>[Error] ‘a’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>Q 2：传值的时候能不能不传数组 a？<br>　　不能，原因同上！只要是函数要用的参数，调用函数的时候都要传值给函数，不然函数无法访问 main 的变量。错误也同上。</p><p>Q 3：调用函数的时候，数组写成了 a[ ] 怎么办？<code>minmax( a[] , &amp;min , &amp;max ,length );</code><br>　　[ ] 实际上是一个运算符，在数组里面索引，所以此时<code>a[]</code>是空的，因为没有值，此时会发生奇奇怪怪的错误：</p><blockquote><p>[Error] expected expression before ‘]’ token</p></blockquote><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a><FONT COLOR = Cyan>返回结果</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景2：函数返回运算的状态，结果通过指针返回</font>。函数在运行的过程中，可能会遇到一些特殊的状态，此时函数无法得到正确的结果。<br>　　此时常用的套路就是让函数返回特殊的，不属于有效范围内的值，来表示出错；在文件操作中，常见的就是让函数返回 -1 或 0 来表示函数出错。<br>　　但是如果函数返回的任何数值都是有效的可能结果时，此时无法通过返回值来判断函数是否运行正确，此时就只能让函数的结果，和需要用的结果分开返回。<FONT COLOR = LimeGreen>一般函数的状态用 return 来返回，而实际的值通过指针来返回。</font></p><h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>除法函数</strong></font></h3><p>　　对于<code>divide()</code>函数，如果除法成功，函数返回值为 1 ；如果除法失败，函数返回值为 0 。此时函数需要两个东西，一个是除法是否成功，一个是除法的值；所以函数的状态用函数的 return 来返回，除法的值用指针带出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a , b , result ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( divide( a , b , &amp;result) == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;除数不能为0\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span></span>&#123;<span class="comment">//需要函数返回值的时候，就不能用void </span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span>( B == <span class="number">0</span> )&#123;<span class="comment">//如果除数是0，此时指针里是没有任何有用的结果</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*Result = A / B ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当运算可能会出错的时候，C只能通过指针来解决。在后续的语言（C++、Java）采用了异常机制来解决这个问题</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p>　　<FONT COLOR = LimeGreen>定义了指针变量，还没有指向任何变量，就开始使用指针。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">12</span> ;</span><br><span class="line">*p = <span class="number">12</span> ;</span><br></pre></td></tr></table></figure><p>　　这种做法编译器不会报错，因为 *p 在编译器里就是可以看做一个整数。</p><p>　　所有的本地变量在没有初始化的时候，是不会有默认的初始值的，这个本地变量所在的地址上有什么，他就是什么。对于指针，如果没有指向任何变量的时候就开始使用它，比如这段代码的<code>*p = 12 </code>；他可能指向一片莫名其妙的地方，然后在那片奇怪的地方写入12。如果那块地方是个不能写的地方，此时会报错；如果那块地方可以写，此时不会报错。但这个指针变量也是没意义的，因为没有储存地址！</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a><FONT COLOR = SpringGreen>指针与数组</font></h1><p>　　如果把一个普通的变量传入函数，函数接收到的是值；如果把一个指针传入函数，函数接受到的也是值，只不过这个值是一个地址；给函数传入数组的话，到底传入函数的数组成了什么？函数接收到的是什么？ 为什么上面的 Max 和Min   程序里面，不能在函数里使用 <code>sizeof(a)</code>？用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在 main 里数组的大小 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在minmax函数里数组的大小</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　结果分别是40、8。 这个 8 刚好和一个指针的大小是相同的！如果对于比较严格的编译器，会出现一个 warning：</p><blockquote><p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [ ] ‘.</p></blockquote><p>　　这个警告的意思是，对于函数的数组的 <code>sizeof </code> 返回的是‘int *’的大小，而不是数组的大小。说明在函数里面的数组，实际上是一个指针！用以下代码验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在 main 里数组 a 的地址 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在函数里数组 a 的地址 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时可以发现，在 main 和函数里面，a 的地址是相同的。这说明在函数里面数组a和 main 里面的数组a是一个东西。再用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; <span class="comment">//查看a[0]的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里会发现，a[0] 的数值变了。<FONT COLOR = LimeGreen>一般来说，函数里一个变量的值变化了，是不会改变 main 里面这个变量的值。除非是指针。从这里就可以看出来，数组的本质就是指针</font>。<br>　　所以在函数定义的时候，如果是数组变量一定得写<code>a[ ]</code>，方括号里不能加数；函数里不能使用<code>sizeof</code>。因为他的本质就是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//原型里，把数组改成指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//定义里，把数组写成指针</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　编译成功！运行正确！</p><p>　　所以我们可以说<FONT COLOR = LimeGreen>函数参数表中的数组实际上就是指针</font>。<code>sizeof(a) == sizeof(*int)</code>；但是可以用数组的运算符<code>[]</code>进行运算。<br>　　<FONT COLOR = LimeGreen>所以以下四种函数原型是等价的：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar , <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * , <span class="keyword">int</span> )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[] , <span class="keyword">int</span> n )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">( <span class="keyword">int</span> [] ,<span class="keyword">int</span>)</span> </span>;</span><br></pre></td></tr></table></figure><p>　　 <FONT COLOR = LimeGreen>数组变量是特殊的指针</font><br>　　1、数组变量本身就表达地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *p = a ;<span class="comment">//无需使用 &amp; 取地址，就能够把地址交给指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//无需使用 &amp; 取地址，就可以吧地址交给 printf 输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;<span class="comment">//两者结果相同</span></span><br></pre></td></tr></table></figure><p>　　但是数组的单元表达的是变量，需要用 &amp; 取地址。</p><p>　　2、数组的地址和第一个元素的地址相同<code>a == &amp;a[0]</code></p><p>　　3、<code>[]</code>使运算符，可以对数组做，也可以对指针做。 p [ 0 ] 相当于 *p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[0] = %d\n&quot;</span>,p[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;</span><br></pre></td></tr></table></figure><p>　　4、* 运算符可以对指针做，也可以对数组做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span> , <span class="number">2</span> &#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>,*a) ;</span><br></pre></td></tr></table></figure><p>　　此时<code>*a</code>的值是<code>a[0]</code>的值。和指针一样，可以对这个值进行读写操作。</p><p>　　5、数组变量是 const 的指针，所以不能被赋值。<br>　　前面学过，像这种数组给数组赋值，是不被允许的<code>int b[] = a []</code>。数组变量间是不允许相互赋值的。因为<code>int b[] </code>相当于是<code>int * const b ;</code>相当于这个 b 是一个常数，是不可以被改变的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（上）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 08 Array</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/</id>
    <published>2021-03-08T13:59:47.000Z</published>
    <updated>2021-04-03T07:48:20.734Z</updated>
    
    <content type="html"><![CDATA[<p>数组</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><FONT COLOR = SpringGreen>数组</font></h1><p>　　数据可以存放在变量里，每一个变量有一个名字，有一个类型，还有它的生存空间。如果我们需要保存一些相同类型、相似含义、相同生存空间的数据，我们可以用数组来保存这些数据，而不是用很多个独立的变量。数组是长度固定的数据结构，用来存放指定的类型的数据。一个数组里可以有很多个数据，所有的数据的类型都是相同的。</p><h2 id="初见数组"><a href="#初见数组" class="headerlink" title="初见数组"></a><FONT COLOR = Cyan>初见数组</font></h2><p>　　如何写一个程序计算用户输入的数字的平均数？并且输出所有大于平均数的数？——即如何写一个程序用来记录用户输入的所有的数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , sum = <span class="number">0</span> , i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> average ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="comment">//定义一个数组，大小是100，每个单元都是int，所以这个数组最多可以放100个int </span></span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="comment">//i是递增的，于是恰好可以用i来作为指示位置的参数 </span></span><br><span class="line"><span class="comment">//以这种形式对数组中的每个元素赋值</span></span><br><span class="line">sum = sum + x ;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> )&#123; <span class="comment">//这里i大于0就说嘛至少读入了一个数 </span></span><br><span class="line">average = <span class="number">1.0</span> * sum / i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, average ) ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; j++)&#123; </span><br><span class="line"><span class="comment">//这个 for 循环目的是为了遍历数组number里面所有的元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,number[j]) ;</span><br><span class="line"><span class="comment">//输出number里所有的元素</span></span><br><span class="line"><span class="keyword">if</span>( number[j] &gt; average )&#123;</span><br><span class="line"><span class="comment">//使用数组中的元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,number[j]) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以用一下代码查看一下，程序中，数组具体的运行情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> , x ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; <span class="number">5</span> ; i++ ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i) ;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= i ; j++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,number[j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其运行结果如下：</p><p><img src="https://www.hualigs.cn/image/6052e612d5a00.jpg"></p><p>　　可以看出来，第一轮在数组0的位置上放了1，第二轮在数组1的位置上放了2……</p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a><FONT COLOR = Cyan>定义数组</font></h2><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的定义</strong></font>：<br>　　<FONT COLOR = LimeGreen>&lt; 类型 &gt; 变量名称 [ 元素数量 ]</font>。这个类型并不是指的数组的类型，严格意义来说而是数组中每一个单元的类型。<br>　　<code>int grades [100];</code>这个数组里面有100个元素，每个元素都是 int 型。<br>　　<code>double weight [20]</code> 这个数组里面有20个元素，每个元素都是double型。<br>　　元素的数量一定要是整数。<br>　　<Font Size = 2>C99以前，元素的数量一定要是常数。但是C99以后，元素的数量也可以是变量。</font></p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的宏观感受</strong></font>：类似一种容器，有三个特点：<br>　　1、所有的元素都有相同的数据类型<br>　　2、一旦创建，就不能改变大小<br>　　3、数组中的元素在内存中是连续依次排序的。</p><p>　　以 <code>int a [10]</code>为例：<br>　　这是一个 int 型的数组，这个数组里有10个元素，每个单元都是一个 int 型的变量，分别是：a[0]、a[1],……,a[9]。<br>　　数组的每个单元就是数组类型的一个变量，使用数组时，放在 [ ] 中的数字叫做下标或索引，下标是从 0 开始计数。所以最大的下标是数组大小减一。<br>　　数组的元素可以出现在赋值的左边或者右边。<code>a[2] = a[1] + 6 ;</code>是可以这么写的。赋值左边称为左值，在指针里面会知道，左值和右值是有区别的。</p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>有效的下标范围</strong></font><br>　　编译器和运行环境都不会去检查数组下标<Font Size = 2>（也可以叫做索引）</font>是否越界，无论是对数组单元做读还是写。<br>　　一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃：</p><blockquote><p>segmentation fault</p><p>array index _ is past the end of the array</p></blockquote><p>　　也有可能运气好，没造成严重地后果，程序运行正常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　比如这种情况，<code>a[10] = 0 ;</code>实际上已经出错了，但是编译器并没有报错，实际上，这段代码把 0 写到了不该写的地方，带来的后果是，程序实际上没有运行。比如有以下手段来检验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main here\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A here\n&quot;</span>) ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B here\n&quot;</span>) ; <span class="comment">//这种技巧常常用来判断程序运行状况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　P.S. 不同的编译器要求不一定相同，但这样的写法是不安全的。</p><p>　　所以一个好的习惯，<FONT COLOR = LimeGreen>就是保证程序只去使用有效的下标值：0 ~ 数组大小-1。</font></p><p>　　所以上面那个计算平均数的程序是有一定风险的，因为一旦用户输入的数字超过100个，程序就报错了。解决办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字的数量： \n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count) ;</span><br><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">int</span> number[count] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　让用户先想好要输入数字的数量，然后定义数组的大小，这种写法，是C99 Only。</p><p>　　<Font Size = 2><code>int a [0] ;</code>这种东西可以存在，但是毫无用处，因为此时数组的大小是空的，即便是 a [0] 也越界了。</font></p><h2 id="例子：统计个数"><a href="#例子：统计个数" class="headerlink" title="例子：统计个数"></a><FONT COLOR = Cyan>例子：统计个数</font></h2><p>　　写一个程序，输入数量不确定的 [ 0 , 9 ] 范围内的整数，统计每一种数字出现的次数，输入 -1 表示结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ; <span class="comment">//c99 only ，为了避免程序出现magic number</span></span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> count[ number ] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">count[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个for循环的目的是定义10个变量，且每个变量的初始值都是0 </span></span><br><span class="line"><span class="comment">//这个循环是使用数组的时候常用的，初始化数组循环 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">9</span> )&#123;</span><br><span class="line">count[ x ]++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个循环的目的是计数，仔细思考下</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span> , i , count[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个循环就是对数组 count 的遍历 </span></span><br></pre></td></tr></table></figure><h1 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a><FONT COLOR = SpringGreen>数组运算</font></h1><p>　　如何去写一个   搜索的程序？先看看以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组集成初始化"><a href="#数组集成初始化" class="headerlink" title="数组集成初始化"></a><FONT COLOR = Cyan>数组集成初始化</font></h2><p>　　<code>int a[] = &#123;2,4,6,7,1,3,5,9,11,13,23,14,32&#125; ;</code>这段代码是<FONT COLOR = LimeGreen>数组的集成初始化</font>。定义数组时有两种办法，第一种是不去初始化它，第二种方法就是这样，直接用大括号给出数组的所有元素的初始值——给他一组数字，用这组数字去初始化数组。<br>　　使用这种办法的时候，不用给出数组的具体大小，[ ] 里没有数字，让编译器来数数。<br>　　如果强行去给数组的大小，而且后面的值不匹配怎么办？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>] = &#123;<span class="number">2</span>&#125;;<span class="comment">//这里就是强行定义数组大小，且大于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">13</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种情况下，输出值如下：</p><p><img src="https://www.hualigs.cn/image/6061a78f25d41.jpg"></p><p>　　可以说，这种情况下，其实就是给<code>a[0]</code>赋值，其余没有赋值，编译器则用0来补充。所以以下两种写法是相同的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　反过来呢？如果定义的数组长度小于集成初始化给的长度呢？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;<span class="comment">//强行规定数组大小，且小于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]<br>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]</p></blockquote><p>　　此时会有如上警告。</p><p>　　还有一个小问题，如果对于大小为3个的数组，在遍历输出的时候，如果不小心输出的长度大于3会如何？看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061c5e0007d3.jpg"></p><p>　　可以看出来，前三位是正常的，分别是<code>a[0] a[1] a[2]</code>但是后面的数，就是程序不存在的东西，实际上是内存原有的东西。</p><h2 id="集成初始化定位"><a href="#集成初始化定位" class="headerlink" title="集成初始化定位"></a><FONT COLOR = Cyan>集成初始化定位</font></h2><p>　　C99 only！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>　　用<code>[n]</code>在初始化数据中给出定位。<br>　　没有定位的数据接在前面的位置后面，比如这个定义，实际上<code>a[3] = 6</code>。<br>　　其他位置的值补零。<br>　　也可以不给出数组大小，让编译器自己算，比如这个数组，如果不给出长度为10，那么编译器会认为他的长度为3。<br>　　特别适合初始数据稀疏的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061d836cd5cb.jpg"></p><h2 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a><FONT COLOR = Cyan>数组的大小</font></h2><p>　　<code>sizeof</code>是一个运算符，可以告诉我们这个量有多大。对数组使用<code>sizeof</code>可以给出整个数组所占据的内容大小，单位是字节。可以求出这个数组占据多少个字节。<br>　　比如上条程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时就会输出40、4。说明在改数组中，一个元素占据4个字节，一共占据40个字节，所以一共有十个元素。</p><p><FONT COLOR = LimeGreen>　　所以对于任何一个数组，可以使用<code>sizeof(a)/sizeof(a[0])</code>来计算数组中的元素。</font>这样的代码，最大的好处是：一旦修改数组中初始的数据，不需要修改遍历的代码，比如把遍历的代码改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++ )&#123;<span class="comment">//这样就安全多了，也不会出现 magic number</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a><FONT COLOR = Cyan>数组的赋值</font></h2><p>　　已知一个数组<code>a[]</code>，能不能用这个数组直接给另外一个数组赋值？比如说;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125; ;<span class="comment">//最末尾这个逗号可有可无</span></span><br><span class="line"><span class="keyword">int</span> b[] = a ; <span class="comment">//无效的初始值设定项</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时会报错：</p><blockquote><p>[Error] invalid initializer</p></blockquote><p>　　<FONT COLOR = LimeGreen>数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历</font></p><p>　　以下就是目前接触的遍历数组的情况。<br>　　其中<code>length = sizeof(a)/sizeof(a[0])</code></p><p>　　把数组 a 的值全都赋值给数组 b ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line">b[i] = a[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　把数组 a 全部赋值为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有和关键字相同的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++  )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有大于平均数的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; average)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　遍历数组，并且将他们全部输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,i,a[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>对于数组的遍历，通常是使用 for 循环，让循环变量 i 从 0 到（&lt;） 数组的长度</font>，这样循环体内的 i 正好是数组最大的有效下标（length -1）。<br>　　<FONT COLOR = LimeGreen>常见错误</font>：<br>　　循环结束条件是 &lt;= 数组长度。此时刚好会多输出一个量，此时程序会超过数组的长度（非常危险）。<br>　　离开循环后，继续用 i 的值来做数组元素的下标。此时 i 的值是 length 也就是说已经超过数组范围了。</p><h2 id="搜索程序解读"><a href="#搜索程序解读" class="headerlink" title="搜索程序解读"></a><FONT COLOR = Cyan>搜索程序解读</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>主程序</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　其中，主程序会调用 search 这个函数，并且返回一个值给 loc 。如果返回值是 -1 ，则说明输入的数字不在数组中；否则，则输出该数字在改数组的第几位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>search 函数</strong></font>：</p><p>　　找出 key 在数组 a 中的位置，其中该函数有三个参数：<br>　　key ：要寻找的数字。a 要寻找的数组。length 数组a 的长度。<br>　　ret 是函数最后的返回值，如果找到，则让 ret 返回为 key 在 a 的位置。如果找不到就返回 -1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;<span class="comment">//对数组遍历，每次遍历是拿出一个单元，判断和 key 是否相等。</span></span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>当函数的参数是数组的时候</font>，比如这个 search 函数，往往必须再用另一个参数传入数组的大小，此时不太好用 <code>sizeof(a)/sizeof(a[0])</code>。<br>　　此时不能在 [ ] 中直接给出数组的大小，也不能利用 sizeof 计算数组的元素个数。<br>　　所以这里引入 length 。</p><h1 id="例子：素数"><a href="#例子：素数" class="headerlink" title="例子：素数"></a><FONT COLOR = SpringGreen>例子：素数</font></h1><p>　　先复习一下，之前用 if - else 判断素数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> x , i ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; i &lt; x ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPrime)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数&quot;</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序有个缺陷，对于 n 可能要循环 n - 1 遍，如果 n 非常大，则程序效率不高。</p><h2 id="算法改进1"><a href="#算法改进1" class="headerlink" title="算法改进1"></a><FONT COLOR = Cyan>算法改进1</font></h2><p>　　首先判断 x 是否为偶数，如果是偶数，立马认为其不是素数。去掉偶数后，让 i 从 3 到 x - 1 ，每次都加 2。具体操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt; x ; i = i + <span class="number">2</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由于几乎去掉了所有的偶数，所以和原来相比，我们只需要走一半的循环即可。</p><h2 id="算法改进2"><a href="#算法改进2" class="headerlink" title="算法改进2"></a><FONT COLOR = Cyan>算法改进2</font></h2><p>　　不需要到 x - 1，到 <code>sqrt(X)</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt;= <span class="built_in">sqrt</span>(x) ; i = i + <span class="number">2</span> )&#123;<span class="comment">//这里老师写成了小于，我认为应该是小于等于。</span></span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为什么只要算到根号x即可？因为整除嘛。这样大大提高了效率。</p><h2 id="算法改进3：构造素数数组"><a href="#算法改进3：构造素数数组" class="headerlink" title="算法改进3：构造素数数组"></a><FONT COLOR = Cyan>算法改进3：构造素数数组</font></h2><p>　　只要拿比 x 小的素数除一除就可以了（分解质因数原理），所以要先构造一张已经有了的素数的表。</p><p>　　比如先要构造一张前100个素数的表（数组），main 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>其中这里的<code>prime[count++] = i ;</code>是一个套路。</font>对于这个大小为100的数组，[ 0 ] 上已经放了 2 。所以接下来就是让 [ 1 ] 这个位置上放置接下来的一个素数。<code>prime[count++] = i ;</code>实际上是，现在自加 1 之前的位置上，放置 i ，然后再对count 自加 1 。所以，如果这里 count 的初始值是 0 ，那么就应该是<code>++count</code>。</p><p>　　其中，判断素数的函数 <code>isPrime()</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123; <span class="comment">//这个for循环实际上是对数组 knownPrimes[] 的遍历</span></span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　该函数需要三个参数，分别是 x 、已经判断过的素数、素数排行（是第几个素数）。该函数里面的 i 和 main 函数里面的 i 是不同的，这个 i 是独立的。<br>　　<code>x</code>，就是我们需要判断的数，这个函数就是用来判断 x 是不是素数。<br>　　<code>knownPrimes[ ]</code> ，可以看到，第二个参数是一个数组，这个数组就是 main 函数里的 prime 。<FONT COLOR = RED>这里有个问题，为什么 main 里面调用函数的时候第二个参数给的是 prime ，这里的 prime 值是多少？</font>总而言之，这个数组应该是一个素数集合。<br>　　<code>numberofKnowPrimes</code>就是目前已经有了多少个素数。注意 for 里面的，是小于号。</p><p>　　为了更好地了解这两段代码的运行模式，可以加一段调试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d \t count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　为了美观，可以用同样调试的技巧，在<code>while</code>前面加一段表头的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">10</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line">&#123;<span class="comment">//为了美观，输出几个表头与后面的调试代码对齐</span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 和外面的 i 无关 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;  </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后遍历并且输出 <code>prime[ ] </code>这个数组，并且为了美观，每个数都输出一个制表符，然后每五个数换一次行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123; <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后构造前100个素数的数组程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;<span class="comment">//从3开始判断这个数是不是素数。</span></span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//这里不能自作聪明写 i = i + 2 。有很多素数相差只有2。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但这里只是构造了一个素数数组，具体如何用这个数组来做素数判断？我以后再研究？初步思路是：<br>　　1、判断这个数是否和数组里面的数相同，如果有相同的，直接判断为素数。<br>　　2、否则的话，让这个数和数组里的数做除法，如果能除尽，直接判断为合数。<br>　　3、否则的话，<Font Size = 2><em>这种情况就比较复杂，这个素数数组里最后两个数是 523 和 541。也就是说，比 <code>523 * 541 </code>大的数，这个数组就判断不了了。</em></font>我目前想着，int 型最大的数是 (2^31)-1，是十位数，所以让 number = 10000，就基本在 int 不爆炸的情况下，用第二步算完了。</p><p>　　<font color = red> 但是这样子，每次都要循环遍历检验一次数组，这样真的会加快效率吗？存疑</font></p><h2 id="算法改进4：构造素数表"><a href="#算法改进4：构造素数表" class="headerlink" title="算法改进4：构造素数表"></a><FONT COLOR = Cyan>算法改进4：构造素数表</font></h2><p>　　欲构造 n 以内的素数表：<br>　　1、令 x 为2<br>　　2、将 2x、3x、4x 直到 ax &lt; n 全部标记为非素数。<br>　　3、令x为下一个没有被标记为非素数的数，重复2；直到所有的数全部尝试完毕。</p><p>　　这个算法，相当于从 2 开始，一直到 n，一个个把素数的倍数给划掉。最后留在表里面的，全是素数。伪代码如下：</p><p>　　欲构造 n 以内（不含）的素数表：<br>　　1、开辟<code>prime[n]</code>，初始化所有元素为1，<code>prime[x]</code>为1就表示 x 是素数。<br>　　2、令 x = 2<br>　　3、如果 x 是素数，则对于<code>( i = 2 ; x * i &lt; n ; i++ )</code>令<code>prime[x * i] = 0</code><br>　　4、令 x++ ，如果 x &lt; n ，重复3，否则结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历初始化</span></span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历输出，这样会使得0，1一定会输出，可以让i从2开始。</span></span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　翁老师还改进了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[x] )&#123;<span class="comment">//这里加一个 if 之后，比如当 x 是15的时候，程序就不会进入这个if了，因为早在 x 是3的时候，prime[15]就被赋值为0.</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><FONT COLOR = SpringGreen>二维数组</font></h1><p>　　<code>int a[10]</code>这个数组只有一个下标，可以看做是一维数组，线性的。<br>　　<code>int a[3][5]</code>就是二维数组，对于二维数组，可以理解为 a 是一个3行5列的矩阵：</p><table><thead><tr><th><code>a[0][0]</code></th><th><code>a[0][1]</code></th><th><code>a[0][2]</code></th><th><code>a[0][3]</code></th><th><code>a[0][4]</code></th></tr></thead><tbody><tr><td><code>a[1][0]</code></td><td><code>a[1][1]</code></td><td><code>a[1][2]</code></td><td><code>a[1][3]</code></td><td><code>a[1][4]</code></td></tr><tr><td><code>a[2][0]</code></td><td><code>a[2][1]</code></td><td><code>a[2][2]</code></td><td><code>a[2][3]</code></td><td><code>a[2][4]</code></td></tr></tbody></table><p><Font Size = 2>　　如果不考虑数组在计算机内存中是如何排列的，那么把它看成5行3列也没关系小，但是不建议这么做。倾向于第一个下标为行数，第二个下标为列数</font></p><h2 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a><FONT COLOR = Cyan>二维数组遍历</font></h2><p>　　用两个 for 循环就可以遍历二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">5</span> ; j++ )&#123;</span><br><span class="line">a[i][j] = i*j ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　以<code>int a[i][j]</code>为例，该数组里所有的元素都是 int 型。特别注意的是，<code>a[i,j]</code>在C语言里表示<code>a[j]</code>，因为此时逗号是运算符。</p><h2 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a><FONT COLOR = Cyan>二维数组的初始化</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>集成初始化</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">5</span>] =  &#123;<span class="comment">//列数是不能省略的！！</span></span><br><span class="line">&#123; <span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>&#125; ,</span><br><span class="line">&#123; <span class="number">2</span> , <span class="number">3</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span>&#125; ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　列数是必须给出的，行数可以让编译器来数。<br>　　每行一个 ｛ ｝ ，用逗号分离<br>　　最后的逗号可以存在（古老的传统）<br>　　如果省略，表示补零，和一维数组相同。<br>　　也可以用初始化定位，和一维数组相同（ C99 Only）</p><h2 id="三连棋"><a href="#三连棋" class="headerlink" title="三连棋"></a><FONT COLOR = Cyan>三连棋</font></h2><p>　　读入一个 3 × 3 的矩阵，矩阵中的数字 1 则表示这个位置上有一个 X，数字 0 则表示位置上有一个 O。只要有一方的棋子连成一条线了，则获胜。程序然后判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符 X or O，或输出无人获胜。</p><p>　　读入矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> numOfX , numOfY ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，2：Y赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>　　检查行是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查列是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　显然这两个循环长得差不多，那么问题来了，能不能用一个两重循环来检查行和列？把他们合并起来？</p><p>　　检查对角线：<br>　　主对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查副对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;<span class="comment">//这是一个表示副对角线的套路，记忆一下。</span></span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后的程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，0：O赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;X赢了&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( result == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;O赢了&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不分胜负&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>chapter 07 Function</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/</id>
    <published>2021-03-07T13:59:47.000Z</published>
    <updated>2021-04-02T09:01:38.438Z</updated>
    
    <content type="html"><![CDATA[<p>函数</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><FONT COLOR = SpringGreen>函数</font></h1><p>　　不要从数学的意义来理解函数，要从 function（功能）的意义来理解函数。</p><h2 id="初见函数"><a href="#初见函数" class="headerlink" title="初见函数"></a><FONT COLOR = Cyan>初见函数</font></h2><h3 id="求素数和"><a href="#求素数和" class="headerlink" title="求素数和"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>求素数和</strong></font></h3><p>　　求 m ~ n 之间所有素数的和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i - <span class="number">1</span> ; k++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( isPrime == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br></pre></td></tr></table></figure><p>　　对于里面判断素数的循环，功能是非常单一的——就是判断循环。对于这种功能单一的代码，可以做成一个函数（function），那样既可以让程序变得简洁，也提高了可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;<span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( Ret(i) == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　### <Font Color = DarkCyan size = 4 Face = 仿宋><strong>多次求和</strong></font></p><p>　　求出1<del>10、20</del>30、35~45 的三个和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i , sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">20</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">30</span>; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">35</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">45</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br></pre></td></tr></table></figure><p>　　这三段是几乎一模一样的。<br>　　Code Duplication，“代码复制”是程序质量不良的表现：<br>　　1、如果将来要做修改维护的时候，会使得维护的地方变得很多。<br>　　2、使代码特别冗长。</p><p>　　对于这种需要重复使用到的“功能function”，不如做成求和函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的定义与使用"><a href="#函数的定义与使用" class="headerlink" title="函数的定义与使用"></a><FONT COLOR = Cyan>函数的定义与使用</font></h2><p>　　函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>定义函数</strong></font></h3><p>　　以下列代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　<FONT COLOR = LimeGreen>　<code>void sum(int begin , int end )</code>称为函数头；<br>　　<code>void</code>是返回类型（空类型，不返回结果）；<br>　　<code>sum</code>是函数名；<br>　　<code>(int begin , int end )</code>是参数表。<br>　　<br>大括号里面的称为函数体，大括号是必须的。</font></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>调用函数</strong></font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">sum(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　调用函数时，要首先给出：函数名（参数值）。该函数有多少个参数，就需要传递多少个参数，而且要传递正确的数据类型、给出正确的数量和顺序。这些值会被按照顺序依次用来初始化函数中的参数。<br>　　如果调用的参数少了，或者小括号里没有逗号，就会出现以下错误：</p><blockquote><p>error: too few arguments to function</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数名后的 ( ) 非常重要</font>，这个小括号起到了表示函数调用的重要作用，即使没有参数也需要有小括号。<br>　　比如说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers() ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是如果没有这个小括号，就会报错（有的编译器不会报错，但此时也不会调用函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning: expression result unused cheer ;</p></blockquote><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a><FONT COLOR = Cyan>Return</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数用来判断素数，最后会返回一个值：isPrime。这个返回的结果，最后会返回给调用它的地方。这个函数 Ret 的类型是 int ，所以有一个返回的int的结果。</p><p>　　return 表示停止函数的执行，并且返回一个函数值。return 有两种写法：<br>　　<code>return ;</code>直接结束<br>　　<code>return 表达式</code>把这个值交给函数调用它的地方</p><p>　　比如上段代码，函数运行之后，return 会使得 isPrime 有一个值。后面程序在调用函数的时候，就会把这个值作为运算结果。<Font Size = 2>（讲起来有点绕，后面再看看其他资料）</font></p><p>　　一个函数里可以出现多个return。但是如果一个函数里去使用多个return的话，那么这个函数就会有多个出口，不符合<FONT COLOR = LimeGreen>单一出口原则</font>。</p><p>　　函数的返回值可以赋值给变量、可以再传递给函数、甚至可以丢掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;</span><br><span class="line">c = MAX( a , b ) ;</span><br><span class="line">c = MAX( c , <span class="number">23</span> ) ;</span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;</span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上述所有写法都是对的，其中所有 MAX 的值，都是函数最后 return 得到的值。<br>　　其中这个<code>MAX(12,34)</code>做了一次调用，但是没有把值交给任何人，就是把函数运行的结果丢掉了。——有时候调用函数的目的并不是要看函数返回的结果，而是要函数的副作用（比如输出一个什么东西）</p><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a><FONT COLOR = Cyan>无返回值的函数</font></h2><p>　　如果我们需要一个没有返回值的函数，以以下代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>void 函数名(参数表)</font></p><p>　　不能使用带值得 return ，如果使用了，会出现以下错误：</p><blockquote><p>[Warning] ‘return’ with a value, in function returning void [enabled by default]</p></blockquote><p>　　可以没有 return ，到函数最后一行，函数自动结束。</p><p>　　调用的时候不能做返回值得赋值。此时 SUM 不会返回值，比如以下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时的<code>SUM(1,10) </code>就是不需要SUM的值，只需要他的副作用——输出一个和。此时SUM的值如下：</p><p><img src="https://www.hualigs.cn/image/605e9f1b1cb95.jpg"></p><h1 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a><FONT COLOR = SpringGreen>函数的参数和变量</font></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><FONT COLOR = Cyan>函数原型</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C的编译器是自上而下分析代码。所以要把函数的定义像这样写在程序的最开始。<br>　　在看到<code>SUM(1,10) ;</code>的时候，程序需要知道 <code>SUM( )</code> 的样子——<FONT COLOR = LimeGreen>函数的名字、函数需要几个参数，每个参数的类型、返回什么类型</font>。这样编译器才能检查程序对 <code>SUM()</code>的调用是否正确。</p><p>　　如果不这样会发生什么？把要调用的函数放在 <code>main()</code>的下面试一试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ; <span class="comment">//int SUM(int,int)</span></span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><blockquote><p>[Warning] conflicting types for ‘SUM’ [enabled by default]<br>[Note] previous implicit declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>特别注意，不同编译器对C语言的要求都不同，有的严格有的宽松，具体报错的信息不一定相同</font><br>　　conflicting types 意思是类型冲突。</p><p>　　对于C99以前的标准，程序读到<code>SUM(1,10) ;</code>时，发现此时没有定义 <code>SUM()</code>这个函数，程序会去猜 <code>SUM()</code>的情况，会去假设<code>SUM()</code>里的类型是两个int，并且会返回一个 int 值：<code>int SUM(int,int)</code>。这种做法叫做隐式声明，C99以后就不用了。</p><blockquote><p>warning: implicit declaration of function ‘SUM’ is invalid in C99</p></blockquote><p>　　那么当程序读到<code>SUM(1,10) ;</code>时候，程序会猜这个函数是<code>int SUM(int,int)</code>，但后面对函数定义的时候，又定义其为<code>void SUM(int, int)</code>，所以后面程序会 warning： conflicting types </p><p>　　在实际的工程项目中，很多时候都希望第一眼能看到<code>main()</code>的样子，而不是一大堆函数的定义。所以就有了<FONT COLOR = LimeGreen>原型声明——把函数头+分号放到程序最开头。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>; <span class="comment">//原型声明，在 main 函数之前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义，在main函数以后</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　程序看到原型声明后，会先记住函数的样子，然后遇到<code>main</code>里面的函数调用的时候，会先采取原型声明里面的定义，最后读到下面函数定义的时候，再一次检查函数调用是否正确。</p><p>　　如果原型和定义冲突怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　和上面隐式声明一样，出现类型冲突的错误：</p><blockquote><p>[Error] conflicting types for ‘SUM’<br>[Note] previous declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数原型</font><br>　　<code>函数头；</code>函数头以分号结尾就构成了函数原型<br>　　函数原型的目的是告诉编译器这个函数长什么样：<br>　　名称；<br>　　参数数量以及参数类型<br>　　返回类型</p><p>　　函数原型的主要目的是告诉编译器函数长什么样，所以对待具体参数的变量名不做检查和要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>; <span class="comment">//原型声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时原型声明可以写成：<br>　　<code>void SUM(int, int) ; </code><br>　　<code>void SUM(int a , int b ) ;</code><br>　　都可以，没有关系，因为编译器在原型声明检查的时候不会检查参数名称，只会检查函数名称、返回类型、参数数量和类型。但为了阅读起来方便，最好是直接把函数头复制过来加分号会好一点，因为要方便人去阅读和修改。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><FONT COLOR = Cyan>参数传递</font></h2><p>　　如果函数有参数，调用函数时必须传递给它数量、类型正确的值。可以传递给函数的值是表达式的结果，包括：字面量、变量、函数的返回值、计算结果。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;<span class="comment">//字面量</span></span><br><span class="line">c = MAX( a , b ) ;<span class="comment">//变量</span></span><br><span class="line">c = MAX( c+<span class="number">3</span> , <span class="number">23</span> ) ;<span class="comment">//计算的结果</span></span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;<span class="comment">//函数返回值</span></span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是因为C语言对于表达式的定义非常宽，单一的字面量、单一的变量、进行计算的结果、赋值全部都是表达式。函数调用本身、函数调用结果，全部都是表达式。</p><h3 id="类型不匹配"><a href="#类型不匹配" class="headerlink" title="类型不匹配"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>类型不匹配</strong></font></h3><p>　　如果参数传递类型不匹配会怎么样？<br>　　<FONT COLOR = LimeGreen>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞。<br>　　编译器总是悄悄替你把类型转换好，但是这可能不是你所期望的。<br>　　后续的语言，C++/Java 在这方面要求非常严格。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序就是非常简单的函数定义以及函数调用，如果调用时参数传递类型不匹配怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1.1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时程序实际上是出错了，因为<code>cheer()</code>函数要求参数是整型，而调用时的参数是浮点数。此时编译会有两种情况：<br>　　情况1：编译器给出warning，编译器在执行过程中，故意把double型的1.1转化为了整型的1。</p><blockquote><p>warning: implicit conversion from ‘double’ to ‘int’ change value form 1.1 to 1</p><p>此处出现了一个隐含的转化，从 double 转化为 int。</p></blockquote><p>　　情况2：编译器连 warning 都没有，直接通过了编译。</p><p>　　对于绝大多数编译器，以下写法不会出现 warning。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> f = <span class="number">1.1</span> ;</span><br><span class="line">cheer(f) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C语言做不到类型匹配的自动检查！！！</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>传值</strong></font></h3><p>　　能不能写一个交换 a b 值的函数？试试看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样的代码可以交换 a 和 b 的值吗？答案是不能的。可以用调试查看一下各个变量的值：</p><p><a href="https://imgtu.com/i/6z6nET"><img src="https://z3.ax1x.com/2021/03/27/6z6nET.png" alt="6z6nET.png"></a></p><p>　　这里可以看出来，当程序运行到 <code>exchange()</code>函数里面的时候，变量 a ，b 的状态都是</p><blockquote><p>Not found in current context。</p><p>在当前上下文找不到</p></blockquote><p>　　也就是说，当程序运行到  <code>exchange()</code>函数里面的时候，变量 a b 都是不存在的。同理，当程序运行到<code>main()</code>函数里面的时候，x y t 也都是不存在的：</p><p><a href="https://imgtu.com/i/6z67q0"><img src="https://z3.ax1x.com/2021/03/27/6z67q0.png" alt="6z67q0.png"></a></p><p>　　尝试一下查看<code>exchange( a , b ) ;</code>的值，看清楚这一步到底是干什么的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exchange(a,b)=%d\n&quot;</span>,exchange(a,b)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a ;</span><br><span class="line">a = b ;</span><br><span class="line">b = t ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/605f014f01a82.jpg"></p><p>　　可以看出来，<code>exchange( a , b ) ;</code>实际上是进入exchange函数，然后返回 exchange 的值，对于第一段代码<code>void exchange( int a , int b ) ; </code>此时 exchange 不返回值，对于第二段代码<code>int exchange( int a , int b ) ; </code>返回的就是 return 的值。<br>　　除此之外，<code>exchange( a , b ) ;</code>并不能实际上改变 a 和 b 的值。<br>　　所以这样的函数不能交换 a 和 b 的值。</p><p>　　每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。<br><FONT COLOR = LimeGreen>　　函数和<code>main</code>的关系是参数和值得关系，C语言在调用函数的时候，永远只能传值给函数。</font></p><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a><FONT COLOR = Cyan>本地变量</font></h2><p>　　Local variables 也翻译成局部变量。<br>　　函数的每一次运行就会产生一个独立的变量空间，在这个空间中的变量是函数的这次运行所独有的，称作本地变量。<br>　　所有定义在函数内部的变量就是本地变量。<br>　　参数也是本地变量。</p><h3 id="生存期和作用域"><a href="#生存期和作用域" class="headerlink" title="生存期和作用域"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>生存期和作用域</strong></font></h3><p>　　生存期：什么时候变量开始出现，到什么时候变量消亡。<br>　　作用域：在代码的什么范围内可以访问这个变量（这个变量可以起作用的领域）<br>　　对于本地变量，这两个答案是统一的：<FONT COLOR = LimeGreen>大括号——块</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当程序运行在<code>main()</code>里面时，t x y 是不存在的：<code>Not found in current context</code>。当程序运行在<code>exchange()</code>里面时，a b也是不存在的，<code>Not found in current context</code>。</p><h3 id="本地变量规则"><a href="#本地变量规则" class="headerlink" title="本地变量规则"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>本地变量规则</strong></font></h3><p>　　<FONT COLOR = LimeGreen>本地变量是定义在块（一组大括号）内的</font><br>　　这个块可以使函数的块，也可以是语句的块，甚至可以随便拉一对大括号来定义变量。比如下面的 if 语句块里面对 i 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;<span class="comment">//这个i生存期和作用域就在这个块里面，离开这个块，i就不存在了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个 i 的生存期和作用域都在 if 控制的这个块里面，所以每次进入<code>main()</code>，这个 i 都不一定存在（因为 if 不一定执行）。如果此时想要在 if 块外面使用 i ，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//在i的生存期和作用域之外使用它</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　报错：</p><blockquote><p>[Error] ‘i’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>　　<FONT COLOR = LimeGreen>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中变量就消失了</font></p><p>　　对上面程序进行调试就可以知道，进入 if 的时候 i 是存在的，出大括号后 i 就是<code>Notfound in current context</code>。</p><p>　　<FONT COLOR = LimeGreen>在块外面定义的变量在块里面任然有效。</font>里面定义的变量出来就不存在了。</p><p>　　同样对上面程序进行调试，在 if 所控制的块里面， a 和 b 都是可以读到的。</p><p>　　<FONT COLOR = LimeGreen>若块里面定义了和外面同名的变量，则里面的变量会掩盖外面的变量。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其中输出的值为：</p><p><a href="https://imgtu.com/i/cSKYCQ"><img src="https://z3.ax1x.com/2021/03/27/cSKYCQ.png" alt="cSKYCQ.png"></a></p><p>　　可以看出来在 if 控制的块里面，a 的值覆盖了外面 a 的值。但是出来之后，里面的 a 不存在了，a 又回到了初始的状态。</p><p>　　不是所有的编程语言都是这么干的！！！</p><p>　　<FONT COLOR = LimeGreen>不能再一个块里面定义同名的变量</font></p><blockquote><p>[Error] redefinition of ‘a’<br>[Note] previous definition of ‘a’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>本地变量不会被默认初始化</font></p><p>　　<FONT COLOR = LimeGreen>参数在进入函数的时候会被初始化</font></p><h2 id="函数庶事"><a href="#函数庶事" class="headerlink" title="函数庶事"></a><FONT COLOR = Cyan>函数庶事</font></h2><h3 id="没有参数时"><a href="#没有参数时" class="headerlink" title="没有参数时"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>没有参数时</strong></font></h3><p>　　<code>void f(void)</code>还是<code>void f()</code><br>　　<code>void f(void)</code>明确告诉编译器，f 函数不接受任何参数。在传统的C中，<code>void f()</code>表示 f 函数的参数未知，并不表示没有参数；现在编译器如何处理呢？尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;<span class="comment">//到这一行的时候，编译器猜测exchange需要两个int型参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时编译通过。编译器理解为，遇到函数原型时，知道有一个函数 <code>void exchange</code>，但不太确定他的参数个数和参数类型。于是编译器根据下面，猜想为双变量，int 型。<br>　　如果此时编译器猜错了呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段程序通过编译了！<br>　　此时程序输出：<br>　　in exchange ， a = 0.000000，b = 0.000000<br>　　in main ，a = 5 b = 6。<br>　　可以看出来，虽然编译器在语法上没有发现这段程序出错，但实际上程序第一次运行到<code>exchange( a , b ) ;</code>时，是认为 exchange 是 int 型。等到运行完下面的函数部分，第二次运行到<code>exchange( a , b )</code>时，把两个整型的量交给<code>exchange</code>，此时就出错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是这种写法就是正确的，此时虽然也是把两个整型交给 exchange 。但是一开始原型声明就正确了，使得后面整型变量会自动转化为 double 型。</p><p>　　<FONT COLOR = LimeGreen>所以，不要这么些函数原型<code>void f()</code></font></p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>逗号运算符</strong></font></h3><p>　　在C语言里，逗号也是一种运算符，比如<code>(a,b)</code>，此时右边的 b 就是其运算的结果。那么调用函数时的逗号和逗号运算符如何区分？<br>　　<code>F(a,b)</code>调用函数时，小括号的逗号是标点符号，不是运算符。<br>　　<code>F((a,b))</code>此时逗号是运算符，此时函数的参数只有1个，</p><h3 id="不可嵌套定义函数"><a href="#不可嵌套定义函数" class="headerlink" title="不可嵌套定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>不可嵌套定义函数</strong></font></h3><p>　　C语言里不允许函数的嵌套定义，也就是说函数内部不能再定义函数。可以放函数的声明，但不能放函数体（body）</p><h3 id="糟糕的写法"><a href="#糟糕的写法" class="headerlink" title="糟糕的写法"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>糟糕的写法</strong></font></h3><p>　　<code>int i , j , sum( int a , int b )</code>这种写法等同于<code>int i , j ; int sum( int a , int b )</code>不推荐这种写法，不利于阅读。<br>　　<code>return（i）</code>这个 (i) 可有可无，但这会让人误解 return 是一个函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>克疾文轩</title>
  
  <subtitle>徐思远的记录空间</subtitle>
  <link href="https://github.com/XuSiyuan-cn/atom.xml" rel="self"/>
  
  <link href="https://github.com/XuSiyuan-cn/"/>
  <updated>2021-03-23T18:12:28.262Z</updated>
  <id>https://github.com/XuSiyuan-cn/</id>
  
  <author>
    <name>XuSiyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3月的结束</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/</id>
    <published>2021-03-23T18:12:28.075Z</published>
    <updated>2021-03-23T18:12:28.262Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>三月快结束啦</FONT></p><a id="more"></a><p>还没准备好呢，今年就已经过去一个季度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(P的分数高&amp;&amp;科目不变)&#123;</span><br><span class="line">瞄准一波P;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;三月快结束啦&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter 16 Interactive Graphic Design</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/</id>
    <published>2021-03-16T13:59:47.000Z</published>
    <updated>2021-03-29T05:41:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>交互图形设计</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;交互图形设计&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 15 ACLLib</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/</id>
    <published>2021-03-15T13:59:47.000Z</published>
    <updated>2021-04-06T03:09:29.856Z</updated>
    
    <content type="html"><![CDATA[<p>ACLLib的基本图形函数</p><a id="more"></a><h1 id="ACLLib介绍"><a href="#ACLLib介绍" class="headerlink" title="ACLLib介绍"></a><FONT COLOR = SpringGreen>ACLLib介绍</font></h1><h1 id="Win32API"><a href="#Win32API" class="headerlink" title="Win32API"></a><FONT COLOR = SpringGreen>Win32API</font></h1><h1 id="创建ACLLIB程序"><a href="#创建ACLLIB程序" class="headerlink" title="创建ACLLIB程序"></a><FONT COLOR = SpringGreen>创建ACLLIB程序</font></h1><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a><FONT COLOR = SpringGreen>基本绘图函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;ACLLib的基本图形函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 14 Linked List</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/</id>
    <published>2021-03-14T13:59:47.000Z</published>
    <updated>2021-04-06T03:08:20.467Z</updated>
    
    <content type="html"><![CDATA[<p>链表</p><a id="more"></a><h1 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a><FONT COLOR = SpringGreen>可变数组</font></h1><h1 id="可变数组数据访问"><a href="#可变数组数据访问" class="headerlink" title="可变数组数据访问"></a><FONT COLOR = SpringGreen>可变数组数据访问</font></h1><h1 id="可变数组自动增长"><a href="#可变数组自动增长" class="headerlink" title="可变数组自动增长"></a><FONT COLOR = SpringGreen>可变数组自动增长</font></h1><h1 id="可变数组的缺陷"><a href="#可变数组的缺陷" class="headerlink" title="可变数组的缺陷"></a><FONT COLOR = SpringGreen>可变数组的缺陷</font></h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><FONT COLOR = SpringGreen>链表</font></h1><h1 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a><FONT COLOR = SpringGreen>链表的函数</font></h1><h1 id="链表的搜索"><a href="#链表的搜索" class="headerlink" title="链表的搜索"></a><FONT COLOR = SpringGreen>链表的搜索</font></h1><h1 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a><FONT COLOR = SpringGreen>链表的删除</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 13 File</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/</id>
    <published>2021-03-13T13:59:47.000Z</published>
    <updated>2021-04-06T03:06:42.074Z</updated>
    
    <content type="html"><![CDATA[<p>文件</p><a id="more"></a><h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a><FONT COLOR = SpringGreen>格式化输入输出</font></h1><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a><FONT COLOR = SpringGreen>文件输入输出</font></h1><h1 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a><FONT COLOR = SpringGreen>二进制文件</font></h1><h1 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a><FONT COLOR = SpringGreen>按位运算</font></h1><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a><FONT COLOR = SpringGreen>移位运算</font></h1><h1 id="位运算例子"><a href="#位运算例子" class="headerlink" title="位运算例子"></a><FONT COLOR = SpringGreen>位运算例子</font></h1><h1 id="位段"><a href="#位段" class="headerlink" title="位段"></a><FONT COLOR = SpringGreen>位段</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 12 Program Structure</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/</id>
    <published>2021-03-12T13:59:47.000Z</published>
    <updated>2021-04-06T03:05:10.506Z</updated>
    
    <content type="html"><![CDATA[<p>程序结构</p><a id="more"></a><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><FONT COLOR = SpringGreen>全局变量</font></h1><h1 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a><FONT COLOR = SpringGreen>静态本地变量</font></h1><h1 id="全局变量tips"><a href="#全局变量tips" class="headerlink" title="全局变量tips"></a><FONT COLOR = SpringGreen>全局变量tips</font></h1><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a><FONT COLOR = SpringGreen>宏定义</font></h1><h1 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a><FONT COLOR = SpringGreen>带参数的宏</font></h1><h1 id="大程序"><a href="#大程序" class="headerlink" title="大程序"></a><FONT COLOR = SpringGreen>大程序</font></h1><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><FONT COLOR = SpringGreen>头文件</font></h1><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><FONT COLOR = SpringGreen>声明</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序结构&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 11 Structure Type</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/</id>
    <published>2021-03-11T13:59:47.000Z</published>
    <updated>2021-04-06T03:03:15.693Z</updated>
    
    <content type="html"><![CDATA[<p>结构类型</p><a id="more"></a><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><FONT COLOR = SpringGreen>枚举</font></h1><h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a><FONT COLOR = SpringGreen>结构类型</font></h1><h1 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a><FONT COLOR = SpringGreen>结构与函数</font></h1><h1 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a><FONT COLOR = SpringGreen>结构中的结构</font></h1><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a><FONT COLOR = SpringGreen>类型定义</font></h1><h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a><FONT COLOR = SpringGreen>联合</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;结构类型&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 10 Strings</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/</id>
    <published>2021-03-11T12:59:47.000Z</published>
    <updated>2021-04-27T10:34:56.413Z</updated>
    
    <content type="html"><![CDATA[<p>字符串</p><a id="more"></a><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><FONT COLOR = SpringGreen>字符串</font></h1><p>　　首先尝试定义一个字符数组：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;&#125; ;</code>。但这个东西只能算是字符数组，不是字符串，因为不能用字符串的方式做计算。</p><img src="https://www.hualigs.cn/image/606f00ffc435f.jpg" style="zoom:50%;" /><p>　　于是在字符数组上加点东西就变成了字符串：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;,&#39;\0&#39;&#125; ;</code>    在数组初始化的最后加一个<code>&#39;\0&#39;</code>或者<code>0</code>。此时字符数组一共有七个单元，最后的单元是一个0，此时这个东西即是字符数组，也是字符串。</p><img src="https://www.hualigs.cn/image/606f017eb0c38.jpg" style="zoom:50%;" /><p>　　<FONT COLOR = LimeGreen>何为字符串</font>：</p><p>　　字符串是以 0 （整数0）结尾的一串字符。0 和 ‘\0’ 是一样的，但是和 ‘0’ 不同。非要说差别，0 表示一个 int （整数，四个字节）；‘\0’ 表示数组里面的一个元素，是一个 char ，是一个字节； ‘0’是一个字符， 这个字符表示Acall码里面的 0 ，是<code>0x30</code>，是48。<br>　　0 标志着字符串的结束，但它不是字符串的一部分。计算<u>字符串</u>长度的时候不包含这个0。<br>　　字符串在内存中以数组的形式存在，以数组或指针的形式去访问。更多的是以指针的形式。<br>　　<code>&lt;string.h&gt;</code>里有很多处理字符串的函数。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a><FONT COLOR = Cyan>字符串常量</font></h2><p>　　“hello”像这样子的东西，由双引号括起来的，就叫做字符串常量，或者字符串字面量。他会被编译器变成一个字符数组放在某处，这个数组的长度是 6 ，结尾还有表示结束的 0 。<br>　　两个相邻的字符串常量会被自动连接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，&quot;</span></span><br><span class="line"><span class="string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　<img src="https://www.hualigs.cn/image/606f08bde26b4.jpg"></p><p>　　可以看见，这是两个字符串，中间什么都没有，但是输出的时候自动连接在了一起。对于C语言来说，如果有两个相邻的字符串，中间没有任何其他符号，他会自动把这两个字符串连接起来。<br>　　也可以如此输入，将两端字符串接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，\</span></span><br><span class="line"><span class="string">如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　把第一行末尾表示字符串结束的引号去掉，加一个反斜杠，然后把下面两个 tab 去掉，然后把引号去掉，也会输入像上面那样的结果。</p><p>　　总的来说，C语言的字符串是以字符数组的形态存在的。所以不能用常规的运算符加减乘除对字符串进行运算。可以通过数组的方式来遍历字符串。<br>　　唯一特殊的地方，就是可以通过字符串字面量（双引号的东西）来初始化字符数组。</p><h1 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a><FONT COLOR = SpringGreen>字符串变量</font></h1><p>　　首先是如何定义去定义一个变量，让这个变量去表达字符串？字符串也是数组，所以下面的变量本质上也是字符数组的变量，只不过有特殊的表现形式。：<br>　　<code>char *str = &quot;hello&quot; ;</code>定义一个指针 str，初始化为指向一个字符串常量，该字符串常量里的内容是 hello。<br>　　<code>char word[] = &quot;hello&quot; ;</code>在这个地方定义一个字符数组，里面的内容是 hello<br>　　<code>char line[10] = &quot;hello&quot; ;</code>在这里定义一个字符数组 line，长度为10（10个字节），在这个数组里面放了 hello 。hello 是五个字符，在数组里要占据6个字节的空间（结尾有一个0）。<Font Size = 2>字符串变量写出来之后，编译器会自己在末尾加一个0</font></p><p>　　试图对字符串变量做一点点修改，尝试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here s[0] = %c\n&quot;</span>,s[<span class="number">0</span>]) ;</span><br></pre></td></tr></table></figure><p>　　这段代码尝试把首字母改一下，有的编译器会通过编译；有的编译器不会报错，但是运行时会出错：</p><blockquote><p>Bus error : 10 </p><p>segmentation fault</p></blockquote><p>　　尝试一件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> * s2 = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br></pre></td></tr></table></figure><p>　　此时会发现一件神奇的事情：</p><p><img src="https://www.hualigs.cn/image/606f9f6d014fe.jpg"></p><p>　　s 和 s2 指向的地址是一样的，都是<code>0x1</code>。做了两个字符串变量，用了相同的字面量来初始化，结果他们指向的地址是相同的。然后相比之下，i 的地址非常的大，而 s 的地址非常的小，相距非常远。i s s2 本身是非常正常的，紧紧挨在一起：</p><p><img src="https://ae01.alicdn.com/kf/U292c7faeb71e4800be85aead7eeac31fg.jpg"></p><p>　　i s s2 这些东西在大地址上，称之为本地变量。hello world 在一个很小的地址上，这个很小的地址叫做代码端，而且这个地址一旦定义完毕后，是只读的。如果在代码端的东西进行写入动作，比如<code>s[0] = &#39;B&#39; ;</code>，此时操作系统就会启动自动保护机制，让程序崩溃。<br>　　<FONT COLOR = LimeGreen>所以字符串常量所在的地方，实际上是<code>const char *s = “hello world” ；</code>。但是由于历史的原因，编译器接受不带<code>const</code>的写法，但是试图对 s 所指的字符串做写入，会导致严重的后果。</font></p><p>　　如果想要修改字符串，应该使用数组：<code>char s[] = &quot;hello world&quot; ;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> s2[] = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,&amp;s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,&amp;s2) ;</span><br></pre></td></tr></table></figure><p>　　这两种写法的区别就在于，定义指针的意思是，在代码端有这么个字符串常量，s 指向那里。定义数组的意思是，我这里有一个字符串常量，就在这里：</p><p><img src="https://www.hualigs.cn/image/60704315a20fe.jpg"></p><p>　　<FONT COLOR = LimeGreen>如果合理选择指针定义还是数组定义呢？</font></p><p>　　<code>char s[] = &quot;hello world&quot; ;</code>数组定义：这个字符串在这里，将来会作为本地变量空间自动被回收。<br>　　<code>char *s = &quot;hello world&quot; ;</code>指针定义：这个字符串不知道在哪里。<br>　　用来表达只读文件；<br>　　处理函数的参数。当作为函数参数时，数组 == 指针，反正进去的都是指针。<br>　　动态分配空间。如果字符串的空间是 <code>malloc</code> 得到的，此时字符串只能用指针。</p><p>　　总之，如果要构造一个字符串——数组；如果要处理一个字符串——指针。</p><p>　　有一个文字游戏，<code>char *</code>就一定是字符串吗？显然不是。<br>　　字符串可以表达为<code>char *</code>的形式。但<code>char *</code>不一定是字符串。因为它本意是指向字符的指针，可能指向的是字符的数组（和<code>int *</code>一样）。只有它所指的字符数组有结尾的 0 ，才能说它指的是字符串。</p><h1 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a><FONT COLOR = SpringGreen>字符串输入输出</font></h1><p>　　C语言对字符串的处理，是C语言最大的短板，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *t = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> *s ;</span><br><span class="line">s = t ;</span><br></pre></td></tr></table></figure><p>　　此时启示并没有产生新的字符串，只是让指针 s 指向了 t 所指的字符串，对 s 的任何操作就是对 t 做的。</p><p><img src="https://www.hualigs.cn/image/60705d3504e85.jpg"></p><h2 id="s-输入输出"><a href="#s-输入输出" class="headerlink" title="%s 输入输出"></a><FONT COLOR = Cyan>%s 输入输出</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ; <span class="comment">//定义长度为 8 的字符的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ; <span class="comment">//由于定义了数组，这里不用加 &amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##\n&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　如果输入 hello world。会看到只会输出 hello## ，而后面的 world 不会输出。而且读入hello的时候，没有包含输入的那个空格。如果稍微改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br></pre></td></tr></table></figure><p>　　如果输入<code>hello world</code>，此时会输出<code>hello##world##</code>。可以刻按到，第一个<code>scanf</code>读到的是 hello 不带空格，第二个<code>scanf</code>读到的是 world 也不带空格。因为用户输入的空格在这里是分隔符。同理，如果输入<code>hello 回车 world</code>，此时会输出<code>hello##world##</code>。因为此时的空格、回车，在 %s 眼里都只是分隔符：<br>　　<FONT COLOR = LimeGreen><code>%s</code>读入一个单词（不是语言上的单词，而是读一串字母，到空格、tab、回车为止）</font>。此时的<code>scanf</code>是非常不安全的，因为不知道要读入的内容的长度。</p><h2 id="安全输入"><a href="#安全输入" class="headerlink" title="安全输入"></a><FONT COLOR = Cyan>安全输入</font></h2><p>　　<code>scanf(&quot;%7s&quot;,string)</code>，在 % 和 s 之间的数字表示最多允许读入的字符的数量，这个数字应该要比数组的大小小1（最后一位要放0）。如果就读了那么多个，比如说此时<code>scanf</code>就读到了7个数，那么<code>scanf</code>就此停止，不再依据空格或者回车来判断单词。<br>　　如果输入的数量超过了规定的个数，那么剩下的东西交给下一个<code>scanf</code>来做。<br>　　比如上述程序，定义的字符数组是8个单位，实际上只能写入7个字符，比如输入12345678：程序可能会出现输入错误（不同编译器表现错误的方式不一样）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果是严格的编译器，此时会报错：</p><blockquote><p>about trap: 6</p><p>数组越界导致程序崩溃</p></blockquote><p>　　解决办法，限定输入大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,<span class="built_in">string</span>) ;<span class="comment">//最多只能读前 7 个字符，超过 7 个字符就不要了。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果此时输入<code>12345678</code>。会发现输出结果是<code>1234567##8##</code>。因为第一个<code>scanf</code>取了前七个数，第八个数就自动去满足下一个<code>scanf</code>。此时程序会只读入一次。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>char *</code>的本质是指针</strong></font></p><p>　　误以为，<code>char *</code>就是字符串类型，误以为这样就是定义了一个字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> ;<span class="comment">//本质是定义一个指针变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时这个指针变量没有被初始化，不知道这个指针去指向哪里，如果此时这个指针指向了“只读的地方”，这种不能写入的地方，就会出错。<br>　　此时就是有可能错，有可能正常。</p><p>　　此时应该先让指针指向一个有效的地址。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>空字符串</strong></font></p><p>　　<code>char buffer[100] = &quot;&quot; ;</code>，此时这个字符串是一个空的字符串，<code>buffer[0] == &#39;\0&#39;</code><br>　　如果写成：<code>char buffer[] = &quot;&quot; ;</code>，此时这个数组的长度只有1，<code>buffer[0] == &#39;\0&#39;</code>，除此之外就没有元素了，无法写入任何东西。</p><h1 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a><FONT COLOR = SpringGreen>字符串数组</font></h1><p>　　如果想让一个数组去表示很多字符串，如何表示？</p><h2 id="char-a"><a href="#char-a" class="headerlink" title="char **a"></a><FONT COLOR = Cyan><code>char **a</code></font></h2><p>　　这句话的意思是，a 是一个指针， 这个指针指向另一个指针，那个指针指向一个字符，或者字符串。</p><h2 id="char-a-1"><a href="#char-a-1" class="headerlink" title="char a[][]"></a><FONT COLOR = Cyan><code>char a[][]</code></font></h2><p>　　这句话是定义一个二维数组，并且根据C语言的规则，行数可以由编译器来数，但列数一定要明确给出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　此时编译器会报错：</p><blockquote><p>[Error] array type has incomplete element type</p><p>该数组没有完备的类型。</p></blockquote><p>　　所以要明确给出这个二维数组的列数，比如修改为：<code>char a[][10] ;</code><br>　　<FONT COLOR = LimeGreen>这句话的本质</font>：是定义一个数组，该数组每一个单元都是 <code>char[10]</code>，<code>a[0]</code>是一个<code>char[10]</code>，<code>a[1]</code>也是一个<code>char[10]</code>。所以就会出现下面情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line"><span class="string">&quot;world&quot;</span> ,</span><br><span class="line"><span class="string">&quot;1234567890&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　定义 hello 和 world 的时候没有错，但是在定义 <code>a[2]</code>的时候出错了：</p><blockquote><p>[Warning] initializer-string for array of chars is too long [enabled by default] 这个东西太长了<br>[Warning] (near initialization for ‘a[2]’) [enabled by default]</p></blockquote><h2 id="char-a-2"><a href="#char-a-2" class="headerlink" title="char *a[]"></a><FONT COLOR = Cyan><code>char *a[]</code></font></h2><p>　　这样写才是真正的去定义一个字符串数组，这个数组里面每一个元素都是一个<code>char *</code>：  </p><p><img src="https://gitee.com/XuSiyuan-cn/PhotosOfMyBlog/raw/master/20210420182315.png" alt="图表1"></p><p>　　在<code>switch-case</code>里面，我们曾经尝试过一个月份的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入月份\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :<span class="built_in">printf</span>(<span class="string">&quot;january&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :<span class="built_in">printf</span>(<span class="string">&quot;feb&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :<span class="built_in">printf</span>(<span class="string">&quot;march&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :<span class="built_in">printf</span>(<span class="string">&quot;april&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :<span class="built_in">printf</span>(<span class="string">&quot;may&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :<span class="built_in">printf</span>(<span class="string">&quot;june&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> :<span class="built_in">printf</span>(<span class="string">&quot;july&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> :<span class="built_in">printf</span>(<span class="string">&quot;august&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> :<span class="built_in">printf</span>(<span class="string">&quot;september&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :<span class="built_in">printf</span>(<span class="string">&quot;october&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span> :<span class="built_in">printf</span>(<span class="string">&quot;november&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span> :<span class="built_in">printf</span>(<span class="string">&quot;december&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序非常的简单，也可以用字符串数组来实现这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">10</span>] = &#123; <span class="comment">//定义字符串数组</span></span><br><span class="line"><span class="string">&quot;January&quot;</span> ,</span><br><span class="line"><span class="string">&quot;february&quot;</span> ,</span><br><span class="line"><span class="string">&quot;march&quot;</span> ,</span><br><span class="line"><span class="string">&quot;april&quot;</span> ,</span><br><span class="line"><span class="string">&quot;may&quot;</span> ,</span><br><span class="line"><span class="string">&quot;june&quot;</span> ,</span><br><span class="line"><span class="string">&quot;july&quot;</span> ,</span><br><span class="line"><span class="string">&quot;august&quot;</span> ,</span><br><span class="line"><span class="string">&quot;september&quot;</span> ,</span><br><span class="line"><span class="string">&quot;october&quot;</span> ,</span><br><span class="line"><span class="string">&quot;november&quot;</span> ,</span><br><span class="line"><span class="string">&quot;december&quot;</span> ,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">12</span> ; i++)&#123; <span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( i + <span class="number">1</span> == month )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main的真相"><a href="#main的真相" class="headerlink" title="main的真相"></a><FONT COLOR = Cyan>main的真相</font></h2><p>在比较严格的编译器中，main 的样子是这样的：<code>int main( int argc, char* argv[], char **env ) </code>。 </p><p>　　第一个参数，int型的<code>argc</code>，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，一般默认为1。  </p><p>　　第二个参数，char*型的<code>argv[]</code>，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：<br>    <code>argv[0]</code>指向程序运行的全路径名<br>    <code>argv[1]</code>指向在DOS命令行中执行程序名后的第一个字符串<br>    <code>argv[2]</code>指向执行程序名后的第二个字符串<br>    <code>argv[3]</code>指向执行程序名后的第三个字符串<br>    <code>argv[argc]</code>为NULL </p><p>　　第三个参数，char**型的<code>env</code>，为字符串数组。<code>env[]</code>的每一个元素都包含<code>ENVVAR=value</code>形式的字符串，其中<code>ENVVAR</code>为环境变量，value为其对应的值。平时使用到的比较少。</p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>,argc) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　输出为：</p><blockquote><p>argc = 1 </p><p>argument 0 is F:\Caches\desktop\Mr.Weng.exe</p></blockquote><p>　　如果在调试—命令参数中，输入多个命令参数，比如“a b c d”此时输出值就会变成</p><blockquote><p><code>argc</code> = 5<br>argument 0 is F:\Caches\desktop\Mr.Weng.exe<br>argument 1 is a<br>argument 2 is b<br>argument 3 is c<br>argument 4 is d</p></blockquote><p>　　在Unix里面，这里还有更复杂的东西</p><h1 id="单字符输入输出"><a href="#单字符输入输出" class="headerlink" title="单字符输入输出"></a><FONT COLOR = SpringGreen>单字符输入输出</font></h1><h2 id="函数putchar"><a href="#函数putchar" class="headerlink" title="函数putchar"></a><FONT COLOR = Cyan>函数<code>putchar</code></font></h2><p>　　<code>int putchar(int c) ;</code>把一个字符输出到标准输出上（终端）。但这个函数的输入参数不是<code>char</code>，而是<code>int</code>，但是这个<code>int</code>所能接受的，也仅仅是一个字符而已。这个函数返回类型也是一个<code>int</code>，表示这一次到底写出去几个字符。如果某时候这个输出不能用了，此时会返回一个 <code>EOF（-1） = end of file</code>；这个 <code>EOF</code> 是一个宏，这个宏的值是 -1 。<br>　　一般来说，不用在意<code>putchar</code>的返回。</p><h2 id="函数getchar"><a href="#函数getchar" class="headerlink" title="函数getchar"></a><FONT COLOR = Cyan>函数<code>getchar</code></font></h2><p>　　<code>int getchar(void)</code>它的作用是从终端中读入一个字符，也就是说，如果终端有数据的话不用输入它就可以直接读取了。第一次调用<code>getchar()</code>时，确实需要人工的输入，但是如果输了多个字符，以后的<code>getchar()</code>再执行时就会直接从缓冲区中读取了。<br>　　返回类型也是<code>int</code>,</p><p>　　试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != EOF )&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOF\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>ch = getchar()) != EOF </code>，首先把终端里面的字符用<code>getchar</code>读取出来，然后赋值给 ch ，然后判断这个值是不是 <code>EOF</code> 。如果不是，那么用<code>putchar</code>输出这个值。</p><h1 id="函数STRLEN"><a href="#函数STRLEN" class="headerlink" title="函数STRLEN"></a><FONT COLOR = SpringGreen>函数<code>STRLEN</code></font></h1><h1 id="函数STRCMP"><a href="#函数STRCMP" class="headerlink" title="函数STRCMP"></a><FONT COLOR = SpringGreen>函数<code>STRCMP</code></font></h1><h1 id="函数STRCPY"><a href="#函数STRCPY" class="headerlink" title="函数STRCPY"></a><FONT COLOR = SpringGreen>函数<code>STRCPY</code></font></h1><h1 id="函数STRCAT"><a href="#函数STRCAT" class="headerlink" title="函数STRCAT"></a><FONT COLOR = SpringGreen>函数<code>STRCAT</code></font></h1><h1 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a><FONT COLOR = SpringGreen>字符串搜索函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;字符串&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers II</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/</id>
    <published>2021-03-10T13:59:47.000Z</published>
    <updated>2021-04-08T10:16:01.696Z</updated>
    
    <content type="html"><![CDATA[<p>指针（下）</p><a id="more"></a><h1 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a><FONT COLOR = SpringGreen>指针与const</font></h1><p>　　C 99 only<br>　　指针和 const 在一起就有点小复杂，因为指针本身可以是 const，而指针所指向的变量的值，也可以是 const。</p><h2 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a><FONT COLOR = Cyan>指针是const</font></h2><p>　　此时表示指针一旦得到了某个变量的地址，就不能再指向其他变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = &amp;i; <span class="comment">// 此时 q 是 const，q 的值不能被改变，q 指向 i 这个事实不能被改变，q 不能再指向别的量了。</span></span><br><span class="line">*q = <span class="number">26</span> ; <span class="comment">//访问指针地址上的值，赋值，OK。因为 q 所指向的 i 不是const</span></span><br><span class="line">q++ ; <span class="comment">//改变指针的位置，ERROR</span></span><br></pre></td></tr></table></figure><h2 id="所指的是const"><a href="#所指的是const" class="headerlink" title="所指的是const"></a><FONT COLOR = Cyan>所指的是const</font></h2><p>　　表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;i ;</span><br><span class="line">*p = <span class="number">26</span> ; <span class="comment">// ERROR！因为 (*p)是const，此时不能通过指针去修改那个地址上的量，此时不能通过 *p 去赋值。</span></span><br><span class="line">i = <span class="number">26</span> ; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j ; <span class="comment">//OK，可以修改 p 的指向，让 p 指向 j</span></span><br></pre></td></tr></table></figure><h2 id="const的位置"><a href="#const的位置" class="headerlink" title="const的位置"></a><FONT COLOR = Cyan>const的位置</font></h2><p>　　const 可以一共出现三个位置，但是只有两个功能：要么是指针不可修改，要么是通过指针不可修改。<FONT COLOR = LimeGreen>判断哪个被 const 了的标志，是 const 在 * 的前面还是后面。</font>如果是指针不可修改，则 const 在变量前面，在 * 后面；如果是通过指针不可修改，则 const 在 * 前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p2 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;i ; <span class="comment">//指针不可修改</span></span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a><FONT COLOR = Cyan>转换</font></h2><p>　　总是可以把一个非 const 的值转换成 const </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * x)</span> </span>;<span class="comment">//该函数需要一个“通过指针不可修改”的指针来进行输入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line">f(&amp;a) ; <span class="comment">//此时给函数一个非 cconst 的指针，是没问题的！</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a ;</span><br><span class="line">f(&amp;b) ; <span class="comment">//此时给函数一个 const 的指针，也是没问题的。</span></span><br><span class="line">b = a + <span class="number">1</span> ;<span class="comment">//[Error] assignment of read-only variable &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数原型的意思是，给我一个指针，我保证在函数内部不会通过指针去修改地址上的值。所以至于交给他的参数是不是 const ，其实是无所谓的。</p><p>　　这种做法主要用来，当要传递的参数的类型比地址大的时候（在结构的时候常用），这是常用的手段：既能用比较少的字节数传值给参数，又能避免函数对外面的变量的修改。类似于传数组，数组可以很大，但实际上传给函数的只有一个<code>*int</code>大小的地址，传进去的实际上是指针。</p><h2 id="const数组"><a href="#const数组" class="headerlink" title="const数组"></a><FONT COLOR = Cyan>const数组</font></h2><p>　　在《指针与数组》中，我们可以看出来，数组本质上就是一个 const 的指针，那么再次对数组进行 const会发生什么？比如<code>const int a[] = &#123; 1, 2, 3, 4, 5, 6&#125; ;</code><br>　　数组变量已经是 const 的指针了，这里的const表明数组的每个单元都是 const int。所以必须通过初始化进行赋值。</p><p><FONT COLOR = LimeGreen>　　这种做法可以用来保护数组值：</font></p><p>　　因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值。为了保护数组不被破坏，可以设置函数的参数为const：</p><p>　　<code>int sum(const int a[],int length);</code><br>　　这句话的意思是要求函数接受一个const的数组，那么在函数内部，函数不会对数组有任何修改！</p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a><FONT COLOR = SpringGreen>指针运算</font></h1><h2 id="1-1-2？"><a href="#1-1-2？" class="headerlink" title="1 + 1 = 2？"></a><FONT COLOR = Cyan>1 + 1 = 2？</font></h2><p> 　　对指针变量进行自加一的话，会是什么呢？用代码尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc = ac ;<span class="comment">//&amp;可加可不加</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc  =%p\n&quot;</span>,pc) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc+1=%p\n&quot;</span>,pc+<span class="number">1</span>) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi  =%p\n&quot;</span>,pi) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi+1=%p\n&quot;</span>,pi+<span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>　　输出结果为：</p><blockquote><p>pc    = 0x22FE30<br>pc+1= 0x22FE31  此时结果相差1</p><p>pi     = 0x22FE00<br>pi+1= 0x22FE04  此时结果相差4 </p></blockquote><p>　　为什么呢？因为<code>sizeof(char) = 1 , sizeof(int) = 4</code>。所以对于指针变量 + 1，不是让地址 + 1，而是让指针 + 1个 sizeof 。 对于 char 类型，如果第一个地址在 30 上，那执行指针 +1后，地址在31上。对于 int 类型，如果第一个地址在00上，因为一个 int 型占据 4 个字节，所以执行指针 +1后，地址在 04 上。</p><p><img src="https://www.hualigs.cn/image/606d14a05b596.jpg"></p><p>　　对指针变量 + 1，本质是让指针所指向的地址往后面移动一格。这一点在数组里面体现的尤为明显：<br>　　对于 char 类型数组<code>*pc -&gt; ac[0] ; *(pc+1) -&gt; ac[1]</code>。<br>　　对于 int 类型数组<code>*pi -&gt; ai[0] ; *(pi+1) -&gt; ai[1]</code>。<br>　　对于任何类型的数组，<code>*p -&gt; a[0] ; *(p+n) -&gt; a[n]</code>。<br>　　<FONT COLOR = LimeGreen>给一个指针加1表示要让指针指向下一个变量</font>，如果指针不是指向一片连续分配的空间，如数组，则这种运算是没有意义的。</p><h2 id="指针的加减"><a href="#指针的加减" class="headerlink" title="指针的加减"></a><FONT COLOR = Cyan>指针的加减</font></h2><p>　　加减可以对指针做。<br>　　指针 + n：指针往后移 n 个<code>sizeof</code>单元<br>　　指针 - n：指针往前移 n 个<code>sizeof</code>单元<br>　　两个指针相减：类似于坐标相减，指的是他们中间有多少个<code>sizeof</code>单元。用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc1 = &amp;ac[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">char</span> *pc7 = &amp;ac[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1  =%p\n&quot;</span>,pc1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc7  =%p\n&quot;</span>,pc7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1 - pc7 = %d\n&quot;</span>,pc1-pc7) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;ai[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">int</span> *pi7 = &amp;ai[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1  =%p\n&quot;</span>,pi1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi7  =%p\n&quot;</span>,pi7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1 - pi7 = %d\n&quot;</span>,pi1-pi7) ; </span><br></pre></td></tr></table></figure><p>　　运行结果如下：</p><blockquote><p>pc1           = 0x22FE21<br>pc7           = 0x22FE27<br>pc1 - pc7 = -6</p><p>pi1           = 0x22FDF4<br>pi7           = 0x22FE0C<br>pi1 - pi7 = -6<br>在16进制下，这两个地址相差24，刚好是 6 个sizeof(int)</p></blockquote><p>　　所以两个指针相减的时候，给的不是地址差，给的是地址之间相差多少个单元，中间还能放几个这样类型的元素。</p><h2 id="p"><a href="#p" class="headerlink" title="*p++"></a><FONT COLOR = Cyan>*p++</font></h2><p>　　　<code>*</code>的优先级是非常高的，但是没有++高。所以是先进行后缀的自加1，再取<code>*</code> ，<FONT COLOR = LimeGreen>p++ 的结果，是p+1以前的结果</font>。所以这句话的操作是：<FONT COLOR = LimeGreen>取出指针 p 所指的数据，完事后顺便把 p 移到下一个位置去。</font><br>　　该操作常用于数组类的连续空间操作。比如遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;<span class="comment">//在数组末尾放一个不可能的多余数据 </span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;b[<span class="number">0</span>] ;<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>( ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果使用指针挪位的方法来遍历，则需要在遍历的数组后面加一个不可能的多余数据，达成循环终止的条件。其中指针的初始化可以用以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p  ;</span><br><span class="line"><span class="keyword">for</span>( p = b ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在上一讲提过，数组就是特殊的指针，对于初始化，以下几种方式都是可以的：<br>　　<code>int *p = b ;</code> 或者 <code>int *p ; p = b ;</code> 或者 <code>int *p = &amp;b[0] ;</code> </p><p>　　在某些CPU上，<code>*p++</code>可以直接被翻译成一条汇编指令。</p><h2 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a><FONT COLOR = Cyan>指针比较</font></h2><p>　　<code>&lt; , &lt;= , == , &gt; , &gt;= , !=</code>都可以对指针做，用来比较他们在内存中的地址。数组中的单元地址是线性递增的。</p><h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a><FONT COLOR = Cyan>0地址</font></h2><p>　　  现代的操作系统都是多进程的操作系统，对于每一个进程，操作系统会给他一个虚拟的地址空间，所以所有的程序在运行的时候都以为自己有从0开始的一片连续的地址空间。<FONT COLOR = LimeGreen>所以任何程序都有0地址，但是0地址通常是个不能随便碰的地址，所以我们的指针不应该具有0值。</font><br>　　所以可以用这个特性来做一些特殊的事情：<br>　　用 0 地址表示返回的指针是无效的，指针没有被真正的初始化（先初始化为0）……<br>　　在C语言里，有的编译器不愿意用 0 来表示 0 地址。所以使用 <code>NULL</code>为预定定义的符号，表示 0 地址。</p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a><FONT COLOR = Cyan>指针类型</font></h2><p>　　无论指向什么类型，所有的指针的大小都是一样的，他们都是地址。但是指向不同类型的指针是不能直接互相赋值的，比如上面的<code>int *pi</code>和<code>char *pc</code>。这是为了避免用错指针。<br>　　如果赋值了会怎么样？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %p\n&quot;</span>,pi) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *pc = ac ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br><span class="line"></span><br><span class="line">pi = pc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br></pre></td></tr></table></figure><p>　　此时会有一个 warning：</p><blockquote><p>[Warning] initialization from incompatible pointer type [enabled by default]</p><p>指针类型不匹配</p></blockquote><p>　　如果忽视掉 warning 强行运行的话，会发现，还是成功地把 pi 所指向的地址，赋给了 pc。所以此时 pc 和 pi 指向同一个地址。这个和数据类型不一样，比如 double 和 int。强行把 double 的值放给 int 的话，因为 double 占据空间比 int 大，所以强行放进去会出现问题。但不管是什么类型的指针，他们本质上都是地址，而且大小都相同，东西是放的进去的，这样做有问题的原因如下：</p><p><img src="https://www.hualigs.cn/image/606d53bb62f4d.jpg"></p><p> 　　如果让<code>pi = pc</code>，然后操作 *pi ，比如让<code>*pi = 0</code>，本来 pi 是指向 4 个字节，那么就会让 30、31、32、33四个位置上全部为0。 所以编译器报 warning 的原因，是为了防止用错指针。</p><h2 id="void"><a href="#void" class="headerlink" title="void *"></a><FONT COLOR = Cyan>void *</font></h2><p>　　如果想要强制让不同类型的指针去赋值，就需要强制类型转换：<br>　　<code>void *</code> 表示不知道指向什么东西的指针，先定义这个指针指向“void”，这片空间里是什么类型，是 int 还是 double，先不用去知道，不用去管。这种指针可以直接去访问内存地址，或者某个内存地址所代表的外部设备等。计算时与<code>char *</code>相同（但不相通）<br>　　指针也可以转换类型。<code>int *p = &amp;i ; void *q = (void *)p</code>这里就是把一个 int 型的指针 p ，强制转换为了 void 型，并且交给了 <code>void *p</code>。此时实际上这并没有改变 p 所指的变量的类型，p 是指向 i 的，i 也任然是 int 。只不过是通过 q 去看 i 的时候，眼光变了；通过 p 去看 i ，i 是 int ；通过 q 去看 i ，i 是 void 。</p><p>　　让后人用不同的眼光通过 p 来看它所指的变量 i，我不再当你是 int 了，我认为你就是个 void。</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><FONT COLOR = SpringGreen>动态内存分配</font></h1><p>　　如何用变量来定义数组？除了<code>const int number ； int a[number]</code>这种方法外，还有没有？利用 malloc 函数对指针进行动态内存分配，比如：<code>int *a = (int*)malloc(n*sizeof(int));</code></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><FONT COLOR = Cyan>malloc</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>属于标准库函数</strong></font></p><p>　　malloc 全称是 memory allocation ，是 C 标准库里面的函数，所以使用 malloc 前要加一个头文件<code>#include&lt;stdlib.h&gt;</code></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>描述</strong></font></p><p>　　该函数分配他想要的一个内存空间，并返回一个指向它的指针。<FONT COLOR = LimeGreen>向 malloc 申请的空间大小是以字节为单位的</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>声明</strong></font></p><p>　　下面是 malloc() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>参数</strong></font></p><p>　　size – 内存块的大小，以字节为单位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>返回值</strong></font></p><p>　　该函数返回一个指针 void * ，指向已分配大小的内存。<FONT COLOR = LimeGreen>返回的指针需要类型转换为自己需要的类型</font>比如：<code>(int *)malloc( n * sizeof(int) )</code>。<br>　　如果空间用完了，则请求分配空间失败，则返回 0，或者NULL。</p><p>　　用“变量”定义数组，方法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"><span class="keyword">int</span> a[number] ;</span><br></pre></td></tr></table></figure><p>　　用“变量”定义数组，方法2，malloc 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br></pre></td></tr></table></figure><p>　　malloc 需要的参数不是有多少个 int，不是这个数组有多少个单元，而是这个数组需要多少空间（字节），所以在括号里面需要乘以一个<code>sizeof(int)</code>。此外，malloc 他返回的是一个 void* ，而 a 是一个 int *。所以这里需要使用一下类型强制转换，前面需要一个<code>( int *)</code><br>　　指针和数组的本质是相同的，所以接下来，这个指针 a ，就可以完全当做数组来使用：</p><p>　　<Font Size = 2 color = DeepSkyBlue><strong>特别注意的是，虽然指针可以当做数组来用，但他还是指针，所以对于这种东西是不能用 <code>sizeof</code>的，如果去用 <code>sizeof</code>，得到的是指针的长度（占据多少个字节）。所以对于这种“数组”的 length 也不能使用<code>sizeof(a)/sizeof(a[0])</code>，应该直接使用 number。</strong></font></p><p>　　尝试对这种数组做点操作：遍历输入，遍历逆序输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = number - <span class="number">1</span> ; i &gt; <span class="number">-1</span> ; i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(a) ;<span class="comment">//释放内存很重要</span></span><br></pre></td></tr></table></figure><p>　　可以利用一下 malloc 看一下自己的系统能给多大的空间，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>( ( p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>)) )&#123;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配了%d00MB的空间\n&quot;</span>,count) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>1、定义指针的时候，定义的是 void 类指针，这里也可以定义 int 型，如果定义 int 型，那么后面使用 malloc 的时候前面就要加一句<code>int *</code>。<br>　　2、<code> p = malloc(100*1024*1024)</code>这句话有三个作用：<br>　　第一，利用 malloc 去申请空间，并且把字节换算成了MB，1 mb = 1024 kb = 1024 * 1024 b。所以这里没申请一次相当于申请了 100 mb。<br>　　第二，把函数返回值交给指针 p 。<br>　　第三，这句话也是循环继续的条件，如果 malloc 申请空间成功，则成功赋值；如果 malloc 申请空间失败，由 malloc 的操作手册可知，malloc 会返回 0，或者 NULL。所以这句话也可以当做循环的条件，当申请空间失败的时候，就是表达式为 0 的时候，就是循环终止的时候。</font></p><h2 id="free"><a href="#free" class="headerlink" title="free( )"></a><FONT COLOR = Cyan>free( )</font></h2><p>　　malloc 函数是向系统申请内存空间，而<code>free()</code>就是把申请来的空间还给“系统”。<br>　　申请过来的空间最终都应该归还，只能还申请来的空间的首地址，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>) ;<span class="comment">//要个100MB的空间</span></span><br><span class="line">p++ ;<span class="comment">//把指针的地址往下面去放一位</span></span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时程序会报错，有可能不报错，但程序会崩溃，也不会运行到“here”那里。如果是严格的编译器此时会编译出错：</p><blockquote><p>error: Access violation in freeing invalid address （提示非法访问）</p><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　如果 free 的指针不是 malloc 来的，也会报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时指针 p 的空间不是 malloc 来的，dev C++ 没有报错，但是程序运行时会崩溃，不会运行到 “here” 那里。如果是严格的编译器，会报错：</p><blockquote><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　由这两个错误可以看出，系统可以记住，哪些内存是 malloc 来的，必须要严格记住 malloc 的地址，对这个地址 free 才有效。<code>free(NULL)</code>也是可以执行的，就是什么都不做。</p><p>　　如果申请了内存空间，不去 free ，长时间运行的话就会使内存逐渐下降。对操作系统来说，当程序结束后，曾经使用过的内存会全部清除干净。<br>　　如果 free 过了再去 free，也会出错。</p><hr><p>指针的主要用途：</p><p>需要传入较大的数据时，用指针作为参数，比如数组。<br>传入数组后对数组做操作。<br>函数返回不止一个结果，需要用指针带出来<br>需要用函数来修改不止一个变量<br>动态申请的内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（下）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/</id>
    <published>2021-03-09T13:59:47.000Z</published>
    <updated>2021-04-06T13:47:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>指针（上）</p><a id="more"></a><h1 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a><FONT COLOR = SpringGreen>取地址运算</font></h1><h2 id="运算符-amp"><a href="#运算符-amp" class="headerlink" title="运算符&amp;"></a><FONT COLOR = Cyan>运算符&amp;</font></h2><p>　　在C里面，&amp;也是运算符，为取地址运算，最典型的就是<code>scanf(&quot;%d&quot;,&amp;i)</code>里面的 &amp;<br>　　<FONT COLOR = LimeGreen>&amp; ：作为运算符，是获得变量的地址，它的操作数必须是变量！</font>C语言里的变量是放在内存里面的，每一个变量都会在内存中占据一定的位置和大小。比如 int 是四个字节，这个变量有大小，内存需要有一个地方放置，放置变量这个地方就是地址。&amp; 就是把这个变量的地址拿出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　地址用16进制表达起来比较方便，所以在输出 %x 前面加一个<code>0x</code>，其中 %x 表示以十六进制数形式输出整数，对于地址的表达，用16进制比较方便。把 i 的地址取出来，用<code>printf</code>输出。此时程序给出的结果是：<code>0x22fe4c</code>。<br>　　有的编译器可能会给一个warning：</p><blockquote><p>warning: format specifies type ‘unsigned int’ but the argument has type ‘ int * ‘</p></blockquote><p>　　这个warning的意思是，如果你想要<code>printf</code>给你输出一个地址，输出的时候不应该用 %x ，而是使用 %p。：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen><code>%p</code>的意思是把这个值作为一个地址来输出，输出的时候自己会在前面加<code>0x</code>，是以16进制的方式输出这个地址， 如果输出数据不够8位数，则左边补零。  </font>此时输出值是：<code>000000000022fe4c</code>。<Font Size = 2>这里我补了16位数，有可能是因为的我的编译器为64位</font></p><p>　　这两个地址实际上表达的是一个位置，看起来像是一个数，尝试能不能对这个数进行操作？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时编译器会有一个 warning:</p><blockquote><p>[Warning] assignment makes integer from pointer without a cast [enabled by default]</p></blockquote><p>　　这个 warning 是需要类型转换的意思，需要从指针型转换为 int 型，若忽视 warning 强行输出，则结果为：<code>000000000022fe48</code>。解决掉这个 warning ，只需要一次强行类型转换即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;<span class="comment">//我的电脑在编译的时候这里任然有类型转换的 warning，初步认为是编译器的问题，换成更加严格的在线编译器之后通过！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时两条代码的编译结果都是<code>0x22fe48</code>。<br>　　注：<Font Size = 2>特别的，关于 &amp;i 和 int 类型的东西，在32位架构下，两者大小是相同的，但是在64位架构下，两者并不相同。</font>所以关于这段代码的编译结果，对于 32 位系统，编译结果相同；对于64位系统，编译结果可能不同，但是后 8 位是一模一样的，比如结果可能是<code>0x5c961d28</code>和<code>0x7fff5c961d28</code>。还有一个例子更好地说明在 64 位架构下，<code>int</code>和<code>&amp;i</code>的区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;i));</span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>0x22fe48、000000000x22fe48、4、8</code>。说明在64位架构下，int 的大小是4，而 &amp;i 的大小是8。在32位架构下，int 的大小是4 ，&amp;i 的大小也是4。</p><p>　　综上：一个变量，它的地址的大小是否与 int 相同取决于编译器，取决于系统是64位架构还是32位架构。地址和整数并不永远是相同的，所以对于地址的输出，我们采用 %p 的方式。</p><h2 id="不能取的地址"><a href="#不能取的地址" class="headerlink" title="不能取的地址"></a><FONT COLOR = Cyan>不能取的地址</font></h2><p>　　<FONT COLOR = LimeGreen>&amp; 不能对没有地址的东西取地址</font>。如果右边不是一个变量，则不能取地址！<br>　　<code>&amp;(a+b)</code>、<code>&amp;(a++)</code>、<code>&amp;(++a)</code>此时右边是一个表达式，所以不能取地址</p><blockquote><p>[Error] lvalue required as unary ‘&amp;’ operand</p><p>error: cannot take the address of an rvalue of type ‘int’</p></blockquote><h2 id="常见的地址"><a href="#常见的地址" class="headerlink" title="常见的地址"></a><FONT COLOR = Cyan>常见的地址</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>变量的地址</strong></font></p><p>　　上面已经阐述过，不再赘述</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的变量的地址</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br></pre></td></tr></table></figure><p>　　输出结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>可以看出来，定义的相邻的变量，地址也是相邻的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;k) ;</span><br></pre></td></tr></table></figure><p>　　输出的结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>、<code>0x22FE44</code>说明在内存里面，他们都是紧挨着的。<br>　　其中也可以看出来，最先定义的 i 占据比较位置比较大，然后是后面定义的 j 然后是后面定义的 k 。</p><p><img src="https://www.hualigs.cn/image/606930106c1cd.jpg"></p><p>　　在内存中，最先定义的 i 在最高的地方，然后是 j  最低的地方是最后定义的 k 。C 的内存模型会将本地变量分配在“堆栈 stack”，在堆栈中，分配变量是“自顶向下”分配的。先写的变量地址最高，后写的变量地址变低，依次紧挨着排列。他们的地址相差一个<code>sizeof(int)</code>。<font color = red>为什么这里相差一个<code>sizeof(int)</code>而不是一个<code>sizeof(&amp;i)</code>?</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>&amp;</code>的结果和 <code>sizeof</code></strong></font></p><p>　　前面已经讨论过，不同编译器和不同架构下，<code>sizeof</code>的结果不一样，32位占据4，64位占据8。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组单元的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的数组单元的地址</strong></font></p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;<span class="comment">//数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">0</span>]) ;<span class="comment">//数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">1</span>] );<span class="comment">//相邻的数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//试图直接把a交给printf输出地址</span></span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>22FE20、22FE20、22FE24、22FE20</code>。相邻数组单元的地址相差永远是 4 。说明他们是紧挨着的。</p><p><img src="https://www.hualigs.cn/image/606b06c98d387.jpg"></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a><FONT COLOR = SpringGreen>指针</font></h1><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a><FONT COLOR = Cyan>指针变量</font></h2><p>　　如果能够将取得的变量的地址，然后将这个地址作为一个值传递给一个函数，那么这个函数能否通过这个地址访问到这个变量呢？比如函数<code>scanf(&quot;%d&quot;,&amp;i)</code>，他到底是如何工作的？<br>　　在使用<code>scanf</code>的时候，会传给这个函数一个变量的地址，然后<code>scanf</code>拿我们传给它的这个地址，放到我们指定的变量中去。这些功能是如何实现的？<code>scanf</code>的原型应该是怎样的？如果我们需要一个参数能够保存别的变量的地址，如何表达能够保存地址的变量？</p><p>　　从分析<code>scanf</code>的功能可以看出来，<code>scanf</code>一定有办法，可以接受用户输入变量的地址。有前面尝试可以知道，不能把地址交给整数，因为 int 和 地址 长度不一样，在不同编译情况下，他们可能不相等。所以在C语言里，用指针来保存地址。</p><p>　　在C语言里，指针就是保存地址的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i ;<span class="comment">//*p就表示p是一个指针变量，用来保存 i 的地址</span></span><br><span class="line"><span class="keyword">int</span>* p,q ;<span class="comment">//*作用在p上，无法作用在q上。</span></span><br><span class="line"><span class="keyword">int</span> *p,q ;<span class="comment">//这句话和上面那句是一样的。</span></span><br></pre></td></tr></table></figure><p>　　<code>int* p = &amp;i</code> p 是指针，指向 i 的地址，如果说“ p 指向 i ”意思就是指针变量 p 里面保存的是 i 的地址。</p><p><FONT COLOR = LimeGreen>　　指针变量的值就是内存的地址。普通变量的值是实际的值，指针变量的值是具有实际值的变量的地址。</font>指针变量里面不会储存实际的值，只会放别的变量的地址。</p><h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a><FONT COLOR = Cyan>函数与指针</font></h2><p>　　如果把指针作为函数的参数会怎么样？就像<code>scanf(&quot;%d&quot;,&amp;i)</code>：<br>　　<code>void f(int *p)</code>此时表示函数 f 需要一个指针，如果要调用这个函数，就需要交给他一个地址：<code>int i = 0 ； f(&amp;i)</code>。此时不能交给 f 这个变量本身，必须要用 &amp; 取得 i 的地址交给 f ，函数才会生效。比如如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ; <span class="comment">//直接输出 i 的地址</span></span><br><span class="line">f(&amp;i) ;<span class="comment">//把 i 的地址交给 f 函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;  <span class="comment">//让函数输出 p 的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　可以看到，两个值是一样的。此时就可以说 p 是一个指针，指向 i 。此时在 f 函数里面，可以得到 main 函数里面变量的地址了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line">f(&amp;i) ;</span><br><span class="line">g(i) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; k = %d\n&quot;</span>,k) ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>　　此时 f 拿到了 i 的地址，但是 g 只拿到了 i 的值。g 这个函数里面拿到的值和 main 函数是没有关系的，g 函数无法访问 main 函数。但是 f 是可以通过指针来访问 main 函数。</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a><FONT COLOR = Cyan>访问地址</font></h2><p>　　有了指针之后，有了地址之后，如何访问这个地址上的变量呢？<FONT COLOR = LimeGreen>使用 * ，用 * 来访问指针所指向的那个地址上的变量。此时 * 是一个单目运算符，用来访问指针的值所表示的低智商的变量。</font>可以做右值，也可以做左值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i ;<span class="comment">// p 指向 i</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;<span class="comment">//查看 i 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;<span class="comment">//查看 p 的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>,&amp;p) ;<span class="comment">//查看 p 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;<span class="comment">//*p 作为一个整体，表示的是 i 的值，所以是一个整数，此时 *p 作为右值</span></span><br><span class="line">*p =  <span class="number">1</span> ;<span class="comment">//此时 *p作为左值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; i = %d\n&quot;</span>,i) ; <span class="comment">//查看 i 的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　最后的结果是：</p><blockquote><p>&amp;i = 0x100010<br> p = 0x100010<br>&amp;p = 0x100018<br>*p = 0<br>i = 1</p></blockquote><p>　　1、把 i 的地址交给 p 后，p 的值就是 i 的地址，而 p 的地址和 i 的地址不相同<br>　　2、<code>printf(&quot;*p = %d\n&quot;,*p)</code>这一步相当于是<code>int k = *p ; printf(&quot;k = %d\n&quot;,k </code>，所以也就证明了，*p 读取了 i 的值。说明 *p 可以作为右值，读取地址上的值，成功。<br>　　3、<code>*p =  1</code>就是修改地址上的值，最后可以看到<code> i = 1</code>，所以修改地址上的值也成功。</p><p>　　综上，<code>*p</code>可以访问地址上的值，也可以修改地址上的值。 </p><h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a><FONT COLOR = Cyan>左值</font></h2><p>　　在做赋值运算的时候，赋值号左边可以不是变量，左边可以是值。这种可以被赋值的值，称之为左值：<br>　　<code>a[0] = 2 ；</code>这里左边不是变量，是值，是表达式计算的结果，[ ] 是特殊的运算符，用来取数组的下标。<br>　　<code>*p = 2 ；</code>这里左边也不是变量，而是指向变量的值，是表达式计算的结果， 但是他也能赋值。<br>　　所以严格意义上来说，赋值号左边不一定是变量，所以称之为左值；赋值号右边称之为右值。</p><h2 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp; 和 *"></a><FONT COLOR = Cyan>&amp; 和 *</font></h2><p>　　在指针中，有两个运算符，他们是互为相反作用的：<br>　　&amp;：取变量的地址。*：访问地址上的变量。可以说他们是互为逆运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*a = &amp;A</span><br><span class="line">*&amp;A → *(&amp;A) → *(A的地址) → 得到那个地址上的值 → A的值      </span><br><span class="line">&amp;*a → &amp;(*a) → &amp;(地址上的值，就是A) →得到A的地址→ A的地址就是a</span><br></pre></td></tr></table></figure><h2 id="scanf的”不合理”"><a href="#scanf的”不合理”" class="headerlink" title="scanf的”不合理”"></a><FONT COLOR = Cyan><code>scanf</code>的”不合理”</font></h2><p>　　为什么像这种代码编译器不会报错：<code>int i ;scanf(&quot;%d&quot;,i);</code>。此时 i 是整数，而在32位架构下，整数和地址是一样大的，所以当这么写的时候，把一个整数传进去，或者把一个地址传进去，他们长的是一样的， <code>scanf</code>无法辨别其区别。<br>　　所以此时编译不一定会报错，但是运行一定会出错。运行一定出错是因为<code>scanf</code>把他读入的量写在了内存其他地方，写在了不该写的地方。</p><h1 id="指针应用"><a href="#指针应用" class="headerlink" title="指针应用"></a><FONT COLOR = SpringGreen>指针应用</font></h1><h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a><FONT COLOR = Cyan>返回多个值</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景1：函数需要返回多个值！</font>函数是只能返回一个值的，如果需要返回多个值，那就只能通过指针返回。传入的参数的地址，然后利用这个地址把函数里面变量的值带出来。<Font Size = 2>（这句话感觉很绕，但仔细体会体会，能明白的）</font>传入的参数，实际上是需要返回值的地址以及变量。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Exchange</strong></font></h3><p>　　当时在《函数》那章的时候，曾经有一个问题，就是是否可以编写一个函数，用来交换 a 和 b 的值。当时的答案是不行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为 main 和函数是参数和值的关系，main 提供参数给函数，而函数把值传给 main。所以当需要返回多个值的时候，单纯靠函数是做不到的，但是有了指针就不一样了！因为在函数可以利用指针来访问 main 里面变量的地址，从而达到交换变量值的目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line">exchange( &amp;a , &amp;b ) ; <span class="comment">//对于指针变量的函数，调用的时候注意，传的是地址，而不是值！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>&#123;<span class="comment">//此时函数拿到 a b 的地址</span></span><br><span class="line"><span class="keyword">int</span> t = *pb ;<span class="comment">//访问 b 地址上的值，并且把该值传给 t</span></span><br><span class="line">*pb = *pa ;<span class="comment">//访问 a 地址上的值，并且把该值传给 b</span></span><br><span class="line">*pa = t ;<span class="comment">//把 t 的值传给 a 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Max-和-Min"><a href="#Max-和-Min" class="headerlink" title="Max 和 Min"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Max 和 Min</strong></font></h3><p>　　编写一个函数，可以判断一个数组里面的最大值和最小值。此时显然函数需要返回两个结果，所以必须要用指针来完成这件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//这四个参数一个都不能少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> , <span class="number">56</span> , <span class="number">74</span> , <span class="number">12</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );<span class="comment">// &amp;min 和 &amp;max 是从 main 传进函数的参数，他们的作用是把函数里面的值带出来！！！！！！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d , min = %d&quot;</span>,max ,min) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//对于传进来的地址，定义函数的时候得是指针变量</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;<span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q 1：能不能不要 length ，直接在函数里面使用<code>sizeof(a)/sizeof(a[0])</code>？<br>　　不能，如果调用函数的时候，参数没有<code>sizeof(a)/sizeof(a[0])</code>，那么函数里面是访问不了 a 的。</p><blockquote><p>[Error] ‘a’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>Q 2：传值的时候能不能不传数组 a？<br>　　不能，原因同上！只要是函数要用的参数，调用函数的时候都要传值给函数，不然函数无法访问 main 的变量。错误也同上。</p><p>Q 3：调用函数的时候，数组写成了 a[ ] 怎么办？<code>minmax( a[] , &amp;min , &amp;max ,length );</code><br>　　[ ] 实际上是一个运算符，在数组里面索引，所以此时<code>a[]</code>是空的，因为没有值，此时会发生奇奇怪怪的错误：</p><blockquote><p>[Error] expected expression before ‘]’ token</p></blockquote><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a><FONT COLOR = Cyan>返回结果</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景2：函数返回运算的状态，结果通过指针返回</font>。函数在运行的过程中，可能会遇到一些特殊的状态，此时函数无法得到正确的结果。<br>　　此时常用的套路就是让函数返回特殊的，不属于有效范围内的值，来表示出错；在文件操作中，常见的就是让函数返回 -1 或 0 来表示函数出错。<br>　　但是如果函数返回的任何数值都是有效的可能结果时，此时无法通过返回值来判断函数是否运行正确，此时就只能让函数的结果，和需要用的结果分开返回。<FONT COLOR = LimeGreen>一般函数的状态用 return 来返回，而实际的值通过指针来返回。</font></p><h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>除法函数</strong></font></h3><p>　　对于<code>divide()</code>函数，如果除法成功，函数返回值为 1 ；如果除法失败，函数返回值为 0 。此时函数需要两个东西，一个是除法是否成功，一个是除法的值；所以函数的状态用函数的 return 来返回，除法的值用指针带出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a , b , result ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( divide( a , b , &amp;result) == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;除数不能为0\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span></span>&#123;<span class="comment">//需要函数返回值的时候，就不能用void </span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span>( B == <span class="number">0</span> )&#123;<span class="comment">//如果除数是0，此时指针里是没有任何有用的结果</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*Result = A / B ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当运算可能会出错的时候，C只能通过指针来解决。在后续的语言（C++、Java）采用了异常机制来解决这个问题</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p>　　<FONT COLOR = LimeGreen>定义了指针变量，还没有指向任何变量，就开始使用指针。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">12</span> ;</span><br><span class="line">*p = <span class="number">12</span> ;</span><br></pre></td></tr></table></figure><p>　　这种做法编译器不会报错，因为 *p 在编译器里就是可以看做一个整数。</p><p>　　所有的本地变量在没有初始化的时候，是不会有默认的初始值的，这个本地变量所在的地址上有什么，他就是什么。对于指针，如果没有指向任何变量的时候就开始使用它，比如这段代码的<code>*p = 12 </code>；他可能指向一片莫名其妙的地方，然后在那片奇怪的地方写入12。如果那块地方是个不能写的地方，此时会报错；如果那块地方可以写，此时不会报错。但这个指针变量也是没意义的，因为没有储存地址！</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a><FONT COLOR = SpringGreen>指针与数组</font></h1><p>　　如果把一个普通的变量传入函数，函数接收到的是值；如果把一个指针传入函数，函数接受到的也是值，只不过这个值是一个地址；给函数传入数组的话，到底传入函数的数组成了什么？函数接收到的是什么？ 为什么上面的 Max 和Min   程序里面，不能在函数里使用 <code>sizeof(a)</code>？用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在 main 里数组的大小 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在minmax函数里数组的大小</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　结果分别是40、8。 这个 8 刚好和一个指针的大小是相同的！如果对于比较严格的编译器，会出现一个 warning：</p><blockquote><p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [ ] ‘.</p></blockquote><p>　　这个警告的意思是，对于函数的数组的 <code>sizeof </code> 返回的是‘int *’的大小，而不是数组的大小。说明在函数里面的数组，实际上是一个指针！用以下代码验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在 main 里数组 a 的地址 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在函数里数组 a 的地址 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时可以发现，在 main 和函数里面，a 的地址是相同的。这说明在函数里面数组a和 main 里面的数组a是一个东西。再用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; <span class="comment">//查看a[0]的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里会发现，a[0] 的数值变了。<FONT COLOR = LimeGreen>一般来说，函数里一个变量的值变化了，是不会改变 main 里面这个变量的值。除非是指针。从这里就可以看出来，数组的本质就是指针</font>。<br>　　所以在函数定义的时候，如果是数组变量一定得写<code>a[ ]</code>，方括号里不能加数；函数里不能使用<code>sizeof</code>。因为他的本质就是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//原型里，把数组改成指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//定义里，把数组写成指针</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　编译成功！运行正确！</p><p>　　所以我们可以说<FONT COLOR = LimeGreen>函数参数表中的数组实际上就是指针</font>。<code>sizeof(a) == sizeof(*int)</code>；但是可以用数组的运算符<code>[]</code>进行运算。<br>　　<FONT COLOR = LimeGreen>所以以下四种函数原型是等价的：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar , <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * , <span class="keyword">int</span> )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[] , <span class="keyword">int</span> n )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">( <span class="keyword">int</span> [] ,<span class="keyword">int</span>)</span> </span>;</span><br></pre></td></tr></table></figure><p>　　 <FONT COLOR = LimeGreen>数组变量是特殊的指针</font><br>　　1、数组变量本身就表达地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *p = a ;<span class="comment">//无需使用 &amp; 取地址，就能够把地址交给指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//无需使用 &amp; 取地址，就可以吧地址交给 printf 输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;<span class="comment">//两者结果相同</span></span><br></pre></td></tr></table></figure><p>　　但是数组的单元表达的是变量，需要用 &amp; 取地址。</p><p>　　2、数组的地址和第一个元素的地址相同<code>a == &amp;a[0]</code></p><p>　　3、<code>[]</code>使运算符，可以对数组做，也可以对指针做。 p [ 0 ] 相当于 *p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[0] = %d\n&quot;</span>,p[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;</span><br></pre></td></tr></table></figure><p>　　4、* 运算符可以对指针做，也可以对数组做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span> , <span class="number">2</span> &#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>,*a) ;</span><br></pre></td></tr></table></figure><p>　　此时<code>*a</code>的值是<code>a[0]</code>的值。和指针一样，可以对这个值进行读写操作。</p><p>　　5、数组变量是 const 的指针，所以不能被赋值。<br>　　前面学过，像这种数组给数组赋值，是不被允许的<code>int b[] = a []</code>。数组变量间是不允许相互赋值的。因为<code>int b[] </code>相当于是<code>int * const b ;</code>相当于这个 b 是一个常数，是不可以被改变的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（上）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 08 Array</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/</id>
    <published>2021-03-08T13:59:47.000Z</published>
    <updated>2021-04-03T07:48:20.734Z</updated>
    
    <content type="html"><![CDATA[<p>数组</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><FONT COLOR = SpringGreen>数组</font></h1><p>　　数据可以存放在变量里，每一个变量有一个名字，有一个类型，还有它的生存空间。如果我们需要保存一些相同类型、相似含义、相同生存空间的数据，我们可以用数组来保存这些数据，而不是用很多个独立的变量。数组是长度固定的数据结构，用来存放指定的类型的数据。一个数组里可以有很多个数据，所有的数据的类型都是相同的。</p><h2 id="初见数组"><a href="#初见数组" class="headerlink" title="初见数组"></a><FONT COLOR = Cyan>初见数组</font></h2><p>　　如何写一个程序计算用户输入的数字的平均数？并且输出所有大于平均数的数？——即如何写一个程序用来记录用户输入的所有的数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , sum = <span class="number">0</span> , i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> average ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="comment">//定义一个数组，大小是100，每个单元都是int，所以这个数组最多可以放100个int </span></span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="comment">//i是递增的，于是恰好可以用i来作为指示位置的参数 </span></span><br><span class="line"><span class="comment">//以这种形式对数组中的每个元素赋值</span></span><br><span class="line">sum = sum + x ;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> )&#123; <span class="comment">//这里i大于0就说嘛至少读入了一个数 </span></span><br><span class="line">average = <span class="number">1.0</span> * sum / i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, average ) ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; j++)&#123; </span><br><span class="line"><span class="comment">//这个 for 循环目的是为了遍历数组number里面所有的元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,number[j]) ;</span><br><span class="line"><span class="comment">//输出number里所有的元素</span></span><br><span class="line"><span class="keyword">if</span>( number[j] &gt; average )&#123;</span><br><span class="line"><span class="comment">//使用数组中的元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,number[j]) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以用一下代码查看一下，程序中，数组具体的运行情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> , x ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; <span class="number">5</span> ; i++ ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i) ;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= i ; j++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,number[j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其运行结果如下：</p><p><img src="https://www.hualigs.cn/image/6052e612d5a00.jpg"></p><p>　　可以看出来，第一轮在数组0的位置上放了1，第二轮在数组1的位置上放了2……</p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a><FONT COLOR = Cyan>定义数组</font></h2><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的定义</strong></font>：<br>　　<FONT COLOR = LimeGreen>&lt; 类型 &gt; 变量名称 [ 元素数量 ]</font>。这个类型并不是指的数组的类型，严格意义来说而是数组中每一个单元的类型。<br>　　<code>int grades [100];</code>这个数组里面有100个元素，每个元素都是 int 型。<br>　　<code>double weight [20]</code> 这个数组里面有20个元素，每个元素都是double型。<br>　　元素的数量一定要是整数。<br>　　<Font Size = 2>C99以前，元素的数量一定要是常数。但是C99以后，元素的数量也可以是变量。</font></p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的宏观感受</strong></font>：类似一种容器，有三个特点：<br>　　1、所有的元素都有相同的数据类型<br>　　2、一旦创建，就不能改变大小<br>　　3、数组中的元素在内存中是连续依次排序的。</p><p>　　以 <code>int a [10]</code>为例：<br>　　这是一个 int 型的数组，这个数组里有10个元素，每个单元都是一个 int 型的变量，分别是：a[0]、a[1],……,a[9]。<br>　　数组的每个单元就是数组类型的一个变量，使用数组时，放在 [ ] 中的数字叫做下标或索引，下标是从 0 开始计数。所以最大的下标是数组大小减一。<br>　　数组的元素可以出现在赋值的左边或者右边。<code>a[2] = a[1] + 6 ;</code>是可以这么写的。赋值左边称为左值，在指针里面会知道，左值和右值是有区别的。</p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>有效的下标范围</strong></font><br>　　编译器和运行环境都不会去检查数组下标<Font Size = 2>（也可以叫做索引）</font>是否越界，无论是对数组单元做读还是写。<br>　　一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃：</p><blockquote><p>segmentation fault</p><p>array index _ is past the end of the array</p></blockquote><p>　　也有可能运气好，没造成严重地后果，程序运行正常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　比如这种情况，<code>a[10] = 0 ;</code>实际上已经出错了，但是编译器并没有报错，实际上，这段代码把 0 写到了不该写的地方，带来的后果是，程序实际上没有运行。比如有以下手段来检验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main here\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A here\n&quot;</span>) ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B here\n&quot;</span>) ; <span class="comment">//这种技巧常常用来判断程序运行状况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　P.S. 不同的编译器要求不一定相同，但这样的写法是不安全的。</p><p>　　所以一个好的习惯，<FONT COLOR = LimeGreen>就是保证程序只去使用有效的下标值：0 ~ 数组大小-1。</font></p><p>　　所以上面那个计算平均数的程序是有一定风险的，因为一旦用户输入的数字超过100个，程序就报错了。解决办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字的数量： \n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count) ;</span><br><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">int</span> number[count] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　让用户先想好要输入数字的数量，然后定义数组的大小，这种写法，是C99 Only。</p><p>　　<Font Size = 2><code>int a [0] ;</code>这种东西可以存在，但是毫无用处，因为此时数组的大小是空的，即便是 a [0] 也越界了。</font></p><h2 id="例子：统计个数"><a href="#例子：统计个数" class="headerlink" title="例子：统计个数"></a><FONT COLOR = Cyan>例子：统计个数</font></h2><p>　　写一个程序，输入数量不确定的 [ 0 , 9 ] 范围内的整数，统计每一种数字出现的次数，输入 -1 表示结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ; <span class="comment">//c99 only ，为了避免程序出现magic number</span></span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> count[ number ] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">count[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个for循环的目的是定义10个变量，且每个变量的初始值都是0 </span></span><br><span class="line"><span class="comment">//这个循环是使用数组的时候常用的，初始化数组循环 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">9</span> )&#123;</span><br><span class="line">count[ x ]++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个循环的目的是计数，仔细思考下</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span> , i , count[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个循环就是对数组 count 的遍历 </span></span><br></pre></td></tr></table></figure><h1 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a><FONT COLOR = SpringGreen>数组运算</font></h1><p>　　如何去写一个   搜索的程序？先看看以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组集成初始化"><a href="#数组集成初始化" class="headerlink" title="数组集成初始化"></a><FONT COLOR = Cyan>数组集成初始化</font></h2><p>　　<code>int a[] = &#123;2,4,6,7,1,3,5,9,11,13,23,14,32&#125; ;</code>这段代码是<FONT COLOR = LimeGreen>数组的集成初始化</font>。定义数组时有两种办法，第一种是不去初始化它，第二种方法就是这样，直接用大括号给出数组的所有元素的初始值——给他一组数字，用这组数字去初始化数组。<br>　　使用这种办法的时候，不用给出数组的具体大小，[ ] 里没有数字，让编译器来数数。<br>　　如果强行去给数组的大小，而且后面的值不匹配怎么办？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>] = &#123;<span class="number">2</span>&#125;;<span class="comment">//这里就是强行定义数组大小，且大于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">13</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种情况下，输出值如下：</p><p><img src="https://www.hualigs.cn/image/6061a78f25d41.jpg"></p><p>　　可以说，这种情况下，其实就是给<code>a[0]</code>赋值，其余没有赋值，编译器则用0来补充。所以以下两种写法是相同的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　反过来呢？如果定义的数组长度小于集成初始化给的长度呢？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;<span class="comment">//强行规定数组大小，且小于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]<br>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]</p></blockquote><p>　　此时会有如上警告。</p><p>　　还有一个小问题，如果对于大小为3个的数组，在遍历输出的时候，如果不小心输出的长度大于3会如何？看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061c5e0007d3.jpg"></p><p>　　可以看出来，前三位是正常的，分别是<code>a[0] a[1] a[2]</code>但是后面的数，就是程序不存在的东西，实际上是内存原有的东西。</p><h2 id="集成初始化定位"><a href="#集成初始化定位" class="headerlink" title="集成初始化定位"></a><FONT COLOR = Cyan>集成初始化定位</font></h2><p>　　C99 only！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>　　用<code>[n]</code>在初始化数据中给出定位。<br>　　没有定位的数据接在前面的位置后面，比如这个定义，实际上<code>a[3] = 6</code>。<br>　　其他位置的值补零。<br>　　也可以不给出数组大小，让编译器自己算，比如这个数组，如果不给出长度为10，那么编译器会认为他的长度为3。<br>　　特别适合初始数据稀疏的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061d836cd5cb.jpg"></p><h2 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a><FONT COLOR = Cyan>数组的大小</font></h2><p>　　<code>sizeof</code>是一个运算符，可以告诉我们这个量有多大。对数组使用<code>sizeof</code>可以给出整个数组所占据的内容大小，单位是字节。可以求出这个数组占据多少个字节。<br>　　比如上条程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时就会输出40、4。说明在改数组中，一个元素占据4个字节，一共占据40个字节，所以一共有十个元素。</p><p><FONT COLOR = LimeGreen>　　所以对于任何一个数组，可以使用<code>sizeof(a)/sizeof(a[0])</code>来计算数组中的元素。</font>这样的代码，最大的好处是：一旦修改数组中初始的数据，不需要修改遍历的代码，比如把遍历的代码改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++ )&#123;<span class="comment">//这样就安全多了，也不会出现 magic number</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a><FONT COLOR = Cyan>数组的赋值</font></h2><p>　　已知一个数组<code>a[]</code>，能不能用这个数组直接给另外一个数组赋值？比如说;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125; ;<span class="comment">//最末尾这个逗号可有可无</span></span><br><span class="line"><span class="keyword">int</span> b[] = a ; <span class="comment">//无效的初始值设定项</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时会报错：</p><blockquote><p>[Error] invalid initializer</p></blockquote><p>　　<FONT COLOR = LimeGreen>数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历</font></p><p>　　以下就是目前接触的遍历数组的情况。<br>　　其中<code>length = sizeof(a)/sizeof(a[0])</code></p><p>　　把数组 a 的值全都赋值给数组 b ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line">b[i] = a[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　把数组 a 全部赋值为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有和关键字相同的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++  )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有大于平均数的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; average)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　遍历数组，并且将他们全部输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,i,a[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>对于数组的遍历，通常是使用 for 循环，让循环变量 i 从 0 到（&lt;） 数组的长度</font>，这样循环体内的 i 正好是数组最大的有效下标（length -1）。<br>　　<FONT COLOR = LimeGreen>常见错误</font>：<br>　　循环结束条件是 &lt;= 数组长度。此时刚好会多输出一个量，此时程序会超过数组的长度（非常危险）。<br>　　离开循环后，继续用 i 的值来做数组元素的下标。此时 i 的值是 length 也就是说已经超过数组范围了。</p><h2 id="搜索程序解读"><a href="#搜索程序解读" class="headerlink" title="搜索程序解读"></a><FONT COLOR = Cyan>搜索程序解读</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>主程序</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　其中，主程序会调用 search 这个函数，并且返回一个值给 loc 。如果返回值是 -1 ，则说明输入的数字不在数组中；否则，则输出该数字在改数组的第几位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>search 函数</strong></font>：</p><p>　　找出 key 在数组 a 中的位置，其中该函数有三个参数：<br>　　key ：要寻找的数字。a 要寻找的数组。length 数组a 的长度。<br>　　ret 是函数最后的返回值，如果找到，则让 ret 返回为 key 在 a 的位置。如果找不到就返回 -1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;<span class="comment">//对数组遍历，每次遍历是拿出一个单元，判断和 key 是否相等。</span></span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>当函数的参数是数组的时候</font>，比如这个 search 函数，往往必须再用另一个参数传入数组的大小，此时不太好用 <code>sizeof(a)/sizeof(a[0])</code>。<br>　　此时不能在 [ ] 中直接给出数组的大小，也不能利用 sizeof 计算数组的元素个数。<br>　　所以这里引入 length 。</p><h1 id="例子：素数"><a href="#例子：素数" class="headerlink" title="例子：素数"></a><FONT COLOR = SpringGreen>例子：素数</font></h1><p>　　先复习一下，之前用 if - else 判断素数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> x , i ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; i &lt; x ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPrime)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数&quot;</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序有个缺陷，对于 n 可能要循环 n - 1 遍，如果 n 非常大，则程序效率不高。</p><h2 id="算法改进1"><a href="#算法改进1" class="headerlink" title="算法改进1"></a><FONT COLOR = Cyan>算法改进1</font></h2><p>　　首先判断 x 是否为偶数，如果是偶数，立马认为其不是素数。去掉偶数后，让 i 从 3 到 x - 1 ，每次都加 2。具体操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt; x ; i = i + <span class="number">2</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由于几乎去掉了所有的偶数，所以和原来相比，我们只需要走一半的循环即可。</p><h2 id="算法改进2"><a href="#算法改进2" class="headerlink" title="算法改进2"></a><FONT COLOR = Cyan>算法改进2</font></h2><p>　　不需要到 x - 1，到 <code>sqrt(X)</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt;= <span class="built_in">sqrt</span>(x) ; i = i + <span class="number">2</span> )&#123;<span class="comment">//这里老师写成了小于，我认为应该是小于等于。</span></span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为什么只要算到根号x即可？因为整除嘛。这样大大提高了效率。</p><h2 id="算法改进3：构造素数数组"><a href="#算法改进3：构造素数数组" class="headerlink" title="算法改进3：构造素数数组"></a><FONT COLOR = Cyan>算法改进3：构造素数数组</font></h2><p>　　只要拿比 x 小的素数除一除就可以了（分解质因数原理），所以要先构造一张已经有了的素数的表。</p><p>　　比如先要构造一张前100个素数的表（数组），main 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>其中这里的<code>prime[count++] = i ;</code>是一个套路。</font>对于这个大小为100的数组，[ 0 ] 上已经放了 2 。所以接下来就是让 [ 1 ] 这个位置上放置接下来的一个素数。<code>prime[count++] = i ;</code>实际上是，现在自加 1 之前的位置上，放置 i ，然后再对count 自加 1 。所以，如果这里 count 的初始值是 0 ，那么就应该是<code>++count</code>。</p><p>　　其中，判断素数的函数 <code>isPrime()</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123; <span class="comment">//这个for循环实际上是对数组 knownPrimes[] 的遍历</span></span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　该函数需要三个参数，分别是 x 、已经判断过的素数、素数排行（是第几个素数）。该函数里面的 i 和 main 函数里面的 i 是不同的，这个 i 是独立的。<br>　　<code>x</code>，就是我们需要判断的数，这个函数就是用来判断 x 是不是素数。<br>　　<code>knownPrimes[ ]</code> ，可以看到，第二个参数是一个数组，这个数组就是 main 函数里的 prime 。<FONT COLOR = RED>这里有个问题，为什么 main 里面调用函数的时候第二个参数给的是 prime ，这里的 prime 值是多少？</font>总而言之，这个数组应该是一个素数集合。<br>　　<code>numberofKnowPrimes</code>就是目前已经有了多少个素数。注意 for 里面的，是小于号。</p><p>　　为了更好地了解这两段代码的运行模式，可以加一段调试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d \t count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　为了美观，可以用同样调试的技巧，在<code>while</code>前面加一段表头的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">10</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line">&#123;<span class="comment">//为了美观，输出几个表头与后面的调试代码对齐</span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 和外面的 i 无关 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;  </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后遍历并且输出 <code>prime[ ] </code>这个数组，并且为了美观，每个数都输出一个制表符，然后每五个数换一次行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123; <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后构造前100个素数的数组程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;<span class="comment">//从3开始判断这个数是不是素数。</span></span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//这里不能自作聪明写 i = i + 2 。有很多素数相差只有2。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但这里只是构造了一个素数数组，具体如何用这个数组来做素数判断？我以后再研究？初步思路是：<br>　　1、判断这个数是否和数组里面的数相同，如果有相同的，直接判断为素数。<br>　　2、否则的话，让这个数和数组里的数做除法，如果能除尽，直接判断为合数。<br>　　3、否则的话，<Font Size = 2><em>这种情况就比较复杂，这个素数数组里最后两个数是 523 和 541。也就是说，比 <code>523 * 541 </code>大的数，这个数组就判断不了了。</em></font>我目前想着，int 型最大的数是 (2^31)-1，是十位数，所以让 number = 10000，就基本在 int 不爆炸的情况下，用第二步算完了。</p><p>　　<font color = red> 但是这样子，每次都要循环遍历检验一次数组，这样真的会加快效率吗？存疑</font></p><h2 id="算法改进4：构造素数表"><a href="#算法改进4：构造素数表" class="headerlink" title="算法改进4：构造素数表"></a><FONT COLOR = Cyan>算法改进4：构造素数表</font></h2><p>　　欲构造 n 以内的素数表：<br>　　1、令 x 为2<br>　　2、将 2x、3x、4x 直到 ax &lt; n 全部标记为非素数。<br>　　3、令x为下一个没有被标记为非素数的数，重复2；直到所有的数全部尝试完毕。</p><p>　　这个算法，相当于从 2 开始，一直到 n，一个个把素数的倍数给划掉。最后留在表里面的，全是素数。伪代码如下：</p><p>　　欲构造 n 以内（不含）的素数表：<br>　　1、开辟<code>prime[n]</code>，初始化所有元素为1，<code>prime[x]</code>为1就表示 x 是素数。<br>　　2、令 x = 2<br>　　3、如果 x 是素数，则对于<code>( i = 2 ; x * i &lt; n ; i++ )</code>令<code>prime[x * i] = 0</code><br>　　4、令 x++ ，如果 x &lt; n ，重复3，否则结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历初始化</span></span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历输出，这样会使得0，1一定会输出，可以让i从2开始。</span></span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　翁老师还改进了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[x] )&#123;<span class="comment">//这里加一个 if 之后，比如当 x 是15的时候，程序就不会进入这个if了，因为早在 x 是3的时候，prime[15]就被赋值为0.</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><FONT COLOR = SpringGreen>二维数组</font></h1><p>　　<code>int a[10]</code>这个数组只有一个下标，可以看做是一维数组，线性的。<br>　　<code>int a[3][5]</code>就是二维数组，对于二维数组，可以理解为 a 是一个3行5列的矩阵：</p><table><thead><tr><th><code>a[0][0]</code></th><th><code>a[0][1]</code></th><th><code>a[0][2]</code></th><th><code>a[0][3]</code></th><th><code>a[0][4]</code></th></tr></thead><tbody><tr><td><code>a[1][0]</code></td><td><code>a[1][1]</code></td><td><code>a[1][2]</code></td><td><code>a[1][3]</code></td><td><code>a[1][4]</code></td></tr><tr><td><code>a[2][0]</code></td><td><code>a[2][1]</code></td><td><code>a[2][2]</code></td><td><code>a[2][3]</code></td><td><code>a[2][4]</code></td></tr></tbody></table><p><Font Size = 2>　　如果不考虑数组在计算机内存中是如何排列的，那么把它看成5行3列也没关系小，但是不建议这么做。倾向于第一个下标为行数，第二个下标为列数</font></p><h2 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a><FONT COLOR = Cyan>二维数组遍历</font></h2><p>　　用两个 for 循环就可以遍历二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">5</span> ; j++ )&#123;</span><br><span class="line">a[i][j] = i*j ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　以<code>int a[i][j]</code>为例，该数组里所有的元素都是 int 型。特别注意的是，<code>a[i,j]</code>在C语言里表示<code>a[j]</code>，因为此时逗号是运算符。</p><h2 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a><FONT COLOR = Cyan>二维数组的初始化</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>集成初始化</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">5</span>] =  &#123;<span class="comment">//列数是不能省略的！！</span></span><br><span class="line">&#123; <span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>&#125; ,</span><br><span class="line">&#123; <span class="number">2</span> , <span class="number">3</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span>&#125; ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　列数是必须给出的，行数可以让编译器来数。<br>　　每行一个 ｛ ｝ ，用逗号分离<br>　　最后的逗号可以存在（古老的传统）<br>　　如果省略，表示补零，和一维数组相同。<br>　　也可以用初始化定位，和一维数组相同（ C99 Only）</p><h2 id="三连棋"><a href="#三连棋" class="headerlink" title="三连棋"></a><FONT COLOR = Cyan>三连棋</font></h2><p>　　读入一个 3 × 3 的矩阵，矩阵中的数字 1 则表示这个位置上有一个 X，数字 0 则表示位置上有一个 O。只要有一方的棋子连成一条线了，则获胜。程序然后判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符 X or O，或输出无人获胜。</p><p>　　读入矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> numOfX , numOfY ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，2：Y赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>　　检查行是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查列是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　显然这两个循环长得差不多，那么问题来了，能不能用一个两重循环来检查行和列？把他们合并起来？</p><p>　　检查对角线：<br>　　主对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查副对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;<span class="comment">//这是一个表示副对角线的套路，记忆一下。</span></span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后的程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，0：O赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;X赢了&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( result == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;O赢了&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不分胜负&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>chapter 07 Function</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/</id>
    <published>2021-03-07T13:59:47.000Z</published>
    <updated>2021-04-02T09:01:38.438Z</updated>
    
    <content type="html"><![CDATA[<p>函数</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><FONT COLOR = SpringGreen>函数</font></h1><p>　　不要从数学的意义来理解函数，要从 function（功能）的意义来理解函数。</p><h2 id="初见函数"><a href="#初见函数" class="headerlink" title="初见函数"></a><FONT COLOR = Cyan>初见函数</font></h2><h3 id="求素数和"><a href="#求素数和" class="headerlink" title="求素数和"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>求素数和</strong></font></h3><p>　　求 m ~ n 之间所有素数的和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i - <span class="number">1</span> ; k++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( isPrime == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br></pre></td></tr></table></figure><p>　　对于里面判断素数的循环，功能是非常单一的——就是判断循环。对于这种功能单一的代码，可以做成一个函数（function），那样既可以让程序变得简洁，也提高了可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;<span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( Ret(i) == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　### <Font Color = DarkCyan size = 4 Face = 仿宋><strong>多次求和</strong></font></p><p>　　求出1<del>10、20</del>30、35~45 的三个和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i , sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">20</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">30</span>; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">35</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">45</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br></pre></td></tr></table></figure><p>　　这三段是几乎一模一样的。<br>　　Code Duplication，“代码复制”是程序质量不良的表现：<br>　　1、如果将来要做修改维护的时候，会使得维护的地方变得很多。<br>　　2、使代码特别冗长。</p><p>　　对于这种需要重复使用到的“功能function”，不如做成求和函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的定义与使用"><a href="#函数的定义与使用" class="headerlink" title="函数的定义与使用"></a><FONT COLOR = Cyan>函数的定义与使用</font></h2><p>　　函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>定义函数</strong></font></h3><p>　　以下列代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　<FONT COLOR = LimeGreen>　<code>void sum(int begin , int end )</code>称为函数头；<br>　　<code>void</code>是返回类型（空类型，不返回结果）；<br>　　<code>sum</code>是函数名；<br>　　<code>(int begin , int end )</code>是参数表。<br>　　<br>大括号里面的称为函数体，大括号是必须的。</font></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>调用函数</strong></font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">sum(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　调用函数时，要首先给出：函数名（参数值）。该函数有多少个参数，就需要传递多少个参数，而且要传递正确的数据类型、给出正确的数量和顺序。这些值会被按照顺序依次用来初始化函数中的参数。<br>　　如果调用的参数少了，或者小括号里没有逗号，就会出现以下错误：</p><blockquote><p>error: too few arguments to function</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数名后的 ( ) 非常重要</font>，这个小括号起到了表示函数调用的重要作用，即使没有参数也需要有小括号。<br>　　比如说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers() ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是如果没有这个小括号，就会报错（有的编译器不会报错，但此时也不会调用函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning: expression result unused cheer ;</p></blockquote><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a><FONT COLOR = Cyan>Return</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数用来判断素数，最后会返回一个值：isPrime。这个返回的结果，最后会返回给调用它的地方。这个函数 Ret 的类型是 int ，所以有一个返回的int的结果。</p><p>　　return 表示停止函数的执行，并且返回一个函数值。return 有两种写法：<br>　　<code>return ;</code>直接结束<br>　　<code>return 表达式</code>把这个值交给函数调用它的地方</p><p>　　比如上段代码，函数运行之后，return 会使得 isPrime 有一个值。后面程序在调用函数的时候，就会把这个值作为运算结果。<Font Size = 2>（讲起来有点绕，后面再看看其他资料）</font></p><p>　　一个函数里可以出现多个return。但是如果一个函数里去使用多个return的话，那么这个函数就会有多个出口，不符合<FONT COLOR = LimeGreen>单一出口原则</font>。</p><p>　　函数的返回值可以赋值给变量、可以再传递给函数、甚至可以丢掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;</span><br><span class="line">c = MAX( a , b ) ;</span><br><span class="line">c = MAX( c , <span class="number">23</span> ) ;</span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;</span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上述所有写法都是对的，其中所有 MAX 的值，都是函数最后 return 得到的值。<br>　　其中这个<code>MAX(12,34)</code>做了一次调用，但是没有把值交给任何人，就是把函数运行的结果丢掉了。——有时候调用函数的目的并不是要看函数返回的结果，而是要函数的副作用（比如输出一个什么东西）</p><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a><FONT COLOR = Cyan>无返回值的函数</font></h2><p>　　如果我们需要一个没有返回值的函数，以以下代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>void 函数名(参数表)</font></p><p>　　不能使用带值得 return ，如果使用了，会出现以下错误：</p><blockquote><p>[Warning] ‘return’ with a value, in function returning void [enabled by default]</p></blockquote><p>　　可以没有 return ，到函数最后一行，函数自动结束。</p><p>　　调用的时候不能做返回值得赋值。此时 SUM 不会返回值，比如以下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时的<code>SUM(1,10) </code>就是不需要SUM的值，只需要他的副作用——输出一个和。此时SUM的值如下：</p><p><img src="https://www.hualigs.cn/image/605e9f1b1cb95.jpg"></p><h1 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a><FONT COLOR = SpringGreen>函数的参数和变量</font></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><FONT COLOR = Cyan>函数原型</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C的编译器是自上而下分析代码。所以要把函数的定义像这样写在程序的最开始。<br>　　在看到<code>SUM(1,10) ;</code>的时候，程序需要知道 <code>SUM( )</code> 的样子——<FONT COLOR = LimeGreen>函数的名字、函数需要几个参数，每个参数的类型、返回什么类型</font>。这样编译器才能检查程序对 <code>SUM()</code>的调用是否正确。</p><p>　　如果不这样会发生什么？把要调用的函数放在 <code>main()</code>的下面试一试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ; <span class="comment">//int SUM(int,int)</span></span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><blockquote><p>[Warning] conflicting types for ‘SUM’ [enabled by default]<br>[Note] previous implicit declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>特别注意，不同编译器对C语言的要求都不同，有的严格有的宽松，具体报错的信息不一定相同</font><br>　　conflicting types 意思是类型冲突。</p><p>　　对于C99以前的标准，程序读到<code>SUM(1,10) ;</code>时，发现此时没有定义 <code>SUM()</code>这个函数，程序会去猜 <code>SUM()</code>的情况，会去假设<code>SUM()</code>里的类型是两个int，并且会返回一个 int 值：<code>int SUM(int,int)</code>。这种做法叫做隐式声明，C99以后就不用了。</p><blockquote><p>warning: implicit declaration of function ‘SUM’ is invalid in C99</p></blockquote><p>　　那么当程序读到<code>SUM(1,10) ;</code>时候，程序会猜这个函数是<code>int SUM(int,int)</code>，但后面对函数定义的时候，又定义其为<code>void SUM(int, int)</code>，所以后面程序会 warning： conflicting types </p><p>　　在实际的工程项目中，很多时候都希望第一眼能看到<code>main()</code>的样子，而不是一大堆函数的定义。所以就有了<FONT COLOR = LimeGreen>原型声明——把函数头+分号放到程序最开头。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>; <span class="comment">//原型声明，在 main 函数之前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义，在main函数以后</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　程序看到原型声明后，会先记住函数的样子，然后遇到<code>main</code>里面的函数调用的时候，会先采取原型声明里面的定义，最后读到下面函数定义的时候，再一次检查函数调用是否正确。</p><p>　　如果原型和定义冲突怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　和上面隐式声明一样，出现类型冲突的错误：</p><blockquote><p>[Error] conflicting types for ‘SUM’<br>[Note] previous declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数原型</font><br>　　<code>函数头；</code>函数头以分号结尾就构成了函数原型<br>　　函数原型的目的是告诉编译器这个函数长什么样：<br>　　名称；<br>　　参数数量以及参数类型<br>　　返回类型</p><p>　　函数原型的主要目的是告诉编译器函数长什么样，所以对待具体参数的变量名不做检查和要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>; <span class="comment">//原型声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时原型声明可以写成：<br>　　<code>void SUM(int, int) ; </code><br>　　<code>void SUM(int a , int b ) ;</code><br>　　都可以，没有关系，因为编译器在原型声明检查的时候不会检查参数名称，只会检查函数名称、返回类型、参数数量和类型。但为了阅读起来方便，最好是直接把函数头复制过来加分号会好一点，因为要方便人去阅读和修改。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><FONT COLOR = Cyan>参数传递</font></h2><p>　　如果函数有参数，调用函数时必须传递给它数量、类型正确的值。可以传递给函数的值是表达式的结果，包括：字面量、变量、函数的返回值、计算结果。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;<span class="comment">//字面量</span></span><br><span class="line">c = MAX( a , b ) ;<span class="comment">//变量</span></span><br><span class="line">c = MAX( c+<span class="number">3</span> , <span class="number">23</span> ) ;<span class="comment">//计算的结果</span></span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;<span class="comment">//函数返回值</span></span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是因为C语言对于表达式的定义非常宽，单一的字面量、单一的变量、进行计算的结果、赋值全部都是表达式。函数调用本身、函数调用结果，全部都是表达式。</p><h3 id="类型不匹配"><a href="#类型不匹配" class="headerlink" title="类型不匹配"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>类型不匹配</strong></font></h3><p>　　如果参数传递类型不匹配会怎么样？<br>　　<FONT COLOR = LimeGreen>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞。<br>　　编译器总是悄悄替你把类型转换好，但是这可能不是你所期望的。<br>　　后续的语言，C++/Java 在这方面要求非常严格。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序就是非常简单的函数定义以及函数调用，如果调用时参数传递类型不匹配怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1.1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时程序实际上是出错了，因为<code>cheer()</code>函数要求参数是整型，而调用时的参数是浮点数。此时编译会有两种情况：<br>　　情况1：编译器给出warning，编译器在执行过程中，故意把double型的1.1转化为了整型的1。</p><blockquote><p>warning: implicit conversion from ‘double’ to ‘int’ change value form 1.1 to 1</p><p>此处出现了一个隐含的转化，从 double 转化为 int。</p></blockquote><p>　　情况2：编译器连 warning 都没有，直接通过了编译。</p><p>　　对于绝大多数编译器，以下写法不会出现 warning。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> f = <span class="number">1.1</span> ;</span><br><span class="line">cheer(f) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C语言做不到类型匹配的自动检查！！！</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>传值</strong></font></h3><p>　　能不能写一个交换 a b 值的函数？试试看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样的代码可以交换 a 和 b 的值吗？答案是不能的。可以用调试查看一下各个变量的值：</p><p><a href="https://imgtu.com/i/6z6nET"><img src="https://z3.ax1x.com/2021/03/27/6z6nET.png" alt="6z6nET.png"></a></p><p>　　这里可以看出来，当程序运行到 <code>exchange()</code>函数里面的时候，变量 a ，b 的状态都是</p><blockquote><p>Not found in current context。</p><p>在当前上下文找不到</p></blockquote><p>　　也就是说，当程序运行到  <code>exchange()</code>函数里面的时候，变量 a b 都是不存在的。同理，当程序运行到<code>main()</code>函数里面的时候，x y t 也都是不存在的：</p><p><a href="https://imgtu.com/i/6z67q0"><img src="https://z3.ax1x.com/2021/03/27/6z67q0.png" alt="6z67q0.png"></a></p><p>　　尝试一下查看<code>exchange( a , b ) ;</code>的值，看清楚这一步到底是干什么的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exchange(a,b)=%d\n&quot;</span>,exchange(a,b)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a ;</span><br><span class="line">a = b ;</span><br><span class="line">b = t ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/605f014f01a82.jpg"></p><p>　　可以看出来，<code>exchange( a , b ) ;</code>实际上是进入exchange函数，然后返回 exchange 的值，对于第一段代码<code>void exchange( int a , int b ) ; </code>此时 exchange 不返回值，对于第二段代码<code>int exchange( int a , int b ) ; </code>返回的就是 return 的值。<br>　　除此之外，<code>exchange( a , b ) ;</code>并不能实际上改变 a 和 b 的值。<br>　　所以这样的函数不能交换 a 和 b 的值。</p><p>　　每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。<br><FONT COLOR = LimeGreen>　　函数和<code>main</code>的关系是参数和值得关系，C语言在调用函数的时候，永远只能传值给函数。</font></p><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a><FONT COLOR = Cyan>本地变量</font></h2><p>　　Local variables 也翻译成局部变量。<br>　　函数的每一次运行就会产生一个独立的变量空间，在这个空间中的变量是函数的这次运行所独有的，称作本地变量。<br>　　所有定义在函数内部的变量就是本地变量。<br>　　参数也是本地变量。</p><h3 id="生存期和作用域"><a href="#生存期和作用域" class="headerlink" title="生存期和作用域"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>生存期和作用域</strong></font></h3><p>　　生存期：什么时候变量开始出现，到什么时候变量消亡。<br>　　作用域：在代码的什么范围内可以访问这个变量（这个变量可以起作用的领域）<br>　　对于本地变量，这两个答案是统一的：<FONT COLOR = LimeGreen>大括号——块</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当程序运行在<code>main()</code>里面时，t x y 是不存在的：<code>Not found in current context</code>。当程序运行在<code>exchange()</code>里面时，a b也是不存在的，<code>Not found in current context</code>。</p><h3 id="本地变量规则"><a href="#本地变量规则" class="headerlink" title="本地变量规则"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>本地变量规则</strong></font></h3><p>　　<FONT COLOR = LimeGreen>本地变量是定义在块（一组大括号）内的</font><br>　　这个块可以使函数的块，也可以是语句的块，甚至可以随便拉一对大括号来定义变量。比如下面的 if 语句块里面对 i 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;<span class="comment">//这个i生存期和作用域就在这个块里面，离开这个块，i就不存在了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个 i 的生存期和作用域都在 if 控制的这个块里面，所以每次进入<code>main()</code>，这个 i 都不一定存在（因为 if 不一定执行）。如果此时想要在 if 块外面使用 i ，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//在i的生存期和作用域之外使用它</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　报错：</p><blockquote><p>[Error] ‘i’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>　　<FONT COLOR = LimeGreen>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中变量就消失了</font></p><p>　　对上面程序进行调试就可以知道，进入 if 的时候 i 是存在的，出大括号后 i 就是<code>Notfound in current context</code>。</p><p>　　<FONT COLOR = LimeGreen>在块外面定义的变量在块里面任然有效。</font>里面定义的变量出来就不存在了。</p><p>　　同样对上面程序进行调试，在 if 所控制的块里面， a 和 b 都是可以读到的。</p><p>　　<FONT COLOR = LimeGreen>若块里面定义了和外面同名的变量，则里面的变量会掩盖外面的变量。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其中输出的值为：</p><p><a href="https://imgtu.com/i/cSKYCQ"><img src="https://z3.ax1x.com/2021/03/27/cSKYCQ.png" alt="cSKYCQ.png"></a></p><p>　　可以看出来在 if 控制的块里面，a 的值覆盖了外面 a 的值。但是出来之后，里面的 a 不存在了，a 又回到了初始的状态。</p><p>　　不是所有的编程语言都是这么干的！！！</p><p>　　<FONT COLOR = LimeGreen>不能再一个块里面定义同名的变量</font></p><blockquote><p>[Error] redefinition of ‘a’<br>[Note] previous definition of ‘a’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>本地变量不会被默认初始化</font></p><p>　　<FONT COLOR = LimeGreen>参数在进入函数的时候会被初始化</font></p><h2 id="函数庶事"><a href="#函数庶事" class="headerlink" title="函数庶事"></a><FONT COLOR = Cyan>函数庶事</font></h2><h3 id="没有参数时"><a href="#没有参数时" class="headerlink" title="没有参数时"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>没有参数时</strong></font></h3><p>　　<code>void f(void)</code>还是<code>void f()</code><br>　　<code>void f(void)</code>明确告诉编译器，f 函数不接受任何参数。在传统的C中，<code>void f()</code>表示 f 函数的参数未知，并不表示没有参数；现在编译器如何处理呢？尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;<span class="comment">//到这一行的时候，编译器猜测exchange需要两个int型参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时编译通过。编译器理解为，遇到函数原型时，知道有一个函数 <code>void exchange</code>，但不太确定他的参数个数和参数类型。于是编译器根据下面，猜想为双变量，int 型。<br>　　如果此时编译器猜错了呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段程序通过编译了！<br>　　此时程序输出：<br>　　in exchange ， a = 0.000000，b = 0.000000<br>　　in main ，a = 5 b = 6。<br>　　可以看出来，虽然编译器在语法上没有发现这段程序出错，但实际上程序第一次运行到<code>exchange( a , b ) ;</code>时，是认为 exchange 是 int 型。等到运行完下面的函数部分，第二次运行到<code>exchange( a , b )</code>时，把两个整型的量交给<code>exchange</code>，此时就出错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是这种写法就是正确的，此时虽然也是把两个整型交给 exchange 。但是一开始原型声明就正确了，使得后面整型变量会自动转化为 double 型。</p><p>　　<FONT COLOR = LimeGreen>所以，不要这么些函数原型<code>void f()</code></font></p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>逗号运算符</strong></font></h3><p>　　在C语言里，逗号也是一种运算符，比如<code>(a,b)</code>，此时右边的 b 就是其运算的结果。那么调用函数时的逗号和逗号运算符如何区分？<br>　　<code>F(a,b)</code>调用函数时，小括号的逗号是标点符号，不是运算符。<br>　　<code>F((a,b))</code>此时逗号是运算符，此时函数的参数只有1个，</p><h3 id="不可嵌套定义函数"><a href="#不可嵌套定义函数" class="headerlink" title="不可嵌套定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>不可嵌套定义函数</strong></font></h3><p>　　C语言里不允许函数的嵌套定义，也就是说函数内部不能再定义函数。可以放函数的声明，但不能放函数体（body）</p><h3 id="糟糕的写法"><a href="#糟糕的写法" class="headerlink" title="糟糕的写法"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>糟糕的写法</strong></font></h3><p>　　<code>int i , j , sum( int a , int b )</code>这种写法等同于<code>int i , j ; int sum( int a , int b )</code>不推荐这种写法，不利于阅读。<br>　　<code>return（i）</code>这个 (i) 可有可无，但这会让人误解 return 是一个函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 06 Data Type</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/06/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2006%20Data%20Type/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/06/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2006%20Data%20Type/</id>
    <published>2021-03-06T13:59:47.000Z</published>
    <updated>2021-03-29T05:39:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型</p><a id="more"></a><h1 id="逻辑类型和运算"><a href="#逻辑类型和运算" class="headerlink" title="逻辑类型和运算"></a><FONT COLOR = SpringGreen>逻辑类型和运算</font></h1><h2 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a><FONT COLOR = Cyan>逻辑类型</font></h2><p>　　抬头加入<code>#include&lt;stdbool.h&gt;</code>之后，就可以使用 bool、true、 false。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a><FONT COLOR = Cyan>逻辑运算</font></h2><p>　　逻辑运算是对逻辑进行的运算，结果只有0、1。<br>　　！——逻辑非——！a——如果 a 是true，则结果是false；如果 a 是false，则结果是true。<br>　　&amp;&amp;——逻辑与——a&amp;&amp;b——如果 a 和 b 都是true，则结果是true；否则结果是false。<br>　　||——逻辑或——a||b——如果 a 和 b 至少有一个是true，则结果是true；如果 a 和 b 两个都是false，则结果是false。</p><p>　　有了逻辑运算后，就可以非常方便地表示数学里面的区间：<br>　　如果要表示数学中的区间，如：x∈(4，6)，有人会习惯性地写成4&lt;x&lt;6；但这样实际上是首先算4&lt;x，答案是0或者1，然后判断1&lt;6。正确的做法是<code>x &gt; 4 &amp;&amp; x &lt; 6</code>。<br>　　<code>a &gt; 20 &amp;&amp; a &lt; 30</code> 意思是20 &lt; a &lt; 30。<br>　　<code>a &lt; 0 || a &gt; 99</code> 意思是 a＜0 或者 a＞99。<br>　　<code>!a &lt; 20</code> <FONT COLOR = LimeGreen>注意，！是单目运算符，所以！的优先级要比＜要高。</font>因此这句话 ！a 会先做。如果 a 是 0 ，则！a 会变成1，然后和 20 作比较。如果 a 不是 0，则 ！a 会变成0，然后和 20 作比较。所以整个表达式永远都是1。如果非要表示 a 不小于 20 ，应该用括号：<code>!( a &lt; 20)</code></p><p>　　也可以通过逻辑运算很简单地判断一个字符 c 是否是大写字母：<br>　　<code>c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;</code></p><p><FONT COLOR = PowderBlue size = 4><strong>优先级</strong></font></p><p>　　逻辑运算优先级，单目的非！最高，其次是与&amp;&amp;，最后是或 ||。详情见《第二周 计算》中的表格。</p><h2 id="短路"><a href="#短路" class="headerlink" title="短路"></a><FONT COLOR = Cyan>短路</font></h2><p>　　逻辑运算是从左往右进行的，如果左边的结果已经能够决定最终结果了的话，就不会做右边的计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">0</span> ;</span><br><span class="line">a == <span class="number">6</span> &amp;&amp; (b += <span class="number">1</span>)  ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b) ;</span><br></pre></td></tr></table></figure><p>　　这里“与”的左边是判断 a 是否等于6。对于“与”来说，当左边是 false 的时候，右边的计算就没必要进行下去了。所以此时 b 的值任然是 0 。</p><p>　　<FONT COLOR = LimeGreen>对于&amp;&amp;，左边是 false 时就不做右边了。对于 ||，左边是 true 时就不做右边了。</font><br>　　<FONT COLOR = LimeGreen>所以，千万不要把赋值，以及复合赋值的组合写进表达式。</font></p><h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a><FONT COLOR = Cyan>条件运算</font></h2><p>　　<code>count = ( count &gt; 20 ) ? count - 10 : count + 10</code><br>　　类似于这种代码，问号之前的是条件，问号之后是条件满足的值，冒号之后是条件不满足的值。等价于一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">20</span> )&#123;</span><br><span class="line">count = count - <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">count = count + <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种条件运算会带来阅读上的麻烦。表面上会使程序变得简洁，但实际上很容易出错。<br>　　条件运算符的优先级高于赋值运算符，但是低于其他运算符。于是就可以有如下几种写法：</p><p>　　<code>m &lt; n ? x : a + 5</code>，如果 m &lt; n 的话，值是 x ，否则的话值是 a + 5。<br>　　<code>a++ &gt;= 1 &amp;&amp; b-- &gt; 2 ? a : b</code>，如果 a++ 的结果大于等于1<Font Size = 2><em>（此时a = 1 满足条件，a=0不满足条件）</em></font>，并且 b– 的结果大于<Font Size = 2><em>（此时 b = 3 满足条件）</em></font>；则结果是 a ，否则是 b 。</p><h2 id="逗号运算"><a href="#逗号运算" class="headerlink" title="逗号运算"></a><FONT COLOR = Cyan>逗号运算</font></h2><p>　　逗号用来连接两个表达式，并且以右边的表达式的值作为它的结果。逗号的优先级是所有运算符中最低的（低于赋值），所以它两边的表达式会先计算，逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">i = ( <span class="number">3</span>+<span class="number">4</span> , <span class="number">5</span>+<span class="number">6</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i) ;</span><br></pre></td></tr></table></figure><p>　　此时输出 i 的结果是11。<br>　　逗号运算主要用在 for 循环中，比如：<br>　　<code>for ( i = 0 , j = 10 ; i &lt; j ; i++ , j--)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> , j = <span class="number">10</span> ; i &lt; j ; i++ , j--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d,j=%d\n&quot;</span>,i,j) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;out loop i=%d,j=%d\n&quot;</span>,i,j) ;</span><br></pre></td></tr></table></figure><p>　　<a href="https://imgtu.com/i/cSGJeA"><img src="https://z3.ax1x.com/2021/03/27/cSGJeA.png" alt="cSGJeA.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据类型&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 05 Loop I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/05/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2005%20Loop%20II/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/05/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2005%20Loop%20II/</id>
    <published>2021-03-05T13:59:47.000Z</published>
    <updated>2021-03-29T05:39:48.358Z</updated>
    
    <content type="html"><![CDATA[<p>循环（下）</p><a id="more"></a><h1 id="循环控制-break-amp-continue"><a href="#循环控制-break-amp-continue" class="headerlink" title="循环控制:break &amp; continue"></a><FONT COLOR = SpringGreen>循环控制:break &amp; continue</font></h1><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a><FONT COLOR = Cyan>判断素数</font></h2><p>　　只能被1和自己整除的数就是素数，1不是素数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是素数\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　如果代码是这么写，如果输入素数，则结果是正常的；如果输入合数，则结果就不正常。那么对于这种循环的控制，可以考虑引入一个新的变量。<br>　　定义一个新的变量 Prime，初始值为1，然后只要 <code>x % i == 0</code>成立一次，那么 Prime 为0，最后判断 Prime 的值来判断素数还是合数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是合数\n&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里引入一个变量，来判断循环是否进入过 if ，从而对循环发起控制。</p><p>　　<FONT COLOR = LimeGreen>特别注意的是 break ，break 指跳出当前的循环。</font><br>　　如果没有这个 break，程序要跑一个比较大的数，比如199988，其实进入循环的第一轮就已经确定是合数了。但因为没有break，所以程序要一直跑到 i = 199987，要多跑很多轮。<br>　　如果这里加一个 break，程序第一轮就可以出来了，极大地提高了程序的运行效率。</p><p>　　和 break 相对的还有 continue。<FONT COLOR = LimeGreen>continue：跳过循环这一轮剩下语句，直接进入下一轮。</font><br>　　比如上述判断素数的题目中，可以利用 continue 求出所有的非因子（实在不知道如何表述这些东西）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为这个 continue 的存在，所以当程序进入 if ，执行 continue 的时候，下面的 printf 就不会执行了。</p><p><img src="https://ae01.alicdn.com/kf/U5715dd804e49409f95a0e002a76f73d7i.jpg"></p><p>　　break，continue 都只能对本层循环做。</p><h1 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a><FONT COLOR = SpringGreen>多重循环</font></h1><h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a><FONT COLOR = Cyan>嵌套循环</font></h2><h3 id="100以内的素数"><a href="#100以内的素数" class="headerlink" title="100以内的素数"></a><FONT COLOR = PowderBlue size = 4>100以内的素数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( x &lt; <span class="number">100</span> )&#123;</span><br><span class="line"><span class="keyword">while</span>( i &lt; x )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x) ;</span><br><span class="line">&#125;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line">i = <span class="number">2</span> ;</span><br><span class="line">x++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　循环里面还有循环就是嵌套循环。</p><h3 id="前50个素数"><a href="#前50个素数" class="headerlink" title="前50个素数"></a><FONT COLOR = PowderBlue size = 4>前50个素数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; <span class="number">50</span> )&#123;</span><br><span class="line"><span class="keyword">while</span>( i &lt; x )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x) ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line">i = <span class="number">2</span> ;</span><br><span class="line">x++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　基本的思路和上一段代码一模一样，只不过多加了一个变量 count 用来计数，每成功输出一次 count 自加1。然后循环条件由 x &lt; 100 变成了 count == 50。 </p><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a><FONT COLOR = Cyan>跳出循环</font></h2><h3 id="凑硬币"><a href="#凑硬币" class="headerlink" title="凑硬币"></a><FONT COLOR = PowderBlue >凑硬币</font></h3><p>　　如何用一角、两角、五角的硬币凑出10元以下金额？主要思路是利用 for 循环，对一角、两角、五角全都遍历一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这三个 for 循环的嵌套实际上是对三个变量的遍历，分别是 one 从0到10x；two 从0到5x；five 从0到2x。</p><h3 id="接力break"><a href="#接力break" class="headerlink" title="接力break"></a><FONT COLOR = PowderBlue >接力break</font></h3><p>　　对于凑硬币，如果我们只需要一个结果，即出现一次结果就停，如何是好？如果只用一个break，那只能跳出一层循环，因此我们要多个 break。<FONT COLOR = LimeGreen>即：当满足什么样的条件下，执行 break——引入类似于判断素数 Prime 的变量</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Prime) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Prime) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a><FONT COLOR = PowderBlue >goto</font></h3><p>　　使用接力 break 会使得程序非常清楚，还有一个办法可以直接跳出所有循环：goto。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line"><span class="keyword">goto</span> out ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>　　goto后面接一个标号，程序执行到 goto 时候会直接跳转到标号处。本段代码的标号是 out ，程序执行到 goto 时会直接跳转到 <code>out:</code>后面的那句中，即跳到 <code>return 0 ;</code></p><p>　　goto 会破坏程序的结构性、逻辑性，慎用。尽量仅在多重循环跳转的时候使用。</p><h1 id="循环习题解析"><a href="#循环习题解析" class="headerlink" title="循环习题解析"></a><FONT COLOR = SpringGreen>循环习题解析</font></h1><h2 id="前n项求和"><a href="#前n项求和" class="headerlink" title="前n项求和"></a><FONT COLOR = Cyan>前n项求和</font></h2><p><FONT COLOR = PowderBlue size = 4><strong>调和级数</strong></font><br>$$<br>f(n）=\sum_{i=1}^{n}\frac{1}{i}=1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+…+\frac{1}{n}<br>$$</p><p>像这种起点和终点都非常明确的程序，用 for 循环是最佳选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">double</span> fn = <span class="number">0.0</span> ;</span><br><span class="line"><span class="keyword">double</span> i = <span class="number">1.0</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt;= n  ; i++)&#123;</span><br><span class="line">fn = fn + <span class="number">1</span> / i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f&quot;</span>,n,fn) ;</span><br></pre></td></tr></table></figure><p><FONT COLOR = PowderBlue size = 4><strong>交错调和级数</strong></font><br>$$<br>g(n）=\sum_{i=1}^{n}(-1)^{n-1}\frac{1}{i}=1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+…+\frac{1}{n}<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">double</span> fn = <span class="number">0.0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">double</span> i = <span class="number">1.0</span> ;</span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt;= n  ; i++)&#123;</span><br><span class="line">fn = fn + sign * <span class="number">1</span> / i ;</span><br><span class="line">sign = -sign ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f&quot;</span>,n,fn) ;</span><br></pre></td></tr></table></figure><p>　　这个正负正负正负交错就是用辅助变量 sign 来实现。</p><h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a><FONT COLOR = Cyan>求最大公约数</font></h2><p>给两个数，如何求最大公约数？</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><FONT COLOR = PowderBlue >枚举</font></h3><p>1、输入两个数 a b 。首先判断两个数中最小的是哪个。<br>2、设 t 为2。<br>3、如果 a b 都能被 t 整除，则记下这个 t 。<br>4、t 自加1后重复步骤3，直到 t 等于 min｛a，b｝。<br>5、记下的 t 中最大的就是我们要求的最大公约数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b , min ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( a&lt;=b ) &#123;</span><br><span class="line">min = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">min = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; t &lt;= min ; t++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a % t == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( b % t == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , t ) ;</span><br><span class="line">ret = t ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大公约数是%d&quot;</span>,ret) ;</span><br></pre></td></tr></table></figure><p>　　1、为什么 t 要从1开始？我一开始是让 t 从2开始。从2开始的话，互质的两个数就没办法算公约数了。<br>　　2、ret 的作用就是记录所有的公约数，然后因为 t 是逐步上升的，所以 ret 最后输出的值也一定是最大值。</p><p>　　这种方法很直观，但是缺点是程序要循环很多轮，从1开始，一直到最小的数结束。于是欧几里得发明出更加效率的求最大公约数的算法：欧几里得算法——辗转相除法。</p><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a><FONT COLOR = PowderBlue >辗转相除法</font></h3><p>　　假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>　　1997 / 615 = 3 (余 152)</p><p>　　615 / 152 = 4(余7)</p><p>　　152 / 7 = 21(余5)</p><p>　　7 / 5 = 1 (余2)</p><p>　　5 / 2 = 2 (余1)</p><p>　　2 / 1 = 2 (余0)</p><p>　　至此，最大公约数为1。以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><p>　　<FONT COLOR = LimeGreen>定理</font>：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。<br>　　<FONT COLOR = LimeGreen>证明</font>：<br>　　设 a b 两个数，a &gt; b。a 可以表示成 a = k * b + r ，且r&lt;b。显然，r 就是 a / b的余数，k就是商。<br>　　假设 d 是 a、b 的一个公约数，且 r = a - k * b ，所以 d 也是 r 的约数。所以 a、b 与 b 、r 的公约数相等，所以他们的最大公约数也相等。<br>　　<FONT COLOR = LimeGreen>算法</font>：任意两个数a ，b。假设 t 为余数。<br>　　1、如果 b 等于0，则计算结束，a 就是最大公约数。<br>　　2、否则，t = a % b ，并且令 a = b ， b = t 。<br>　　3、回到第一步。<br>　　<FONT COLOR = LimeGreen>算法解析</font>：<br>　　1、如果 a &gt; b 。则第二步的目的就是把 b 的值赋给 a ，把余数赋给 b 。然后开始辗转相除，直到 t == 0，即余数为 0 ，此时再进行一次 第二步，则把 b 的值赋给 a ，把  t 的值赋给 b ，此时 b == 0 ，计算结束。<br>　　2、为什么没有求 min｛a，b｝的步骤，如果 a &lt; b ，经过第二步后，a 和 b会交换值，则 a &gt; b 了。<br>　　3、不妨假设 a = 12 ， b = 18 看看每步的结果：<br>　　　　 a    b    t<br>　　　　12 18 12<br>　　　　18 12  6<br>　　　　12  6   0<br>　　　　6    0   0<br>　　<FONT COLOR = LimeGreen>代码：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b , t ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) ;</span><br><span class="line"><span class="keyword">while</span>( b != <span class="number">0</span> )&#123;</span><br><span class="line">t = a % b ;</span><br><span class="line">a = b ;</span><br><span class="line">b = t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;最大公约数是%d&quot;</span>,a) ;</span><br></pre></td></tr></table></figure><h2 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a><FONT COLOR = Cyan>整数分解</font></h2><h3 id="逆序分解整数"><a href="#逆序分解整数" class="headerlink" title="逆序分解整数"></a><FONT COLOR = PowderBlue >逆序分解整数</font></h3><p>　　输入一个非负整数。逆序输出它的每一位数字。比如：输入12345，输出5 4 3 2 1。<br>　　算法：<br>　　1、输入x<br>　　2、<FONT COLOR = LimeGreen>x%10，就得到了最后一位数字</font>，输出。<FONT COLOR = LimeGreen>x = x /10 ，去除了最后一位数字</font><br>　　3、x ！= 0 的话，重复步骤2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t ) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样做的话，是大差不差的，但是还是有两个细节。<br>　　第一个，如果 x 是 0 怎么办，因为题目要求 x 是非负，这段程序当 x = 0 时是不输出任何东西的。<br>　　第二个，题目给的要求里最后一个数字是没有空格的。而我这段程序输出会是5 4 3 2 1 ，1后面有个空格。</p><p>　　解决办法：<br>　　1、改 while 为 do - while ，必须要循环一轮。<br>　　2、加一个判断，每一轮都输出一个空格，除了最后一轮。最后一轮x一定是个位数，根据这个来写程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t ) ;</span><br><span class="line"><span class="keyword">if</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><h3 id="正序分解整数"><a href="#正序分解整数" class="headerlink" title="正序分解整数"></a><FONT COLOR = PowderBlue >正序分解整数</font></h3><p>　　输入一个非负整数，正序输出它的每一位数字。比如输入12345，输出1 2 3 4 5 。</p><p><FONT COLOR = LimeGreen>思路一</font>：<br>　　对于一个非负整数，首先把它逆序一遍，然后把它逆序分解，不就成了正序分解？<br>　　如何逆序一个数？算法如下：<br>　　1、引入d，p = 0。<br>　　2、d = x % 10 。这样 d 就取到了 x 的最后一位数。<FONT COLOR = LimeGreen>p = p * 10 + d </font>，x = x / 10 。这样就把 x 的末尾加到了 p 上，且 x 去掉最后一位数。<br>　　3、当 x &gt; 0 时，重复 2 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;x) ;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span> , d ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">d = x % <span class="number">10</span> ;</span><br><span class="line">p = p * <span class="number">10</span> + d ; </span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125; <span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;逆序的结果是%d\n&quot;</span>,p) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = p % <span class="number">10</span> ;</span><br><span class="line">p = p / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ;</span><br><span class="line"><span class="keyword">if</span>( p &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>( p &gt; <span class="number">0</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　但这个方法有一个巨大的缺陷：当输入 700，710。等末尾有0的数时，输出会错误，主要原因是逆序的时候会出问题。</p><p>　<FONT COLOR = LimeGreen>思路2：</font><br>　　1、数出输入的数 x 有多少为，比如是5位数，于是构造 mask = 10^(5-1)。<br>　　2、利用 mask 和 x 写出循环，不再是去尾巴，而是去头。</p><p>　　以 5 位数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">10000</span> ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br></pre></td></tr></table></figure><p>　　这段程序有个问题，就是如果输入 x = 700 ，那么 mask = 100 。输出就会变成7。而不是要求的 7 0 0 。<br>　　原因是循环条件有问题，如果输入 700 ，那么循环只会进行一轮，第二轮就结束了，改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">700</span> ;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( mask &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( mask &gt; <span class="number">0</span> ) ;</span><br></pre></td></tr></table></figure><p>　　不用 x 作为条件，用 mask 。最后一轮的特点是，x 是个位数，mask 是 1。循环结束后 mask 会变成 0 。 </p><p>　　那么如何得到这个mask呢？或者说，如何计算整数的位数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line">mask = mask / <span class="number">10</span> ; <span class="comment">//这里mask会多走一位，所以这里除以10 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mask) ;</span><br></pre></td></tr></table></figure><p>　　其实 mask 从0.1开始更好，但这样就会让 mask 变成浮点数。翁老师的做法不是让 mask 最后自除一个零，而是让循环少跑一轮，改变循环的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">9</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mask) ;</span><br></pre></td></tr></table></figure><p>　　但这样，当 x 是个位数的时候，mask 就会判断错误，所以我还是采取我的办法，即最后让 mask 自除 10 。<br>　　这样数位数的程序就做完了，于是完整的正序分解整数程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> , number ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line">number = x ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">number = number / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( number &gt; <span class="number">0</span> ) ;</span><br><span class="line">mask = mask / <span class="number">10</span> ; <span class="comment">//这里mask会多走一位，所以这里除以10 </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,mask) ;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( mask &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( mask &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag\n&quot;</span>) ;<span class="comment">//这个flag是看看尾巴有没有空格</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环（下）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汉高祖04率先入关</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/04/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9604%E7%8E%87%E5%85%88%E5%85%A5%E5%85%B3/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/04/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9604%E7%8E%87%E5%85%88%E5%85%A5%E5%85%B3/</id>
    <published>2021-03-04T14:14:01.000Z</published>
    <updated>2021-04-13T04:40:43.069Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。</FONT></p><a id="more"></a><h1 id="顺利入关"><a href="#顺利入关" class="headerlink" title="顺利入关"></a>顺利入关</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="历史的天空" scheme="https://github.com/XuSiyuan-cn/categories/%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/"/>
    
    
    <category term="汉高祖" scheme="https://github.com/XuSiyuan-cn/tags/%E6%B1%89%E9%AB%98%E7%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 04 Loop I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/04/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2004%20Loop%20I/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/04/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2004%20Loop%20I/</id>
    <published>2021-03-04T13:59:47.000Z</published>
    <updated>2021-03-29T04:01:16.099Z</updated>
    
    <content type="html"><![CDATA[<p>循环（上）</p><a id="more"></a><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a><FONT COLOR = SpringGreen>循环</font></h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a><FONT COLOR = Cyan>while</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 循环条件 )&#123;</span><br><span class="line">循环体语句</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>　　while循环意思是：当条件满足的时候，不断地重复循环体内的语句。</p><p><a href="https://imgtu.com/i/6JjH6H"><img src="https://s3.ax1x.com/2021/03/10/6JjH6H.jpg" alt="6JjH6H.jpg"></a></p><p>　　以计算数字的位数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , n ) ;</span><br></pre></td></tr></table></figure><p>　　这个程序有一个不完美的地方，就是当 x = 0 时，没办法正常数数。做题的时候学会写一下基本的算法：<br>1、用户输入 x ；<br>2、初始化 n 为0；<br>3、x = x / 10 ，去掉个位 ；<br>4、n++ ；<br>5、如果 x &gt; 0 ，回到3 ；<br>6、否则 n 就是结果。<br>　　如果是上面那种代码，相当于把第五步放到第二步后面，所以应该改成以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , n ) ;</span><br></pre></td></tr></table></figure><p>　　其实这个循环就是 do - while 。因为不管是什么数，都要至少数一次，所以用 do - while 比较好。</p><p>　　循环体内一定要有改变条件的机会，不然就会成为死循环，在编译的时候不会出现语法问题，但结果是错的，或者超时。</p><h2 id="do-while"><a href="#do-while" class="headerlink" title="do - while"></a><FONT COLOR = Cyan>do - while</font></h2><p>　　在进入循环的时候不做检查，而是在执行完一轮循环体的代码后，再来检查循环的条件是否满足，如果满足则继续下一轮的循环，不满足则结束循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体语句</span><br><span class="line">&#125;<span class="keyword">while</span>( 循环条件 ) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>特别注意的是，while() 后面有一个分号。表示一行语句结束的要么是分号，要么是大括号。</font></p><p><a href="https://imgtu.com/i/6JjbXd"><img src="https://s3.ax1x.com/2021/03/10/6JjbXd.jpg" alt="6JjbXd.jpg"></a></p><p>　　while 循环以及 do - while 循环本质是一样的，特别的，判断循环是否继续的条件是一样的。区别是 do -while 无论如何循环体都会至少执行一遍。</p><h2 id="for"><a href="#for" class="headerlink" title=" for "></a><FONT COLOR = Cyan> for </font></h2><p>计算阶乘：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number , Factorial = <span class="number">1</span> , i = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number ) ;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= number )&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Factorial) ;</span><br></pre></td></tr></table></figure><p>这种循环次数很确定的程序很适合用 for 循环来编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt;= number ; i++)&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>for( 初始条件 ; 循环继续的条件 ; 循环每轮最后要做的动作)</code><br>　　读成：对于一开始的初始条件，当循环条件成立时，重复做循环体，循环体完毕后，执行循环每轮最后要做的动作，然后判断循环条件。</p><p>　　<code>for( count = 10 ; count &gt; 0 ; count-- )</code><br>　　读成：对于一开始的 count = 10，当 count &gt; 0 时，重复做循环体，循环体完毕后，执行 count – ，然后判断 count &gt; 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( 表达式<span class="number">1</span> ; 表达式<span class="number">2</span> ; 表达式<span class="number">3</span>)&#123;</span><br><span class="line">&lt;循环体&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/6JjLnA"><img src="https://s3.ax1x.com/2021/03/10/6JjLnA.jpg" alt="6JjLnA.jpg"></a></p><p>　　表达式1可以没有，也可以在表达式1里面定义变量，比如上述的计算阶乘：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number , Factorial = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number ) ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= number ; i++)&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Factorial) ;</span><br></pre></td></tr></table></figure><p>　　如果在 for 循环表达式1里面定义变量，可能会出现一个警告：</p><blockquote><p>[Error] ‘for’ loop initial declarations are only allowed in C99 mode</p><p>[Note] use option -std=c99 or -std=gnu99 to compile your code</p></blockquote><p>　　这种写法是C99才有的，看编译器的接受程度。<br>　　for 循环像一个计数循环：设定一个计数器，初始化它，然后在计数器到达某值之前，重复执行循环体。相比于其他两种循环，for 循环的次数判断是最简单的。</p><h2 id="循环的选择"><a href="#循环的选择" class="headerlink" title="循环的选择"></a><FONT COLOR = Cyan>循环的选择</font></h2><p>　　如果有固定的次数，用 for<br>　　如果必须执行一次，用 do - while<br>　　其他情况用 while </p><h1 id="循环举例"><a href="#循环举例" class="headerlink" title="循环举例"></a><FONT COLOR = SpringGreen>循环举例</font></h1><h2 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a><FONT COLOR = Cyan>循环计算</font></h2><p>　　计算log2x的近似值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , input ;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">input = x ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">x = x /<span class="number">2</span> ;</span><br><span class="line">ret++ ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;log2 of %d is %d&quot;</span>,input , ret ) ;</span><br></pre></td></tr></table></figure><p>　　这个算法其实很简单，就是把 x 除2，能除多少次就是 2 的多少次方。</p><p>　　<FONT COLOR = LimeGreen>对于边界条件判断的小套路</font>：如果要模拟运行一个很大次数的循环，可以模拟较少的循环次数，然后作出推断。</p><h2 id="算平均数"><a href="#算平均数" class="headerlink" title="算平均数"></a><FONT COLOR = Cyan>算平均数</font></h2><p>$$<br>sum=\frac{\sum_{i=1}^{n}{x_i}}{n}<br>$$</p><p>　　让用户输入一系列的正整数，最后输入 -1 表示输入结束，然后程序计算出这些数字的平均数，最后输出 输入数字的个数和平均数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">0</span> , sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> ave ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x ) ;</span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span>)&#123;</span><br><span class="line">sum = sum + x ;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line">ave = <span class="number">1.0</span> * sum / i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average = %f\n&quot;</span>,ave) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d&quot;</span>,i) ;</span><br></pre></td></tr></table></figure><h2 id="猜数"><a href="#猜数" class="headerlink" title="猜数"></a><FONT COLOR = Cyan>猜数</font></h2><p>　　让计算机来想一个数，然后让用户来猜，用户每输入一个数，就告诉用户大了还是小了，直到用户猜中了为止，还要告诉用户总共猜了多少次。</p><p>　　<FONT COLOR = LimeGreen>召唤随机数</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">srand(time(<span class="number">0</span>)) ;</span><br><span class="line"><span class="keyword">int</span> a = rand() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是这样生成的随机数没有办法确定范围，于是有一个<FONT COLOR = LimeGreen>小操作</font>：<br>　　对于任何正整数 a，a % 100 一定在 0 ~ 100之间。a % 1000 一定在 0 ~ 1000 之间。以此类推，显然成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">srand(time(<span class="number">0</span>)) ;</span><br><span class="line"><span class="keyword">int</span> number = rand() ;</span><br><span class="line">number = number % <span class="number">100</span> ;<span class="comment">//这个数一定在 0~ 100之间.</span></span><br><span class="line"><span class="keyword">int</span> x , count ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( x != number)&#123;</span><br><span class="line"><span class="keyword">if</span>( x &gt; number )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big\n&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;small\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the number is %d\n&quot;</span>,x) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d times&quot;</span>,count) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数求逆"><a href="#整数求逆" class="headerlink" title="整数求逆"></a><FONT COLOR = Cyan>整数求逆</font></h2><p>一、700输出007：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , t ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ; </span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、700输出7，12345输出54321：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , t ;</span><br><span class="line">t = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = t * <span class="number">10</span> + x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ;</span><br></pre></td></tr></table></figure><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><FONT COLOR = SpringGreen>讨论</font></h1><h2 id="会被替换为什么？"><a href="#会被替换为什么？" class="headerlink" title="/* */会被替换为什么？"></a><FONT COLOR = Cyan>/* */会被替换为什么？</font></h2><p>　　编译器在把代码翻译成汇编代码前，还有一个步骤叫预处理。在预处理当中会把注释代码干掉。可以使用以下命令来进行预处理：<br>　　gcc -E hello.c -o hello.i<br>　　hello.i 里面就是预处理后的代码。<br>　　一条语句前的注释 =&gt; 等长的空格；<br>　　一条语句中的注释 =&gt; 一个空格；<br>　　一条语句后的注释 =&gt; 直接删除</p><h2 id="最大的数有多大？"><a href="#最大的数有多大？" class="headerlink" title="最大的数有多大？"></a><FONT COLOR = Cyan>最大的数有多大？</font></h2><p>　　C语言能处理的数字是有上限的。<br>　　首先要搞清楚自己编译器各个数据类型占据多少个字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span>* b; <span class="comment">//指针变量，32位系统与64为系统不一样</span></span><br><span class="line">   <span class="keyword">short</span> <span class="keyword">int</span> c;</span><br><span class="line">   <span class="keyword">int</span> d;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> e;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">double</span> g;</span><br><span class="line">   <span class="keyword">long</span> h;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> j;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char a=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(a));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char*b=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(b));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;short int c=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(c));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int d=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(d));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;unsigned int e=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(e));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float f=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(f));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;double g=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(g));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;long h=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(h));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;long long i=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(i));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;unsiged long j=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(j));</span><br></pre></td></tr></table></figure><p>　　对整型int来说，一个整数占4个字节，一个字节可以储存8位无符号数，所以一个整数占32bit，其中最高位要表示符号，所以最小的数就是 -2^31。而最大的数是 2^31-1，理由是要减去一个0。</p><h2 id="for很怪吗？"><a href="#for很怪吗？" class="headerlink" title="for很怪吗？"></a><FONT COLOR = Cyan>for很怪吗？</font></h2><p>　　为什么老师说for循环很怪？for循环是高级语言出现的第一种循环，它和现代的程序设计理念是否存在差距？为什么Python语言就没有C语言这种形式的for循环了？</p><p>　　for循环更加偏向于机器理解的指令，不像while语句更容易让人理解。<br>　　Python中用的是 for in 语句，打个比方，for(int i=0;i&lt;10;i++) 在python中表示为 for i in range(0,10)，python的语法更让人理解。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a><FONT COLOR = SpringGreen>习题</font></h1><h2 id="输出所有小于等于n的奇数"><a href="#输出所有小于等于n的奇数" class="headerlink" title="输出所有小于等于n的奇数"></a><FONT COLOR = Cyan>输出所有小于等于n的奇数</font></h2><p><strong>题目内容：</strong><br>　　比如输入8，则要输出1 3 5 7.比如输入9，则要输出1 3 5 7 9.</p><p><strong>输入格式:</strong><br>　　输入一个正整数n，表示班级的人数。</p><p><strong>输出格式：</strong><br>　　每两个数之间用一个空格隔开，最后一个数后面没有空格。</p><p><strong>输入样例：</strong>11</p><p><strong>输出样例：</strong>1 3 5 7 9 11</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= n )&#123;</span><br><span class="line"><span class="keyword">if</span>( i % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i) ;</span><br><span class="line"><span class="keyword">if</span>( i &lt; n<span class="number">-1</span> )&#123; <span class="comment">//这里我一开始条件是i&lt;n，那样输入偶数就不对了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;f&quot;) ;//用来看尾巴有没有空格</span></span><br></pre></td></tr></table></figure><h2 id="注意-i-和-i-的区别"><a href="#注意-i-和-i-的区别" class="headerlink" title="注意 i++ 和 ++i 的区别"></a><FONT COLOR = Cyan>注意 i++ 和 ++i 的区别</font></h2><p>　　<code>for ( i=0; i&lt;10; i++ ) &#123;...&#125;</code><br>　　<code>for ( i=0; i&lt;10; ++i ) &#123;...&#125;</code><br>　　<code>for ( i=0; i&lt;=9; i++ ) &#123;...&#125;</code><br>　　以上三者等价。<br>　　<code>for ( i=0; i++&lt;10;  ) &#123;...&#125;</code>，这个不一样：</p><p>　　第一种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i) ;</span><br></pre></td></tr></table></figure><p>　　循环了10轮，循环体是 i 从0 到 9。出循环体时 i 是 10。<br>　　第二种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i++&lt;<span class="number">10</span>;  ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i) ;</span><br></pre></td></tr></table></figure><p>　　同样是循环了10轮，循环体是 i 从1 到 10。出循环体时 i 是11。</p><h2 id="注意for循环表达式2和表达式3的顺序"><a href="#注意for循环表达式2和表达式3的顺序" class="headerlink" title="注意for循环表达式2和表达式3的顺序"></a><FONT COLOR = Cyan>注意for循环表达式2和表达式3的顺序</font></h2><p>　　口算一下下面这段代码的输出值是多少：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i=<span class="number">10</span>; i&gt; <span class="number">1</span>; i /=<span class="number">2</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　10 5 3 2 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环（上）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汉高祖03西入秦关</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/03/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9603%E8%A5%BF%E5%85%A5%E7%A7%A6%E5%85%B3/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/03/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9603%E8%A5%BF%E5%85%A5%E7%A7%A6%E5%85%B3/</id>
    <published>2021-03-03T14:14:01.000Z</published>
    <updated>2021-03-16T15:31:15.409Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。</FONT></p><a id="more"></a><h1 id="怀王谋略"><a href="#怀王谋略" class="headerlink" title="怀王谋略"></a><FONT COLOR = SpringGreen>怀王谋略</font></h1><h2 id="怀王夺权"><a href="#怀王夺权" class="headerlink" title="怀王夺权"></a><FONT COLOR = Cyan>怀王夺权</font></h2><p>　　前208年八月，项梁战死后，楚怀王开始了他的一系列操作：</p><blockquote><p>　　时连雨，自七月至九月。项羽、沛公攻外黄未下，去，攻陈留；闻武信君死，士卒恐，乃与将军吕臣引兵而东，徙怀王自盱眙都彭城。吕臣军彭城东；项羽军彭城西；沛公军砀。</p><p>　　后九月，楚怀王并吕臣、项羽军，自将之；以沛公为砀郡长，封武安侯，将砀郡兵；封项羽为长安侯，号为鲁公；吕臣为司徒，其父吕青为令尹。——《资治通鉴·前208》</p></blockquote><p>　　项梁死后，楚怀王做了以下几个部署：<br>　　1、迁都彭城<br>　　2、夺取吕臣、项羽的军队，自己亲自统领<br>　　3、提拔吕臣吕青作为文官。<br>　　4、提拔刘邦</p><p>　　显然这是楚怀王熊心为了自己掌权所做的部署。除此之外，当时还有非常重要的两件事情要解决，就是灭秦和救赵。</p><h2 id="灭秦救赵"><a href="#灭秦救赵" class="headerlink" title="灭秦救赵"></a><FONT COLOR = Cyan>灭秦救赵</font></h2><blockquote><p>　　章邯已破项梁，以为楚地兵不足忧，乃渡河，北击赵，大破之；引兵崐至邯郸，皆徙其民河内，夷其城郭。张耳与赵王歇走入钜鹿城，王离围之。陈馀北收常山兵，得数万人，军钜鹿北；章邯军钜鹿南棘原。赵数请救于楚。——《资治通鉴·前208》</p></blockquote><p>　　项梁被杀之后，章邯认为楚地不用忧虑了，立马开始攻击赵国，而且王离也率领长城军团前来支援。击破邯郸，赵王和国相张耳只能躲进巨鹿城，形势非常危急。<br>　　如果说赵国被击破的话，那么主要反秦武装，就只剩下偏远的燕国和楚国的部分残余了。所以熊心一定要派人去救援赵国，这就是第一个迫在眉睫的任务——救赵。</p><p>　　陈胜吴广当时大泽乡起义时，陈胜派遣周文向西灭秦，最后被章邯击破。所以现在还需要派遣一支军队进入关中灭秦。这就是第二个紧急任务——灭秦。</p><h2 id="怀王之约"><a href="#怀王之约" class="headerlink" title="怀王之约"></a><FONT COLOR = Cyan>怀王之约</font></h2><p>　　当时章邯几乎以一己之力击破了所有的反秦武装，所以大家都害怕和秦军交战，不敢西进灭秦。楚怀王为了激励大家，于是定下了怀王之约：</p><blockquote><p>　　初，楚怀王与诸将约：“先入定关中者王之。”当是时，秦兵强，常乘胜逐北，诸将莫利先入关；独项羽怨秦之杀项梁，奋愿与沛公西入关。——《资治通鉴·前208》</p></blockquote><p>　　先入定关中者王之——“谁能够先进入函谷关，并且安定了关中，谁就是关中王。”在这个重赏之下，也只有两个人愿意，刘邦和项羽。两个任务相比较来说，灭秦较为轻松。最后楚怀王决定，让项羽北上救赵，刘邦西进灭秦。</p><p>　　楚怀王这么做，有以下几点考量：</p><p><FONT COLOR = PowderBlue size = 4><strong>一、项羽残暴</strong></font></p><blockquote><p>　　怀王诸老将皆曰：“项羽为人僄悍猾贼<Font Size = 2><em>【僄悍猾贼：凶悍残忍。】</em></font>。项羽尝攻襄城，襄城无遗类，皆坑之，诸所过无不残灭。且楚数进取，前陈王、项梁皆败。不如更遣长者扶义而西，告谕秦父兄。秦父兄苦其主久矣，今诚得长者往，毋侵暴，宜可下。今项羽僄悍，不可遣。独沛公素宽大长者，可遣。”——《资治通鉴·前208》</p></blockquote><p>　　大家都认为，项羽非常残暴，不适合独自带兵去消灭秦国。需要派一个长者去灭秦。楚怀王的手下将领，也都认为刘邦是宽大长者。</p><p><FONT COLOR = PowderBlue size = 4><strong>二、长者之风</strong></font></p><p>　　何谓长者？第一点要年龄偏大，第二点要宽厚、仁爱。当时是公元前208年，刘邦48岁，项羽24岁，刘邦满足年龄偏大的条件。除此之外，整个社会上对刘邦的评价都比较好，都认为他有长者之风。可以从王陵母亲和郦食其的评价可以看出来：</p><blockquote><p>　　王陵者，故沛人，始为县豪，高祖微时，兄事陵。陵少文，任气，好直言。及高祖起沛，入至咸阳，陵亦自聚党数千人，居南阳，不肯从沛公。及汉王之还攻项籍，陵乃以兵属汉。项羽取陵母置军中，陵使至，则东向坐陵母，欲以招陵。陵母既私送使者，泣曰：“为老妾<Font Size = 2><em>【老妾：旧时年老的妇人对自己的谦称。】</em></font>语陵，谨事汉王。汉王，长者也，无以老妾故，持二心。妾以死送使者。”遂伏剑<Font Size = 2><em>【伏剑：以剑自刎。】</em></font>而死。项王怒，烹陵母。陵卒从汉王定天下。——《史记·陈丞相世家第二十六》</p></blockquote><p>　　王陵的母亲劝王陵为刘邦做事的原因，就是认为刘邦是个长者。</p><blockquote><p>　　及陈胜、项梁等起，诸将徇地<Font Size = 2><em>【徇地：掠地。】</em></font>过高阳者数十人，郦生闻其将皆握齱<Font Size = 2><em>【握齱：同“龌龊”。】</em></font>好苛礼自用<Font Size = 2><em>【自用；自以为是。】</em></font>，不能听大度之言。郦生乃深自藏匿。——《史记·郦生陆贾列传第三十七》</p><p>　　郦食yì其jī为监门，曰：“诸将过此者多，吾视沛公大人长者。”——《史记·高祖本纪第八》</p></blockquote><p>　　郦食其住在高阳，中间经过高阳的起义军将领非常多，但郦食其都看不上，唯独刘邦经过的时候看上了刘邦，就是因为郦食其认为刘邦是个长者。<br>　　从王陵母亲和郦食其的评价可以看出，刘邦在外的名声是非常不错的。</p><p><FONT COLOR = PowderBlue size = 4><strong>三、打压项羽</strong></font></p><p>　　楚怀王是项氏家族所立，项梁死后，楚怀王明里暗里都在打压项氏家族。</p><blockquote><p>　　项梁起东阿，西，比至定陶，再破秦军，项羽等又斩李由，益轻秦，有骄色。宋义乃谏项梁曰：“战胜而将骄卒惰者败。今卒少惰矣，秦兵日益，臣为君畏之。”项梁弗听。乃使宋义使于齐。道遇齐使者高陵君显，曰：“公将见武信君乎？”曰：“然。”曰：“臣论武信君军必败。公徐行即免死，疾行则及祸。”秦果悉起兵益章邯，击楚军，大破之定陶，项梁死。</p><p>　　初，宋义所遇齐使者高陵君显在楚军，见楚王曰：“宋义论武信君之军必败，居数日，军果败。兵未战而先见败征，此可谓知兵矣。”王召宋义与计事，而大说之，因置以为上将军，项羽为鲁公，为次将，范增为末将，救赵。诸别将皆属宋义，号为卿子冠军。——《史记·项羽本纪第七》</p></blockquote><p>　　项梁连连胜利后，宋义劝谏项梁不要骄傲，但项梁不听，还嫌宋义唠叨，于是就把宋义撵去出使齐国，于是就发生了后面和高陵君显相遇的事情。<br>　　楚怀王熊心在听说宋义的事情后，决定和宋义谈话，结果宋义是非常兴奋。他发现宋义是个军事奇才，是一个可以替代项羽的军事奇才。所以他把北伐的重任交给了宋义，而只是把项羽任命为他的副手。</p><p>　　综合以上原因，熊心决定让刘邦西进灭秦，让宋义带着项羽北上救赵。</p><h1 id="高阳酒徒"><a href="#高阳酒徒" class="headerlink" title="高阳酒徒"></a><FONT COLOR = SpringGreen>高阳酒徒</font></h1><blockquote><p>　　（怀王）遣沛公西略地，收陈王、项梁散卒。乃道砀至成阳，与杠里秦军夹壁<Font Size = 2><em>【夹壁：对垒。】</em></font>，破秦二军。楚军出兵击王离，大破之。——《史记·高祖本纪第八》</p></blockquote><p>　　楚怀王于是命令刘邦往西灭秦，刘邦在路上收集陈胜、项梁残余的军队。在西进之前，和北上救赵的队伍一起攻击王离军队。</p><blockquote><p>　　沛公引兵西，遇彭越昌邑，因与俱攻秦军，战不利。还至栗，遇刚武侯，夺其军，可四千余人，并之。与魏将皇欣、魏申徒<Font Size = 2><em>【申徒：官名，即司徒。】</em></font>武蒲之军并攻昌邑，昌邑未拔。——《史记·高祖本纪第八》</p></blockquote><p>　　之后刘邦继续往西进军，路上还遇到了彭越，打了几仗，都不顺利。于是刘邦决定绕过这些攻不下来的城池，经过高阳的时候，遇到了一位非常重要的谋士——郦食其。</p><h2 id="郦生其人"><a href="#郦生其人" class="headerlink" title="郦生其人"></a><FONT COLOR = Cyan>郦生其人</font></h2><blockquote><p>　　郦生食其者，陈留高阳人也。好读书，家贫落魄，无以为衣食业，为里监门吏。然县中贤豪不敢役，县中皆谓之狂生。</p><p>　　及陈胜、项梁等起，诸将徇地<Font Size = 2><em>【徇地：掠地。】</em></font>过高阳者数十人，郦生闻其将皆握齱<Font Size = 2><em>【握齱：同“龌龊”。】</em></font>好苛礼自用<Font Size = 2><em>【自用；自以为是。】</em></font>，不能听大度之言。郦生乃深自藏匿。后闻沛公将兵略地陈留郊，沛公麾下骑士适郦生里中子也，沛公时时问邑中贤士豪俊。骑士归，郦生见谓之曰：“吾闻沛公慢而易<Font Size = 2><em>【易：轻视。】</em></font>人，多大略，此真吾所愿从游，莫为我先<Font Size = 2><em>【先：引见，介绍。】</em></font>。若见沛公，谓曰‘臣里中有郦生，年六十余，长八尺，人皆谓之狂生，生自谓我非狂生’。”骑士曰：“沛公不好儒，诸客冠儒冠来者，沛公辄解其冠，溲溺其中。与人言，常大骂。未可以儒生说也。”郦生曰：“弟<Font Size = 2><em>【弟：但，尽管。】</em></font>言之。”骑士从容言如郦生所诫者。——《史记·郦生陆贾列传第三十七》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　郦食其，是陈留县高阳人。他喜欢读书，但是因为家里贫穷落魄，没有可以依靠过活的产业，于是便去做了看管里门的小吏。但是县里有名望有权势的人没有敢役使他的，当地人都称他为狂生。<br>　　等到陈胜、项梁等人起兵反抗秦朝的时候，起义军将领攻城略地经过高阳的多达数十人，郦食其听闻这些将领个个气量狭小，局促于繁文缛节之中，并且自以为是，很难听取有宏伟抱负的言论。于是郦食其就远远地躲了起来。后来他听说沛公率领军队攻到了陈留郊外，沛公麾下有一名骑兵恰好与郦食其是同乡，沛公经常向他询问陈留县中贤士豪杰的情况。那名骑兵回乡，郦食其见到他后说道：“我曾听说沛公这个人十分傲慢，轻视别人，但是却有远大的谋略，这正是我愿意结交的人，但是并没有人替我引见。你见到沛公以后，就告诉他说‘我的家乡有个人名叫郦食其，已经六十多岁了，身高八尺，县里人都称之为狂生，但他本人却说自己并非狂生’。”骑兵说：“沛公不爱好儒学，凡是佩戴儒生帽子的宾客，总是会被沛公摘掉他们的帽子，并在帽子里小便。他与人谈话时，动不动就破口大骂。所以，你千万不要以儒生的身份去游说沛公。”郦食其说：“你只管将我的话传到就行了。”于是骑兵很从容地将郦食其所吩咐的话转告给沛公。</font></p><p>　　从这个骑兵侍从的话可以看出来，刘邦有两个坏毛病：第一，爱骂人，见人就骂。第二，特别不喜欢儒生，看见儒生的帽子就要“溲溺其中”。即便如此，郦食其也要见刘邦。</p><blockquote><p>　　沛公至高阳传舍，使人召郦生。郦生至，入谒。沛公方倨床使两女子洗足，而见郦生。郦生入，则长揖不拜，曰：“足下欲助秦攻诸侯乎？且欲率诸侯破秦也？”沛公骂曰：“竖儒<Font Size = 2><em>【竖儒：穷酸书生，骂人的话。】</em></font>！夫天下同苦秦久矣，故诸侯相率而攻秦，何谓助秦攻诸侯乎？”郦生曰：“必聚徒合义兵诛无道秦，不宜倨见长者。”于是沛公辍洗，起摄衣，延郦生上坐，谢之。——《史记·郦生陆贾列传第三十七》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　沛公来到高阳传舍下榻，派人召见郦食其。郦食其来到，便进去拜见沛公。当时沛公正坐在床沿上，让两个女子为他洗脚，他就这样召见郦食其。郦食其进来，只是对沛公行了一个拱手礼，并没有跪拜，说：“您是想帮助秦朝打诸侯呢？还是想率领诸侯将秦朝灭掉呢？”沛公骂道：“你这个穷酸书生！天下人苦于秦朝的暴政已经很久了，所以各路诸侯才相继起兵攻打秦朝，你怎么能说帮助秦朝打诸侯呢？”郦食其回答道：“如果您真的打算聚集众人组成正义之师去讨伐暴虐无道的秦朝，那么就不应该用这种傲慢的态度接待长者。”于是沛公停止了洗脚，站起身来整理好衣服，然后请郦食其坐到上位，向他赔礼道歉。</font></p><p>　　郦食其见到刘邦如此场面，非常不高兴，于是没有下跪，而是作了一个长揖，揖而不拜。这个也是不太尊重人的动作。<br>　　刘邦此时48，郦食其此时六十多了；刘邦听了郦食其的一番话之后，觉得非常惭愧，于是道歉，并且请郦食其吃饭，请教灭秦谋略。</p><h2 id="偷袭陈留"><a href="#偷袭陈留" class="headerlink" title="偷袭陈留"></a><FONT COLOR = Cyan>偷袭陈留</font></h2><blockquote><p>　　郦生因言六国从横<Font Size = 2><em>【从横：合纵连横。从，通“纵”。】</em></font>时。沛公喜，赐郦生食，问曰：“计将安出？”郦生曰：“足下起纠合之众，收散乱之兵，不满万人，欲以径入强秦，此所谓探虎口者也。夫陈留，天下之冲，四通五达之郊也，今其城又多积粟。臣善其令，请得使之，令下<Font Size = 2><em>【下：降，归附。】</em></font>足下。即不听，足下举兵攻之，臣为内应。”于是遣郦生行，沛公引兵随之，遂下陈留。号郦食其为广野君。——《史记·郦生陆贾列传第三十七》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　郦食其便说起当年六国合纵连横的形势。沛公听了非常高兴，就赏赐郦食其饭食，问道：“该如何制定伐秦之计呢？”郦食其说：“您聚集乌合之众，收编散兵游勇，不足一万人，想依靠他们直接进军攻打强秦，这就是所谓的摸虎口！陈留这个地方，是天下的交通要道，是个四通八达的地方，如今城中又囤积了很多粮食。我与陈留县令关系很好，请您派我出使陈留，我会劝他归附于您。如果他不听劝的话，您就出兵攻打他，到时候我作内应。”于是沛公派郦食其前往，他自己则带兵在后面尾随，最终占领了陈留。此后，沛公就封郦食其为广野君。</font></p><p>　　郦食其的话也是非常的不客气，直接指出刘邦的要害：现在刘邦手下连一万人都没有，就想消灭强秦，这是绝对不可能的。郦食其建议刘邦先攻打陈留县，第一，陈留县县令是我的朋友。第二，陈留县的军粮很多。刘邦听后决定暂缓西进，先派郦食其游说陈留<Font Size = 2><em>【陈留在现在河南开封附近】</em></font>，然后不等郦食其回来，就立刻偷袭。最后成功攻下陈留，刘邦也因此封郦食其为广野君。<br>　　偷袭陈留成功是刘邦独自西进以来打的第一个大胜仗。</p><h1 id="谋圣之路"><a href="#谋圣之路" class="headerlink" title="谋圣之路"></a><FONT COLOR = SpringGreen>谋圣之路</font></h1><h2 id="初见张良"><a href="#初见张良" class="headerlink" title="初见张良"></a><FONT COLOR = Cyan>初见张良</font></h2><blockquote><p>　　楚王景驹在留，沛公往从之。张良亦聚少年百余人欲往从景驹，道遇沛公，遂属焉；沛公拜良为厩将。良数以太公兵法说沛公；沛公善之，常用其策；良为他人言，皆不省。良曰：“沛公殆天授！”故遂留不去。——《资治通鉴·前208》</p><p>　　陈涉等起兵，良亦聚少年百余人。景驹自立为楚假王，在留。良欲往从之，道还沛公。沛公将数千人，略地下邳西，遂属焉。沛公拜良为厩将<Font Size = 2><em>【厩将：官名。厩，马厩。】</em></font>。<u>良数以《太公兵法》说沛公，沛公善之，常用其策。良为他人者，皆不省。良曰：“沛公殆天授。”</u>故遂从之，不去见景驹。——《史记·留侯世家第二十五》</p></blockquote><p>　　刘邦刚刚起兵的时候就遭遇了雍齿叛乱，刘邦没有打过雍齿，于是准备去投奔陈胜部下立的楚王景驹<Font Size = 2><em>【景驹是陈胜死后，他的部下秦嘉所立】</em></font>。在留县遇见了张良，这是刘邦第一次遇见张良。张良认为刘邦是知音，于是决定跟随刘邦。</p><blockquote><p>　　及沛公之薛，见项梁。项梁立楚怀王。良乃说项梁曰：“君已立楚后，而韩诸公子横阳君成贤，可立为王，益树党。”项梁使良求韩成，立以为韩王。以良为韩申徒<Font Size = 2><em>【申徒：官名，即司徒。】</em></font>，与韩王将千余人西略韩地，得数城，秦辄复取之，往来为游兵颍川。——《史记·留侯世家第二十五》</p></blockquote><p>　　张良遇见项梁后，看见项梁立楚怀王熊心为楚王，于是建议立韩公子横阳君韩成<Font Size = 2><em>【这就是后面项羽杀掉的韩王成】</em></font>为韩王，项梁答应。张良于是为了了却自己家族的心愿，离开刘邦，前去辅佐韩王成。</p><p><Font Size = 2 Color = MediumAquaMarine>　　（张良）与韩王一起带领一千多名士兵向西攻取韩地，攻占了几座城邑，秦国不久又将它们重新夺了回去，他们就在颍川一带往来游走打游击战。</font></p><p>　　从这里可以看出来，张良与韩王成的复国计划并不顺利，张良确实是秦汉之际第一流的谋士，但是会谋划不一定会带兵。应该说张良善于参谋，并不善于直接管理军队。</p><h2 id="再见张良"><a href="#再见张良" class="headerlink" title="再见张良"></a><FONT COLOR = Cyan>再见张良</font></h2><blockquote><p>　　沛公之从雒阳南出轘辕，良引兵从沛公，下韩十余城，击破杨熊军。沛公乃令韩王成留守阳翟，与良俱南，攻下宛，西入武关。——《史记·留侯世家第二十五》</p><p>　　（刘邦）乃以郦食其为广野君，郦商为将，将陈留兵，与偕攻开封<Font Size = 2><em>【开封：当时称启封，《史记》避汉景帝刘启讳，改启为开。】</em></font>，开封未拔。西与秦将杨熊战白马，又战曲遇东，大破之。杨熊走之荥阳，二世使使者斩以徇。南攻颍yǐng阳，屠之。因张良遂略韩地轘huán辕。——《史记·高祖本纪第八》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　沛公于是封郦食其为广野君，任命郦商为将军，率领陈留的军队，与他一起攻打开封，开封没有攻下。沛公向西和秦将杨熊在白马交战，又在曲遇以东交战，大破秦军。杨熊逃到荥阳，秦二世派使者将他斩首示众。沛公向南进攻颍阳，屠戮那里。依靠张良终于攻下韩地的轘辕关。</font></p><p>　　刘邦攻破陈留后，张良也在河南附近，于是张良过来面见刘邦，这是张良刘邦的第二次相会。在刘邦的帮助下，韩国终于复国。于是张良决定跟着刘邦，帮助刘邦西进灭秦。</p><h2 id="智取南阳"><a href="#智取南阳" class="headerlink" title="智取南阳"></a><FONT COLOR = Cyan>智取南阳</font></h2><p>　　关中的地形是非常险要的，四面都是山，四面有四个非常重要的关口：东边函谷关、西边大散关、北边萧关、南边武关，因此关中也称为四塞之地，易守难攻。<br>　　刘邦想要进入关中实际上只有两条路：从洛阳继续向西，经过函谷关进入关中。另一条是南下，走陕西西南部分的武关。当年周文是从函谷关打进去的，所以刘邦也想走这条路。</p><blockquote><p>　　当是时，赵别将司马卬方欲渡河入关，沛公乃北攻平阴，绝河津。南，战雒阳东，军不利。——《史记·高祖本纪第八》</p></blockquote><p>　　刘邦在洛阳这里吃了败仗，洛阳没有攻下来，还想从洛阳打进函谷关就非常困难。所以刘邦决定南下，经过南阳，从武关打进关中。</p><blockquote><p>　　还至阳城，收军中马骑，与南阳守齮战犨东，破之。略南阳郡，南阳守齮走，保城守宛。沛公引兵过而西。——《史记·高祖本纪第八》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　回军到阳城，集合军队中的战马和骑兵，与南阳郡守齮在犨县以东交战，击败敌军。攻取南阳郡的土地，南阳郡守齮逃跑，退守到宛县。沛公领兵绕过宛县向西进发。</font></p><p>　　刘邦首先和南阳郡的郡守打了一仗，刘邦胜利后郡守退守宛城，宛城是南阳郡的郡治。刘邦看见太守撤退了，于是想绕过宛县直接向西走。</p><p>　　这里反映出刘邦的一种急功近利的心态，刘邦的目的很明确，就是抢时间。能绕过的就绕，能不打的就不打。就在这时，对于刘邦这种急功近利的进军方式，张良提出了反对意见：</p><blockquote><p>　　张良谏曰：“沛公虽欲急入关，秦兵尚众，距险。今不下宛，宛从后击，强秦在前，此危道也。”于是沛公乃夜引兵从他道还，更旗帜，黎明，围宛城三匝。——《史记·高祖本纪第八》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　张良劝谏说：“沛公虽然想要尽快攻入关中，但是秦军人数还有很多，据守险要地带。现在不攻下宛县，宛县从后面进攻，强大的秦军挡在前方，这是危险的做法。”于是沛公就在夜里领兵从另一条路返回，变换了旗帜，天快亮时，把宛县城围了三重。</font></p><p>　　刘邦于是假装向西进军，实际上改换旗帜，偷偷掉头回来。南阳郡守以为刘邦的军队全都撤走了，于是放松了戒备。没想到第二天早上，刘邦就包围了南阳，南阳形势危急。</p><blockquote><p>　　南阳守欲自刭。其舍人陈恢曰：“死未晚也。”乃逾城见沛公，曰：“臣闻足下约，先入咸阳者王之。今足下留守宛。宛，大郡之都<Font Size = 2><em>【大郡之都：南阳郡治所在宛县。】</em></font>也，连城数十，人民众，积蓄多，吏人自以为降必死，故皆坚守乘城。今足下尽日止攻，士死伤者必多；引兵去宛，宛必随足下后，足下前则失咸阳之约，后又有强宛之患。为足下计，莫若约降，封其守，因使止守，引其甲卒与之西。诸城未下者，闻声争开门而待，足下通行无所累。”沛公曰：“善。”乃以宛守为殷侯，封陈恢千户。引兵西，无不下者。——《史记·高祖本纪第八》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　南阳郡守想要自杀。他的门客陈恢说：“等我回来再死也不算晚。”他就翻越城墙去见沛公，说：“我听说您有约定，先进入咸阳的人可以在关中称王。现在您却留下围攻宛县。宛县，是大郡的治所，相连的城邑有几十座，人口众多，积蓄充足，官吏和百姓都认为投降一定会死，因此都登上城墙顽强防守。现在您整天留在这里攻城，士卒死伤的一定有很多；领兵离开宛县，宛县的军队一定会跟在您的后面，您向前就不能履行先入咸阳的约定，向后又有强大的宛县为祸患。我替您考虑，不如约请宛县守军投降，封赏南阳郡守，顺便留他在这里守城，您率领他的士卒向西进发。那些没有被攻下的城邑，听说这个消息，都会争相打开城门等您进城，您就能通行无所牵挂了。”沛公说：“好。”于是他封南阳郡守为殷侯，封给陈恢一千户食邑。沛公领兵向西进发，没有不能攻下的城邑。</font></p><p>　　这个陈恢给刘邦分析了一下局势：如果强攻宛县，一定会耽误率先灭秦的时间，而且搞不好死伤惨重。大家不愿意投降的原因，是这些官吏害怕投降后被清算<Font Size = 2><em>【刘邦在颍阳屠过城】</em></font>。陈恢给刘邦出了个主意，那就是给大家定个投降的条约——约降：只要投降，把军队交给刘邦，刘邦就保证不伤害大家性命，而且保证大家官职不变。<br>　　刘邦听取了陈恢的建议，还给南阳郡守、陈恢一定的封赏。至此，南阳下属所有的县城全部投降刘邦。</p><blockquote><p>　　至丹水，高武侯鳃、襄侯王陵降西陵。还攻胡阳，遇番pó君<Font Size = 2><em>【番君：吴芮。】</em></font>别将梅鋗，与皆<Font Size = 2><em>【皆：同“偕”。】</em></font>，降析、郦。遣魏人宁昌使秦，使者未来。是时章邯已以军降项羽于赵矣。——《史记·高祖本纪第八》</p></blockquote><p><Font Size = 2 Color = MediumAquaMarine>　　抵达丹水，高武侯戚鳃、襄侯王陵在西陵投降。回军进攻胡阳，遇到番君的别将梅鋗，和他一起，降服了析县、郦县。沛公派魏人宁昌出使秦朝，使者没有回来。当时章邯已经率领全军在赵地向项羽投降了。</font></p><hr><p>　　刘邦有自己的过人之处，其中一个就是刘邦的悟性特别好。他不懂兵法，但只要张良跟他讲解，他就能马上听懂。他的计谋也不多，但只要别人讲的有道理，他立即就能采纳。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="历史的天空" scheme="https://github.com/XuSiyuan-cn/categories/%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/"/>
    
    
    <category term="汉高祖" scheme="https://github.com/XuSiyuan-cn/tags/%E6%B1%89%E9%AB%98%E7%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 03 Judgment</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/03/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2003%20Judgment/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/03/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2003%20Judgment/</id>
    <published>2021-03-03T13:59:47.000Z</published>
    <updated>2021-03-29T04:01:13.298Z</updated>
    
    <content type="html"><![CDATA[<p>判断</p><a id="more"></a><h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a><FONT COLOR = SpringGreen>判断</font></h1><h2 id="if-判断"><a href="#if-判断" class="headerlink" title=" if 判断"></a><FONT COLOR = Cyan> if 判断</font></h2><p>　　格式：<code>if(条件成立)&#123;则...&#125;</code><br>　　以算时间差为例，上一讲我们采取全部换算成分钟来做，这次采取用 if 判断是否存在借位的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hour1 , hour2 , minute1 , minute2 ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;hour1 , &amp;minute1) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;hour2 , &amp;minute2) ;</span><br><span class="line"><span class="keyword">int</span> hour , minute ;</span><br><span class="line">hour = hour2 - hour1 ;</span><br><span class="line">minute = minute2 - minute1 ;</span><br><span class="line"><span class="keyword">if</span>( minute &lt; <span class="number">0</span> )&#123;</span><br><span class="line">minute = minute + <span class="number">60</span> ;</span><br><span class="line">hour-- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;时间差是%d小时%d分钟\n&quot;</span>, hour , minute ) ;</span><br></pre></td></tr></table></figure><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a><FONT COLOR = Cyan>关系运算</font></h2><p><a href="https://imgtu.com/i/6Gslzd"><img src="https://s3.ax1x.com/2021/03/10/6Gslzd.png" alt="6Gslzd.png"></a></p><p>　　关系运算的结果只有两个值，如果符合预期则是1，如果不符合预期则是0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> == <span class="number">3</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> &gt; <span class="number">3</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> &lt;= <span class="number">3</span> );</span><br></pre></td></tr></table></figure><p>　　输出的值分别是0 、1、0。<br>　　所有的关系运算符的优先级都要比算术运算低，但是比赋值运算高。<br>　　在关系运算符之间，判断是否相等的 ==、！= 优先级也要比其他判断大小的优先级要低。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><FONT COLOR = Cyan>注释</font></h2><p>　　单行注释：C语言里，双斜杠可以表示一行都是注释 // ，C99支持，ANSI不支持。<br>　　多行注释：/**/ 可以表示多行注释</p><h2 id="else"><a href="#else" class="headerlink" title="else"></a><FONT COLOR = Cyan>else</font></h2><p>　　以算找零为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price , bill ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入金额\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;price) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入票面\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;bill) ;</span><br><span class="line"><span class="keyword">if</span>(bill &gt; price)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应该找您%d\n&quot;</span>,bill-price) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;钱不够&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　if - else 格式与流程图如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 条件表达式 )&#123;</span><br><span class="line"><span class="keyword">if</span>体语句</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">else</span>体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<a href="https://imgtu.com/i/6J5b9I"><img src="https://s3.ax1x.com/2021/03/10/6J5b9I.jpg" alt="6J5b9I.jpg" style="zoom: 67%;" /></a></p><h2 id="没有大括号"><a href="#没有大括号" class="headerlink" title="没有大括号"></a><FONT COLOR = Cyan>没有大括号</font></h2><p>　　一个基本的 if 语句由一个关键字 if 开头，跟上在括号里的一个表示条件的逻辑表达式，然后是一对大括号 “{}” 之间的若干条语句。<br>　　如果表示条件的逻辑表达式的结果不是零，那么就执行后面跟着的这对大括号中的语句，否则就跳过这些语句不执行，而继续下⾯面的其他语句。</p><p>　　if 语句还有一种形式，就是没有大括号的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( total &gt; amount )</span><br><span class="line">total += amount+<span class="number">10</span> ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>if 语句这一行结束的时候并没有表示语句结束的分号 “ ; ” </font>。而后面的赋值语句写在 if 的下一行，在这一行结束的时候有一个表示语句结束的分号。这表明这条赋值语句是if语句的一部分，if 语句拥有和控制这条赋值语句，决定它是否要被执行。else 同理。</p><p>　　以计算加班费为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> rate = <span class="number">8.25</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> standard = <span class="number">40</span> ;</span><br><span class="line"><span class="keyword">double</span> pay = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hours ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入工作的小时数：&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;hours) ;</span><br><span class="line"><span class="keyword">if</span>( hours &gt; standard )</span><br><span class="line">pay = standard * rate + ( hours - standard ) * ( rate * <span class="number">1.5</span> ) ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pay = hours * rate ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应付工资：%f\n&quot;</span>,pay) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　以判断成绩为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> PASS = <span class="number">60</span> ;</span><br><span class="line"><span class="keyword">int</span> score ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;清输入成绩：&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你输入的成绩是%d。\n&quot;</span>, score ) ;</span><br><span class="line"><span class="keyword">if</span>( score &gt;= PASS)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;及格了\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不及格\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;再见\n&quot;</span>) ; </span><br></pre></td></tr></table></figure><p>　　可以看到，if 和 else 后面都没有大括号，那么紧跟着 if 和 else 的语句就是他们控制的语句。而《判断成绩》里的再见不属于 if 或者 else 控制。但这种写法很危险！</p><h1 id="判断的嵌套与级联"><a href="#判断的嵌套与级联" class="headerlink" title="判断的嵌套与级联"></a><FONT COLOR = SpringGreen>判断的嵌套与级联</font></h1><h2 id="嵌套的-if-else"><a href="#嵌套的-if-else" class="headerlink" title="嵌套的 if - else"></a><FONT COLOR = Cyan>嵌套的 if - else</font></h2><p>　　判断三个数比较大小，先画出流程图：</p><p><img src="https://www.hualigs.cn/image/6050233c3b196.jpg"></p><p>　　根据流程图写出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b, c ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c) ;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line"><span class="keyword">if</span>( a &gt; c)&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = c ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( b &gt; c )&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = c ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　if - else 里面还有 if - else，这就是 if - else的嵌套。对于这种代码的编写与阅读，建议先画出流程图。<br>　　<FONT COLOR = LimeGreen>else 的匹配</font>：else 总是会和最近的 if 匹配。当然，前提是没有大括号的影响：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( a == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( b == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一切正常&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;继续等待&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个 else 就属于第二个 if 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( a == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( b == <span class="number">1</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一切正常&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;继续等待&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个 else 就属于 第一个 if 。</p><p>　　这些都是不好的编写习惯，所以对于 if - else 不管接下来跟几句代码，都要加｛｝。减少错误，也方便阅读。</p><h2 id="级联的-if-else"><a href="#级联的-if-else" class="headerlink" title="级联的 if -else "></a><FONT COLOR = Cyan>级联的 if -else </font></h2><p>　　如何表示分段函数？比如<br>$$<br>f(x)=\begin{cases} -1，x&lt;0\ 0， x=0\2x,　x&gt;0\end{cases}<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , fx ;</span><br><span class="line"><span class="keyword">if</span>( x &lt; <span class="number">0</span> )&#123;</span><br><span class="line">fx = <span class="number">-1</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( x == <span class="number">0</span> )&#123;</span><br><span class="line">fx = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">fx = <span class="number">2</span> * x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种有 if - else if - else 的，就称为 if - else 的级联。利用流程图来理解：</p><p><img src="https://www.hualigs.cn/image/6050de45bdc71.jpg"></p><h1 id="多路分支"><a href="#多路分支" class="headerlink" title="多路分支"></a><FONT COLOR = SpringGreen>多路分支</font></h1><p>　　当情况非常多的时候，用级联的 if - else 就会比较复杂，比如以下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> type ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type) ;</span><br><span class="line"><span class="keyword">if</span> ( type == <span class="number">1</span> )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;morning&quot;</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( type == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;afternoon&quot;</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( type == <span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;evening&quot;</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( type == <span class="number">4</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bye&quot;</span>) ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;what?&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　这种情况下，级联的 if - else 写起来比较复杂，程序运行速率也比较慢，于是就有另外的一种方式：switch - case 语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> type ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type) ;</span><br><span class="line"><span class="keyword">switch</span>( type )&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;morning&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;afternoon&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;eventing&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bye&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;what?&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　switch - case 格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( 控制表达式 )&#123;</span><br><span class="line"><span class="keyword">case</span> 常量 :</span><br><span class="line">语句......</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> 常量 :</span><br><span class="line">语句......</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">default</span> : </span><br><span class="line">语句......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>特别注意</font>：<br>　　这个控制表达式，只能是整数型的结果，即 int 型。<br>　　case 中的 break 不一定强制需要。switch 可以看作是一种基于计算的跳转。计算控制表达式的值之后，程序会跳转到相匹配的 case 处。这个 case 相当于是一个路牌，执行完这个 case 里面的所有语句后，如果后面没有 break，程序就会顺序执行到下面的 case 里去，直到遇到一个 break，或者 switch 结束为止。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( type )&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;afternoon&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;what?&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　比如此时，输入 1 或者 2 都能得到 afternoon 的结果。</p><h2 id="switch-case举例"><a href="#switch-case举例" class="headerlink" title="switch - case举例"></a><FONT COLOR = Cyan>switch - case举例</font></h2><p>　　<FONT COLOR = PowderBlue size = 4><strong>成绩转换</strong></font>：<br>　　本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则：大于等于90分为A；小于90且大于等于80为B；小于80且大于等于70为C；小于70且大于等于60为D；小于60为E。<br>　　输入格式：输入在一行中给出一个整数的百分制成绩。<br>　　输出格式：在一行中输出对应的五分制成绩。<br>　　输入样例：90<br>　　输出样例：A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score ; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;score) ;</span><br><span class="line">score = score / <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">switch</span>( score )&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :<span class="comment">//这段要是漏了，100分就没法处理 </span></span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>) ;</span><br><span class="line"><span class="keyword">break</span> ; </span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;E&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段代码不符合单一出口原则，等学了字符串后再说。</p><h1 id="if-常见错误"><a href="#if-常见错误" class="headerlink" title="if 常见错误"></a><FONT COLOR = SpringGreen>if 常见错误</font></h1><p>　　<FONT COLOR = LimeGreen>忘记大括号</font>：if - else 后面不管有几条语句，都要加大括号，除了if - else - if 级联以外。</p><p>　　<FONT COLOR = LimeGreen>if 后面的分号</font>：if 后面不能有分号，否则 if 失效：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> salary = <span class="number">4000</span> ;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">55</span> ;</span><br><span class="line"><span class="keyword">if</span>( age &gt; <span class="number">60</span> );</span><br><span class="line">&#123;</span><br><span class="line">salary = salary * <span class="number">1.2</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,salary) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段程序还是可以通过编译的，但实际上 if 已经失效了，因为 if 后面有大括号的缘故，相当于 if 判断后执行了一条空语句。<br>　　保持一个习惯，写完 if 后，习惯性加一个 ( ) 和 { } 。</p><p>　　<FONT COLOR = LimeGreen>错误的使用 == 和 =</font>：if 只要求 ( ) 里的值是零，或者非零。也就是说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> , b = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">if</span>( a = b )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A=B&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　不管 a b 为何值，都能通过编译，而且都能进入 if 。</p><p>　　<FONT COLOR = LimeGreen>使人困惑的 else </font>：注意格式和美观。代码风格就是三观。</p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><FONT COLOR = SpringGreen>讨论</font></h1><h2 id="分段函数可以用switch-case吗？"><a href="#分段函数可以用switch-case吗？" class="headerlink" title="分段函数可以用switch-case吗？"></a><FONT COLOR = Cyan>分段函数可以用switch-case吗？</font></h2><p>　　比如这个函数，如果用 switch - case 表示，如何表示？<br>$$<br>f(x)=\begin{cases} -1，x&lt;0\ 0， x=0\2x,　x&gt;0\end{cases}<br>$$<br>　　使用逻辑判断方法，将 x 区间全部化为整数：<br>　　<code>t = ( x &gt;= 0 ) + ( x == 0)</code>，如果 x &lt; 0 ，则 t = 0，如果 x &gt; 0 ，则 t = 1，如果 x = 0 ，则 t = 2  。（不满足条件，满足一个条件，满足两个条件）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t , x ;</span><br><span class="line"><span class="keyword">int</span> fx ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">t = ( x &gt;= <span class="number">0</span> ) + ( x == <span class="number">0</span> ) ;</span><br><span class="line"><span class="keyword">switch</span>( t )&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">fx = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">fx = <span class="number">2</span> * x ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">fx = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,fx) ;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;判断&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 02 Calculation</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/02/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2002%20Calculation/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/02/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2002%20Calculation/</id>
    <published>2021-03-02T02:36:38.000Z</published>
    <updated>2021-03-29T04:01:10.346Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>计算</FONT></p><a id="more"></a><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a><FONT COLOR = SpringGreen>变量</font></h1><p>　　以算找零为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> price = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;price);</span><br><span class="line"><span class="keyword">int</span> change = <span class="number">100</span> - price;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,change);</span><br></pre></td></tr></table></figure><h2 id="关于scanf"><a href="#关于scanf" class="headerlink" title="关于scanf"></a><FONT COLOR = Cyan>关于scanf</font></h2><p>　　1、输入是以行为单位进行的，行的结束标志就是按下回车键。也就是说，按下回车键之前，程序不会读到任何东西。<br>　　2、scanf中如果没有&amp;，程序不会报错，但是在执行的时候会卡住。<br>　　3、%d表示要求输入一个整数，如果不是整数怎么办？就会出现输入无效的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> , b = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a , &amp;b) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a , b ) ;</span><br></pre></td></tr></table></figure><p>　　出现在scnaf格式字符串的东西，都是scanf需要读取的东西。如果中间有空格则一定要输入空格；如果里面有逗号则一定要输入逗号。<br>　　<code>scanf(&quot;%d %d&quot;, &amp;a , &amp;b) ;</code>如果两个%d中间有空格，可以用回车代替。多个空格视为一个空格。<br>　　<code>scanf(&quot;%d，%d&quot;, &amp;a , &amp;b) ;</code>如果有逗号却没有输入逗号的话，则后面的变量就会输入失败，程序就不会去读取用户给b的输入值。这个逗号可以是英文或者中文。<br>　　<code>scanf(&quot;%d %d &quot;, &amp;a , &amp;b) ;</code>如果最后一个%d后面有空格，则一定要输入空格，否则按再多的回车也没用。可以用其他东西代替空格，比如随便输入一些数字之类的，这个东西不会被程序读取，只是为了满足空格。<br>　　<code>scanf(&quot;%d %d\n&quot;, &amp;a , &amp;b) ;</code>如果最后一个%d后面有回车，则输入回车也没有用，一定要输入一个其他的东西来满足回车。这个东西不会被程序读取，只是为了满足回车。</p><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a><FONT COLOR = Cyan>变量定义</font></h2><p>　　变量是一个保存数据的地方。<br>　　变量定义的一般形式是类型名称+变量名称。比如：int price ； int amount ； int price , amount；<br>　　变量需要一个名字，即“标识符”，计算机用其来进行区分和识别。<br>　　<FONT COLOR = LimeGreen>标识符有其构造规则</font>：<br>　　1、只能用字母、数字、下划线组成。<br>　　2、数字不可以出现在第一个位置上。<br>　　3、C语言的关键字（保留字）不能作为标识符。</p><h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a><FONT COLOR = Cyan>变量赋值</font></h2><p><code>int price = 0 ；</code><br>　　这一行定义了一个变量。变量名字是price，类型是int，这个赋值动作是在定义变量时候做的，所以这个值也称为初始值，或初始化。<br>　　在C语言里，初始化和赋值的差异不大，在C++里会有差异。<br>　　C语言里没有强制要求所有的变量在定义的地方做初始化，但是要求所有的变量第一次被使用（出现在赋值运算右边时候）之前被赋值一次。</p><p><FONT COLOR = PowderBlue size = 4><strong>如果没有初始化？</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line">b = a + <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b);</span><br></pre></td></tr></table></figure><p>　　如果没有进行初始赋值而强行运算，可能会出现一堆奇怪的数字。原因是变量在内存当中，如果没有初始赋值，那么这个变量所处的内存位置，原本有什么数据，他就会输出什么数据。就像去一间没有打扫过的房间一样。</p><p><FONT COLOR = PowderBlue size = 4><strong>变量初始化</strong></font></p><p>　　单独初始化：<code>int price = 0 ；</code>&lt;类型名称&gt;&lt;变量名称&gt; = &lt;初始值&gt;；<br>　　组合初始化：<code>int price = 0 ， amount = 100 ；</code><br>　　在<code>int change = 100 - price;</code>这一行中，不仅仅定义了变量change，还做了计算。这种写法是C99的写法，C99允许在程序的任何地方定义变量，只要在这个变量第一次使用之前都可以。而更老的版本ANSI C只能在代码开头的地方定义变量。</p><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a><FONT COLOR = Cyan>常量与变量</font></h2><p>　　固定不变的数是常数，直接写在程序里，我们称作直接量（literal）。比如在《算找零》程序中那个100，就是直接量。更好地方式是定义一个常量：<br>　　<code>const int AMOUNT = 100 ;</code> 这也是C99的写法，这个好处是让程序更好地理解，更好地修改。<br>　　<FONT COLOR = PowderBlue >const</font> 是一个修饰符，加在 int 的前面，用来给这个变量加上一个 const （不变的）属性。这个 const 的属性表示这个变量的值一旦初始化，就不能再修改了。如果尝试对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指为一个错误。</p><blockquote><p>[Error] assignment of read-only variable</p></blockquote><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><FONT COLOR = SpringGreen>浮点数</font></h1><p>　　C是一种有类型的语言，所有的变量在使用之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。<br>　　带小数点的数就是浮点数。浮点这个词的本意就是指小数点是浮动的，是计算机内部表达非整数（包含分数和无理数）的一种方式。另一种方式叫做定点数，表示小数点永远出现在第几位，比如小数点永远出现在第四位。<br>　　在C语言里不会遇到定点数，人们用浮点数表示所有带小数点的数。</p><p>　　关于浮点数的研究以单位换算为例，英制长度英尺英寸转化为公制单位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> foot = <span class="number">0</span> , inch = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> meter ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，如输入5 7表示5英尺7英寸\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;foot , &amp; inch);</span><br><span class="line">meter = ( foot + inch / <span class="number">12.0</span>) * <span class="number">0.3048</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你的身高是%f米&quot;</span>, meter) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　就是这么个简单程序实际写起来会有很多注意点，以下注意点都是语法不会报错的情况：</p><p><FONT COLOR = PowderBlue size = 4><strong>第一个注意点</strong></font>：<code>    meter = ( foot + inch / 12) * 0.3048 ;</code><br>　　inch 是整型，12也是整数。<FONT COLOR = LimeGreen>整数在互相运算的时候只能出现整数。</font>所以如果此时 inch 是11，则运算结果是0；如果 inch 是13，则运算结果是1。<br>　　在C语言中，10/3*3 = 9 。小数点后面的数全都被丢掉了。10和10.0在C中是完全不同的两个数。10.0是浮点数。由于这个特性所以有一些很特殊的运算：</p><p>　　10/3.0*3 = 10.0 。</p><p>　　10/3*3.0=9.0 。<br>　　基于此可以有以下修改。</p><p>　　第一个办法是：把这行变成：<code>meter = ( foot + inch / 12.0) * 0.3048 ;</code><FONT COLOR = LimeGreen>当浮点数和整数放到一起运算时，C会将整数转换为浮点数，然后进行浮点数的运算。</font>即 inch 整数和浮点数做计算的时候，自己也会变成浮点数。<br>　　第二个办法是：<FONT COLOR = LimeGreen>在开头就把 inch ，foot 定义为 double ，但此时一定要注意scanf 里面输入也有变化，不再是%d，而是%lf</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> foot , inch , meter ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，如输入5 7表示5英尺7英寸\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;foot , &amp; inch);</span><br><span class="line">meter = ( foot + inch / <span class="number">12</span>) * <span class="number">0.3048</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你的身高是%f米&quot;</span>, meter) ;</span><br></pre></td></tr></table></figure><p>　　double是“双精度浮点数”的意思，float表示单精度浮点数。</p><p><FONT COLOR = PowderBlue size = 4><strong>第二个注意点</strong></font>：<code>double meter ;</code><br>　　因为meter里要乘以一个0.3048，meter一定是浮点数。所以定义meter时候如果定义为int，输出值会不正常。不是说int型不能用float输出，而是int型没有经过运算就赋值小数的话，会不正常。比如下面这段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ;</span><br><span class="line">a = <span class="number">1.333</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,a);</span><br></pre></td></tr></table></figure><p>　　输出就是一串0。</p><p><FONT COLOR = PowderBlue size = 4><strong>第三个注意点</strong></font>：<code>printf(&quot;你的身高是%d米&quot;, meter);</code> </p><p>　　meter一定是浮点数，而输出范式是%d整数的话，输出的值就不正常。所以输出应该是%f。</p><p><FONT COLOR = PowderBlue size = 4><strong>数据类型小总结</strong></font>：<br>　　整数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：<span class="keyword">int</span>  ;</span><br><span class="line">输入：<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;...) ;</span><br><span class="line">输出：<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , ....) ;</span><br></pre></td></tr></table></figure><p>　　小数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：<span class="keyword">double</span>  ;</span><br><span class="line">输入：<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;...) ;</span><br><span class="line">输出：<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span> , ....)</span><br></pre></td></tr></table></figure><p>求平均值的例子再次巩固下数据类型的差别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"><span class="keyword">double</span> c ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a , &amp;b) ;</span><br><span class="line">c = ( a + b ) / <span class="number">2.0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span> , c ) ;</span><br></pre></td></tr></table></figure><p>1：如果不是 double c 而是 int c ，那么就会出现小数缺失的情况<br>　　特别注意的是，如果代码改成<code>    int c ; c = ( a + b ) / 2.0 ;</code>这样还是会出现问题。整型赋值为浮点数就会出问题</p><p>2：<code>c = ( a + b ) / 2</code> 这样也会出问题。除非在一开始的时候把 a 和 b 全部定义为 double 型。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><FONT COLOR = SpringGreen>表达式</font></h1><p>　　四则运算：“%”，表示取余。</p><p>　　以计算时间差为例：输入两个时间，每个时间分别输入小时和分钟的值，然后输出两个时间之间的差，也以几小时几分钟来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hour1 , hour2 , minute1 , minute2 ;</span><br><span class="line"><span class="keyword">int</span> minute , hour ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;hour1 , &amp;minute1) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;hour2 , &amp;minute2 ) ;</span><br><span class="line">minute1 = minute1 + hour1 * <span class="number">60</span> ;</span><br><span class="line">minute2 = minute2 + hour2 * <span class="number">60</span> ;</span><br><span class="line">minute = minute2 - minute1 ;</span><br><span class="line">hour = minute / <span class="number">60</span> ;</span><br><span class="line">minute = minute % <span class="number">60</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d时%d分&quot;</span> , hour , minute) ;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a><FONT COLOR = Cyan>运算符优先级</font></h2><p>　　单目运算符优先级是最高的，其次是四则运算，其次是关系运算，其次是逻辑运算，赋值运算最低。</p><p><a href="https://imgtu.com/i/6NGIPA"><img src="https://s3.ax1x.com/2021/03/11/6NGIPA.png" alt="6NGIPA.png"></a></p><p>　　单目不变 + ，a *+ b<br>　　单目取负 - ， a *- b ，这里实际上是 a 乘以负 b 。<br>　　单目递增 ++ ，单目递减 –：自加1和自减1是单目运算符，但他们的算子必须是变量。</p><p>　　<FONT COLOR = PowderBlue size = 4><strong>自加1和自减1的前缀后缀</strong></font>：<br>　　a++的值是a加1以前的值，而++a的值是加1以后的值，无论哪个，a自己都加1了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a++=%d\n&quot;</span>, a++ ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;++a=%d\n&quot;</span>, ++a ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a++ ) ;</span><br></pre></td></tr></table></figure><p>　　结果分别是10、11 、12、12</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span> ;</span><br><span class="line">b = a++ ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>,a,b);</span><br></pre></td></tr></table></figure><p>　　结果是 a = 11 、 b = 10 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span> ;</span><br><span class="line">a++ ;</span><br><span class="line">b = a ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>,a,b);</span><br></pre></td></tr></table></figure><p>　　结果是 a = 11 、 b = 11。</p><p>　　从这里可以看出<FONT COLOR = LimeGreen>前缀表达式的值是原来的值，但表达后的结果是自加1或者自减1。</font><br>　　<a href="https://imgtu.com/i/68dSTH"><img src="https://s3.ax1x.com/2021/03/09/68dSTH.png" alt="68dSTH.png"></a></p><h2 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a><FONT COLOR = Cyan>复合赋值</font></h2><p>　　五个算数运算符 + - * / % 可以和赋值运算符结合起来，形成符合赋值： total += 5 ; 和 total = total +5 ; 是一回事。特别注意，两个运算符中间不能有空格。</p><p>　　total += ( sum + 100 ) / 2 ; 等价于 total = total + ( sum + 100 ) / 2 ;<br>　　total *= sum + 12 ; 等价于 total = total * ( sum + 12 ) ;</p><p>　　从这里可以看出来，符合赋值的优先级是类似赋值运算的优先级的。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a><FONT COLOR = SpringGreen>习题</font></h1><h2 id="逆序的三位数"><a href="#逆序的三位数" class="headerlink" title="逆序的三位数"></a><FONT COLOR = Cyan>逆序的三位数</font></h2><p>　　程序每次读入一个正三位数，然后输出逆序的数字。注意，当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> a1 , a2 ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;a ) ;</span><br><span class="line">a1 = a % <span class="number">10</span> ;</span><br><span class="line">a = a / <span class="number">10</span> ;</span><br><span class="line">a2 = a % <span class="number">10</span> ;</span><br><span class="line">a = a / <span class="number">10</span> ;</span><br><span class="line">a = a1 * <span class="number">100</span> + a2 * <span class="number">10</span> + a ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a) ;</span><br></pre></td></tr></table></figure><p>　　提示：用%10可以得到个位数，用/10可以去掉个位数，三位数/100可以得到首位数。将这样得到的三个数字合起来：百位<em>100+十位</em>10+个位，就得到了结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;计算&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 01 Introduction</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/01/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2001%20Introduction/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/01/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2001%20Introduction/</id>
    <published>2021-03-01T08:19:46.000Z</published>
    <updated>2021-03-29T04:01:04.928Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>程序设计与C语言</FONT></p><a id="more"></a><h1 id="计算机和编程语言"><a href="#计算机和编程语言" class="headerlink" title="计算机和编程语言"></a><FONT COLOR = SpringGreen>计算机和编程语言</font></h1><h2 id="关于编程语言和计算机"><a href="#关于编程语言和计算机" class="headerlink" title="关于编程语言和计算机"></a><FONT COLOR = Cyan>关于编程语言和计算机</font></h2><p><FONT COLOR = PowderBlue size = 4><strong>计算机里的CPU可以直接运行人类编写的程序吗？</strong></font></p><p>　　CPU = Center Processing Units 指的是中央处理器，是计算机的硬件组成部分。硬件（可以看作是电子原件）只有开和关的实现功能，也可以说CPU只能处理开和关的信号（语言）。所以CPU硬件只能处理机器之间的语言（机器语言），或者说CPU只能处理它所在的计算机给它的指令语言而不能直接处理人类编写的程序。人编写的高级语言是由软件转化为汇编语言，再由操作系统转化为机器语言执行的。</p><p><FONT COLOR = PowderBlue size = 4><strong>为什么说编程语言不是和计算机交谈的语言？</strong></font></p><p>　　人类编写的编程语言是为了便于人类看懂，又方便计算机识别及处理的语言。计算机通过识别后，进入执行状态执行人类编写的编程语言。编程语言是指令集合，指示计算机执行指令，这不存在交流的过程。</p><h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a><FONT COLOR = Cyan>程序的执行</font></h2><p>　　解释执行：借助一个程序，那个程序能试图理解人类的代码，然后按照代码执行。</p><p>　　编译执行：借助一个程序，把人来的代码翻译成计算机能懂的语言：用机器语言写的程序。这个用机器语言写的程序就可以执行了。</p><p>　　语言本无编译、解释之分。任何一种语言既可以解释执行也可以编译执行，只是传统和习惯的问题。常用的语言来说，C是编译性语言，Python是解释性语言。<br>　　解释和编译都只是常用的执行方式而已。<br>　　解释性语言有特殊的计算能力，运行效率比编译性要慢。<br>　　编译性语言有确定的运算性能。</p><p><FONT COLOR = PowderBlue size = 4><strong>编译执行与解释执行</strong></font></p><p><FONT COLOR = PowderBlue >　　有的编程语言，源代码经过编译后形成目标代码，但是这样的目标代码不能直接在CPU上执行，而是需要由一个仿真器程序来解释执行。这样的执行方式是编译的还是解释的？</font></p><p>　　我认为是编译+解释：<br>　　如Java是需要编译的，但是没有直接编译成机器语言，而是编译成字节码，然后在Java虚拟机上用解释的方式执行字节码，Python也是使用了类似的方式。</p><h1 id="C语言介绍"><a href="#C语言介绍" class="headerlink" title="C语言介绍"></a><FONT COLOR = SpringGreen>C语言介绍</font></h1><p>　　C语言在工业界有重要的地位，在很多领域无可替代，几乎所有和硬件打交道的地方都得要用C语言。</p><p>　　C语言是伴随着Unix一起起来的，作为一个有着40多年历史的语言，它是当代很多新兴语言的基础参考体系，但是它也无可避免地带着1970年代的时代烙印。今天的编程语言，基本上都是一家主持的，标准统一，编译运行环境单纯。而C语言只有所谓的标准，每个实现C语言编译器和运行库的厂家都在往里面加入自己的方言。</p><h2 id="为什么选择C？"><a href="#为什么选择C？" class="headerlink" title="为什么选择C？"></a><FONT COLOR = Cyan>为什么选择C？</font></h2><p>　　现代的编程语言在语法上的差异非常小。几乎都是C-like语言。<br>　　语言的能力以及适用领域主要是由库和传统决定的。</p><h2 id="C的发展与版本"><a href="#C的发展与版本" class="headerlink" title="C的发展与版本"></a><FONT COLOR = Cyan>C的发展与版本</font></h2><p>　　1989年ANSI（美国国家标准学会，AMERICAN NATIONAL STANDARDS INSTITUTE）发布了一个标准——ANSI C。<br>　　1990年ISO（国际标准化组织，International Organization for Standardization）接受了ANSI的标准——C89<br>　　C的标准在1995年和1999年两次更新——C95和C99，所有的当代编译器都支持C99。<br>　　C语言标准的最新版本是2011年的C11，但是目前编译器支持得最好的是1999年的C99。我们会按照C99来展开教学。国内很多大学，包括所谓的二级考试，还在坚持更老的ANSI C，所以在课程中，凡是C99和ANSI C不同的地方，我们都做了特别的标注。</p><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a><FONT COLOR = SpringGreen>第一个程序</font></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双引号的内容叫做“字符串”，printf会把其中的内容原封不动地输出<br>\n表示需要在输出的结果后面换一行，相当于输出一个换行符。</p><h2 id="做点计算"><a href="#做点计算" class="headerlink" title="做点计算"></a><FONT COLOR = Cyan>做点计算</font></h2><p><code>printf(&quot;%d\n&quot;,23 + 46);</code></p><p>%d说明后面有一个整数要输出在这个位置上</p><p><a href="https://imgchr.com/i/yrRhZQ"><img src="https://s3.ax1x.com/2021/02/13/yrRhZQ.png" alt="yrRhZQ.png"></a></p><h2 id="我们是在学习GCC吗？"><a href="#我们是在学习GCC吗？" class="headerlink" title="我们是在学习GCC吗？"></a><FONT COLOR = Cyan>我们是在学习GCC吗？</font></h2><p><FONT COLOR = PowderBlue >　　常听到有人说他学的是Visual C，有人学的是Turbo C，不是我们学的什么Dev C，是他们的比我们的高级吗？<br>　　<br>还有GCC到底是什么？</font></p><p>　　Microsoft Visual C++ 6.0是一款学习C语言应用软件，Turbo C是美国Borland公司的编译程序。Visual C, Turbo C，Dev c这些只是不同的编程环境而已，没有高低级之分。但不同的开发环境可能对编程人员的感觉是不一样的，DEV C的操作总体比较便捷，它更容易安装，并且占的内存不大。</p><p>　　C语言属于高级语言，要通过编译生成目标程序，再通过连接库函数等来生成可执行文件，而编译的过程就需要通过编译器来实现。GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言编译器。GCC的初衷是为GNU操作系统专门编写一款编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，甚至在微软的Windows上也可以使用GCC。</p><h2 id="main-的样子"><a href="#main-的样子" class="headerlink" title="main()的样子"></a><FONT COLOR = Cyan>main()的样子</font></h2><p><FONT COLOR = PowderBlue >　　为什么看到有的书上的main()是void main()，而我们课件上是int main()？<br>　　还有main()里面那句return 0;是必须的吗？</font></p><p>　　在《C Primer Plus》这本书里，对这件事有细致的描述。<br>　　<code>void main()</code>表示主函数没有返回值，可以不加return，有一些编译器是认可这种写法的，但是所有的标准都不认可这样的写法，有的编译器void main()可以通过编译，但在其他编译器就会报错，所以最好不要这样写。在void main（）下return语句返回一个值的话会报错，如果就只是一个return；表示程序结束不继续往下执行。<br>　　<code>int main()</code>表示主函数返回值为整型，可加return 0；返回一个值看是否为0来判断程序是否正常退出（返回值 整型是有取值范围的 尝试了过大会导致程序报错）。这种写法在C 90标准中被勉强接受，但是C 99和C 11标准并不允许这样写。它们仍然可以被正常编译使用的原因是我们的编译器允许这样写。但是书中明确指出，为了使我们的程序有良好的移植性，最好使用以下更为标准的写法。<br>　　在main函数中，return语句的作用在于离开main函数。尝试不加return 0 也可正常运行（但这是不太好的写法） ，了解到是编译器为我们校正默认添加了return 0 放在别的地方可能会出错。有的编译器必须main要有返回值 int ，那就写成int main 后面加return。<br>　　<code>int main(void)</code>是更为标准的写法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;程序设计与C语言&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>克疾文轩</title>
  
  <subtitle>徐思远的记录空间</subtitle>
  <link href="https://github.com/XuSiyuan-cn/atom.xml" rel="self"/>
  
  <link href="https://github.com/XuSiyuan-cn/"/>
  <updated>2021-05-07T08:16:37.417Z</updated>
  <id>https://github.com/XuSiyuan-cn/</id>
  
  <author>
    <name>XuSiyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021下半年TU计划</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/14%202021%E4%B8%8B%E5%8D%8A%E5%B9%B4TU%E8%AE%A1%E5%88%92/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/14%202021%E4%B8%8B%E5%8D%8A%E5%B9%B4TU%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-06T20:00:00.000Z</published>
    <updated>2021-05-07T08:16:37.417Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！搞个大新闻</FONT></p><a id="more"></a><h1 id="101"><a href="#101" class="headerlink" title="101"></a><FONT COLOR = SpringGreen>101</font></h1><ul><li>核心考案+1000题（铅笔做题，水笔记笔记+大牙考研视频）+思维导图</li><li>1000题第二遍</li><li>冲刺背诵手册（看大牙推荐谁的，陆寓丰 or 徐涛）</li><li>1000题第三遍</li><li>看一下公众号：木易木子的肖4、肖8辅助背诵资料</li><li>肖8（选择题考试 + 分析题自己整理模板），背诵肖8分析题</li><li>肖4</li><li>在记乎app上背诵各路老师的政治预测卷的选择题</li></ul><h1 id="201"><a href="#201" class="headerlink" title="201"></a><FONT COLOR = SpringGreen>201</font></h1><ul><li>考研英语真题手译：阅读+翻译+长难句</li><li>于慧真题100篇</li><li>考研英语阅读理解蓝皮书</li><li>黄皮书真题解析</li><li>新东方真题解析</li><li>英语二试卷模考</li><li>英语一试卷模考</li></ul><h1 id="301"><a href="#301" class="headerlink" title=" 301"></a><FONT COLOR = SpringGreen> 301</font></h1><ul><li>660</li><li>狮子AB</li><li>李正元复习全书</li><li>陈文灯复习全书（到时候淘宝买一本）</li><li>李永乐线代讲义</li><li>张宇概率论讲义</li><li>狮子真题+狮子真题串讲梳理视频</li><li>狮子分考点真题解析</li><li>李永乐真题，重点关注薄弱章节</li><li>蔡燧林《考研数学辅导讲义》</li><li>陈维新《线性代数专题剖析》</li><li>余丙森《概率论辅导讲义》</li><li>李林880</li><li>1100题</li><li>各种试卷：合工大往年共创+超越；重点关注薄弱章节</li><li>考研数学笔记</li></ul><h1 id="912预习"><a href="#912预习" class="headerlink" title="912预习"></a><FONT COLOR = SpringGreen>912预习</font></h1><ul><li>王道历年真题</li><li>王道模拟题、天勤模拟题</li><li>王道——计算机专业基础综合考试名校真题解析</li></ul><h1 id="912"><a href="#912" class="headerlink" title="912"></a><FONT COLOR = SpringGreen>912</font></h1><h2 id="数算70"><a href="#数算70" class="headerlink" title="数算70"></a><FONT COLOR = Cyan>数算70</font></h2><p>　　往年的真题和一些清华的期中期末试题，清华课上内容，清华PPT，清华教材与辅导书</p><p>　　说明：往年的真题以及清华的其中期末试题都可以在一些论坛以及github上找到，大家不需要到淘宝上购买。以上罗列的资料非常重要，需要重点学习。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>BBST（红黑 / AVL/Splay/B 树）</td><td>★★★</td><td>★★</td><td>★★★★</td><td>★★</td><td>★★</td></tr><tr><td>散列表</td><td>★</td><td>★</td><td>★★</td><td>★</td><td>★★★</td></tr><tr><td>BST 遍历 / PFS</td><td>★★★★x2</td><td>★★★★★★</td><td></td><td>★★★★★★</td><td>★★★×3</td></tr><tr><td>排序（冒 / 插 / 选 / 基 / 归 / 锦 / 败、CBA）</td><td>★★★★</td><td>★★★★★</td><td>★★</td><td>★★★★</td><td>★★</td></tr><tr><td>串匹配（KMP/BM）</td><td>★★</td><td>★★</td><td>★★</td><td>★</td><td></td></tr><tr><td>复杂度</td><td>★</td><td>★</td><td>★★</td><td>★</td><td></td></tr><tr><td>编码树（Huffman/PFC）</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>RPN</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>减治</td><td></td><td></td><td>★★★</td><td></td><td>★★★</td></tr><tr><td>Catalan</td><td>★</td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>堆（完全、左式堆）</td><td>★★★★★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>栈（调用栈、栈混洗）</td><td></td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>Dijkstra 算法</td><td></td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>跳转表</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>二分、Fib 查找</td><td></td><td></td><td>★★★★★</td><td></td><td></td></tr><tr><td>最小生成树（Prim）</td><td></td><td></td><td></td><td></td><td>★★★</td></tr><tr><td>非法表达式</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>逻辑地址</td><td></td><td></td><td></td><td></td><td>★</td></tr></tbody></table><h2 id="操作系统30"><a href="#操作系统30" class="headerlink" title="操作系统30"></a><FONT COLOR = Cyan>操作系统30</font></h2><p>　　期中期末考题与课件：<a href="http://os.cs.tsinghua.edu.cn/oscourse/FrontPage">http://os.cs.tsinghua.edu.cn/oscourse/FrontPage</a></p><p>　　期中期末考试答案：<a href="https://zhanghuimeng.github.io/">https://zhanghuimeng.github.io</a></p><p>　　simple_os_book、ucore_os_docs、操作系统课程练习：<a href="https://legacy.gitbook.com/@chyyuu">https://legacy.gitbook.com/@chyyuu</a></p><p>　　管程：在912中不止一次考过管程的详细知识。在课程中陈渝老师提到管程是可以让同步互斥的代码不用分散在四处，但是代码中还是两个部分，这里有很多同学产生了困惑，因为这里看起来和PV操作没有什么区别，如<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/kkkkkk/p/5543799.html">这位同学在博客中提到</a></p><p>　　后来经过阅读指导手册的<a href="https://link.zhihu.com/?target=https://chyyuu.gitbooks.io/ucore_os_docs/content/lab7/lab7_3_4_monitors.html">管程和条件变量</a>这一节，我才恍然大悟：管程就是一个类，把所有的同步互斥都当成类方法写在这个类里，类外面加一个锁，只有一个线程能进来。后来又翻到网友写的<a href="https://link.zhihu.com/?target=https://blog.csdn.net/ljbdream00/article/details/83501948">信号量和管程区别</a>也可以帮助理解。</p><p>　　说明：操作系统课程难度大，想要得高分需要投入巨大的时间和精力。其ucore实验部分对于跨考生是极不友好的，大家量力而行，合理取舍。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>uCore 代码</td><td>★★★</td><td>★★★★</td><td>★★★</td><td>★★★</td><td></td></tr><tr><td>虚 / 实地址 (转换 / 扩展)</td><td></td><td>★★★</td><td>★★★</td><td>★★★</td><td></td></tr><tr><td>进程控制 / 系统调用</td><td>★★★★</td><td></td><td>★★★</td><td>★</td><td>★</td></tr><tr><td>管程</td><td></td><td></td><td>★★★★★</td><td>★</td><td></td></tr><tr><td>belady</td><td>★</td><td></td><td>★★★</td><td>★</td><td></td></tr><tr><td>x86 硬件</td><td>★</td><td>★★</td><td></td><td>★</td><td></td></tr><tr><td>信号量</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>死锁</td><td>★</td><td>★</td><td></td><td></td><td>★</td></tr><tr><td>线程</td><td></td><td>★</td><td></td><td>★</td><td>★</td></tr><tr><td>文件系统</td><td>★★★</td><td></td><td></td><td></td><td>★★★</td></tr><tr><td>调度算法</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>僵尸 / 孤儿进程</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>中断</td><td></td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>Cache</td><td>★</td><td></td><td></td><td></td><td>★</td></tr><tr><td>哲学家就餐</td><td></td><td></td><td>★★★</td><td></td><td></td></tr><tr><td>硬 / 软链接</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>stride 算法</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>x86 特权级</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>优先级反置</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>伙伴系统</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>自旋锁</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>动态分区算法</td><td></td><td></td><td></td><td>★</td><td></td></tr><tr><td>RAID</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><h2 id="组原30’"><a href="#组原30’" class="headerlink" title="组原30’"></a><FONT COLOR = Cyan>组原30’</font></h2><p>　　往年真题与清华期中期末试题，刘卫东PPT</p><p>说明：MIPS汇编和流水线时间计算是组成原理中的难点，但又是考察的重点。</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>流水线相关计算</td><td>★★★★</td><td>★★★</td><td>★★★</td><td></td><td>★★★</td></tr><tr><td>流水线冲突</td><td>★</td><td>★★★</td><td>★★</td><td>★★★</td><td></td></tr><tr><td>浮点数表示</td><td>★</td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>Cache 缺失 / 映射</td><td>★★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>RAID</td><td>★</td><td>★★</td><td>★</td><td></td><td></td></tr><tr><td>补码表示</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>CPU 指标 (CPI / 主频)</td><td>★</td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>Cache 相关计算</td><td>★★</td><td></td><td></td><td>★★★</td><td></td></tr><tr><td>指令的概念</td><td>★</td><td></td><td></td><td>★★</td><td></td></tr><tr><td>异常处理 / 中断</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>虚拟内存</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>C 语言</td><td></td><td>★</td><td>★</td><td></td><td></td></tr><tr><td>总线</td><td></td><td>★</td><td></td><td>★</td><td></td></tr><tr><td>显存带宽计算</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>RAM</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>冯诺依曼架构</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>时序 / 组合逻辑</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>海明码检错 / 纠错</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><h2 id="网络原理20’"><a href="#网络原理20’" class="headerlink" title="网络原理20’"></a><FONT COLOR = Cyan>网络原理20’</font></h2><p>往年的912真题和清华期中期末考题</p><p>说明：这一部分分值不高但是考察的简单，投入较少的时间便能拿到很好的分数。</p><p> 海明码的计算</p><p>统考中3个校验位，4个数据位</p><p>清华考试：4个校验位（包含一个总校验位），3个数据位</p><p>流水线时间</p><p>统考中只有每段的流水时间</p><p>清华这里考虑了每段中间的寄存器时间</p><p>RIP路由协议</p><p>清华这里在RIP协议中有一个水平分割技术：路由器从某个接口接收到的更新信息不允许再从这个接口发回去</p><table><thead><tr><th>考点</th><th>2020</th><th>2019</th><th>2018</th><th>2017</th><th>2016</th></tr></thead><tbody><tr><td>TCP (拥塞 / 握手 / 报文等)</td><td>★★★</td><td>★★</td><td>★★</td><td></td><td>★★★</td></tr><tr><td>路由器计算</td><td></td><td>★★★</td><td>★★★</td><td>★★★</td><td>★★★</td></tr><tr><td>信道利用率</td><td></td><td>★</td><td>★</td><td>★</td><td></td></tr><tr><td>ARQ (停等 / 后退 / 选择)</td><td>★</td><td>★</td><td>★★</td><td></td><td></td></tr><tr><td>HTTP</td><td></td><td>★★★</td><td></td><td>★</td><td></td></tr><tr><td>网桥转发</td><td>★</td><td></td><td>★★★</td><td></td><td></td></tr><tr><td>ARP</td><td>★★★</td><td></td><td></td><td></td><td></td></tr><tr><td>物理层设备</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>调制 / 解调</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>水平分裂</td><td>★</td><td></td><td></td><td></td><td></td></tr><tr><td>蜂窝</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>最小帧长</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>以太网</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>分组转发</td><td></td><td>★</td><td></td><td></td><td></td></tr><tr><td>OSI&amp;TCP/IP</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>奈奎斯特定理</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>数据链路层概念</td><td></td><td></td><td>★</td><td></td><td></td></tr><tr><td>DNS</td><td>★</td><td></td><td>★</td><td></td><td></td></tr><tr><td>SMTP</td><td></td><td></td><td></td><td>★</td><td></td></tr><tr><td>SNMP</td><td></td><td></td><td></td><td>★</td><td></td></tr></tbody></table><hr><p>各个学校考研真题：<a href="https://github.com/csseky/cskaoyan">https://github.com/csseky/cskaoyan</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！搞个大新闻&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年疾风计划</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/13%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%96%BE%E9%A3%8E%E8%AE%A1%E5%88%92/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/13%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%96%BE%E9%A3%8E%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-06T19:00:00.000Z</published>
    <updated>2021-05-07T08:15:17.467Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！注重效率</FONT></p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><FONT COLOR = SpringGreen>基础</font></h1><h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a><FONT COLOR = Cyan>语言基础</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>C</strong></font></p><p>《C primer plus》</p><ul><li>浙大，程序设计入门C语言</li><li>浙大，C语言程序设计进阶</li><li>B站 VS C</li><li>经典 100题</li><li>谭浩强</li><li>贪吃蛇</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Java</strong></font></p><ul><li>浙大，零基础学Java语言</li><li>浙大，面向对象程序设计——Java语言</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Python</strong></font></p><ul><li><p>浙大，Python程序设计</p></li><li><p>北理，Python全家桶</p></li><li><p>Python语言程序设计:AV77405880</p></li><li><p>数据分析与展示:AV73025184</p></li><li><p>科学计算三维可视化:AV73059189</p></li><li><p>机器学习应用:AV73055836</p></li><li><p>网络爬虫与信息提取:AV73060821</p></li><li><p>云端系统开发:AV73032036</p></li><li><p>游戏开发:AV73028956</p></li><li><p>MIT 6.0001</p></li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>C/C++</strong></font></p><p>《C++ Primier》《effective c++》</p><ul><li>北大，计算概论</li><li>北大，程序设计与算法（一）（二）（三）</li><li>北大，程序设计实习</li><li>清华：面向对象程序设计（C++）</li><li>清华，VC++面向对象与可视化程序设计（上）：Windows编程基础</li><li>清华，VC++面向对象与可视化程序设计（下）：MFC编程基础</li><li>侯捷 C++：BV1Ce411x77G  BV1tg4y1872m </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>经典总结</strong></font></p><ul><li>《计算机程序的构造和解释》 + Berkeley 61A，</li><li>Brian Harvey ：BV1Xx41117tr</li><li>学习资料：<a href="https://github.com/DeathKing/Learning-SICP">https://github.com/DeathKing/Learning-SICP</a></li></ul><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a><FONT COLOR = Cyan>汇编基础</font></h2><ul><li>清华 学堂在线 汇编语言程序设计　　</li></ul><h2 id="数电模电"><a href="#数电模电" class="headerlink" title="数电模电"></a><FONT COLOR = Cyan>数电模电</font></h2><p>阎石 《数字电子技术基础》</p><ul><li>国防科大 数字电子技术基础 </li><li>华科 数字电路与逻辑设计</li><li>华科 数字电子技术基础</li><li>华科 模拟电子技术基础</li><li>清华王红 数字电路 BV1F5411t7Cj</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><FONT COLOR = Cyan>补充</font></h2><ul><li><p>万门 大学 计算机科学一月特训班</p></li><li><p>万门大学人工智能一月特训班</p></li><li><p>万门大学数据挖掘一月特训班</p></li></ul><h2 id="912预习"><a href="#912预习" class="headerlink" title="912预习"></a><FONT COLOR = Cyan>912预习</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数据结构预习</strong></font></p><ul><li>阅读：《大话数据结构》、《算法图解》</li><li>武大数据结构教材+浙大数据结构慕课+浙大编程题</li><li>《算法设计手册》 + 斯坦福算法专项 <a href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>组成原理预习</strong></font></p><p>《组成原理黑书》</p><ul><li>华科计算机组成原理</li><li>华科计算机系统结构</li><li>华科慕课计算机硬件系统设计</li><li>计算机原理 国防科技大学 唐玉华</li><li>计算机组成原理 哈工大 刘宏伟 </li><li>北大 组成原理</li><li>袁春风两本书：《计算机组成与系统结构》+《计算机系统基础》+南大袁春风三门课+唐朔飞习题指导+袁春风教材课后练习题</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>操作系统预习</strong></font></p><p>《操作系统导论》《现代操作系统》</p><ul><li>计算机操作系统 南大 骆斌</li><li>操作系统 浙江大学 MOOC</li><li>操作系统原理 哈工大  </li><li>操作系统实验：<a href="https://www.lanqiao.cn/courses/115">https://www.lanqiao.cn/courses/115</a></li><li>伯克利 CS 162</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>计网预习</strong></font></p><p>《自顶向下》</p><ul><li>网络技术与应用 南京邮电</li><li>计算机网络 哈工大 李全龙</li><li>中科大自顶向下：BV1JV411t7ow</li><li>斯坦福计算机网络：BV1wt41167iN</li></ul><h1 id="专业基础课"><a href="#专业基础课" class="headerlink" title="专业基础课"></a><FONT COLOR = SpringGreen>专业基础课</font></h1><h2 id="程序设计基础"><a href="#程序设计基础" class="headerlink" title="程序设计基础"></a><FONT COLOR = Cyan>程序设计基础</font></h2><p>C++语言程序设计基础</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><FONT COLOR = Cyan>面向对象</font></h2><ul><li>C++语言程序设计进阶</li><li>面向对象程序设计（C++）</li></ul><h2 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a><FONT COLOR = Cyan>离散数学</font></h2><h1 id="专业必修"><a href="#专业必修" class="headerlink" title="专业必修"></a><FONT COLOR = SpringGreen>专业必修</font></h1><h2 id="⭐数据结构"><a href="#⭐数据结构" class="headerlink" title="⭐数据结构"></a><FONT COLOR = Cyan>⭐数据结构</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习段</strong></font>：</p><ul><li>新东方（淘宝、PDD、咸鱼，买去年的）：数算巩固阶段（赵海英）+巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华段</strong></font>：</p><ul><li>清华教材+清华的课+武大教材+清华习题解析</li><li>visualgo可视化学习算法、实验楼动手实验</li><li>清华电子稿与示例代码:<a href="https://link.zhihu.com/?target=https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/">https://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp</a></li><li>注意看学堂在线慕课讨论区</li><li>《数据结构精讲与习题详解——考研辅导与答疑解惑 殷人昆》</li><li>《数据结构习题解析第二版（殷人昆）》</li><li>邓俊辉个人网站：<a href="https://dsa.cs.tsinghua.edu.cn/~deng/ds/index.htm">https://dsa.cs.tsinghua.edu.cn/~deng/ds/index.htm</a></li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐算法设计与分析"><a href="#⭐算法设计与分析" class="headerlink" title="⭐算法设计与分析"></a><FONT COLOR = Cyan>⭐算法设计与分析</font></h2><ul><li>北大慕课屈婉玲 + 清华学堂在线王振波 </li><li>《算法笔记》</li><li>《具体数学》</li><li>《算法导论》 MIT算法导论： BV1Tb411M7FA</li><li>《算法》普林斯顿 算法上：BV1Jt411P77c 普林斯顿算法下：BV1M741177FX</li><li>算法训练营</li><li>acwing：y总的《算法基础课》《算法提高课》</li></ul><h2 id="⭐计算机组成原理"><a href="#⭐计算机组成原理" class="headerlink" title="⭐计算机组成原理"></a><FONT COLOR = Cyan>⭐计算机组成原理</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方组成原理（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>《深入理解计算机系统（CSAPP）》，配合B站的课BV1iW411d7hd，实验：<a href="https://github.com/Exely/CSAPP-Labs">https://github.com/Exely/CSAPP-Labs</a></li><li>伯克利 CS61C</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华：</strong></font></p><p>　　清华刘卫东老师的计算机组成原理课的视频与课件</p><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐操作系统"><a href="#⭐操作系统" class="headerlink" title="⭐操作系统"></a><FONT COLOR = Cyan>⭐操作系统</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方操作系统（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>黑书+双汤学习指导</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>基础</strong></font>：</p><ul><li>《Orange’S：一个操作系统的实现》</li><li>《操作系统真象还原》</li><li>《x86汇编语言-从实模式到保护模式》</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华：</strong></font></p><ul><li>清华学堂在线上陈渝和向勇老师讲授的《操作系统》网课</li><li>期中期末考题与课件：<a href="http://os.cs.tsinghua.edu.cn/oscourse/FrontPage">http://os.cs.tsinghua.edu.cn/oscourse/FrontPage</a></li><li>清华simple OS Book：<a href="https://chyyuu.gitbooks.io/simple_os_book/content/">https://chyyuu.gitbooks.io/simple_os_book/content/</a></li><li>OSppt：<a href="https://github.com/LearningOS/os-lectures">https://github.com/LearningOS/os-lectures</a></li><li>清华课程介绍：<a href="https://chyyuu.gitbooks.io/os_course_info/content/">https://chyyuu.gitbooks.io/os_course_info/content/</a></li><li>学习建议：<a href="https://github.com/chyyuu/os_course_info">https://github.com/chyyuu/os_course_info</a></li><li>清华操作系统老版：<a href="https://www.xuetangx.com/course/THU08091000267/5883104">https://www.xuetangx.com/course/THU08091000267/5883104</a></li><li>清华操作系统新版：<a href="https://www.xuetangx.com/course/thu08091002729/3175284">https://www.xuetangx.com/course/thu08091002729/3175284</a></li><li>操作系统实验书：<a href="https://chyyuu.gitbooks.io/simple_os_book/content/">https://chyyuu.gitbooks.io/simple_os_book/content/</a></li><li>清华ucore实验指导书（2015）：<a href="https://objectkuan.gitbooks.io/ucore-docs/content/">https://objectkuan.gitbooks.io/ucore-docs/content/</a></li><li>清华ucore实验指导书（2020）：<a href="https://learningos.github.io/ucore_os_webdocs/">https://learningos.github.io/ucore_os_webdocs/</a></li><li>ucore在线实验：<a href="https://www.lanqiao.cn/courses/221/?show_merge_modal=true">https://www.lanqiao.cn/courses/221/?show_merge_modal=true</a></li><li>rcore参考书第二版：<a href="https://rcore-os.github.io/rCore_tutorial_doc/">https://rcore-os.github.io/rCore_tutorial_doc/</a></li><li>rcore参考书第三版：<a href="https://rcore-os.github.io/rCore-Tutorial-deploy/">https://rcore-os.github.io/rCore-Tutorial-deploy/</a></li><li>清华教务处课程主页（期中期末题目）：<a href="http://os.cs.tsinghua.edu.cn/oscourse/">http://os.cs.tsinghua.edu.cn/oscourse/</a></li><li>清华期中期末习题解析，张木辉博客：<a href="https://zhanghuimeng.github.io/">https://zhanghuimeng.github.io</a></li><li>操作系统习题集：<a href="https://chyyuu.gitbooks.io/os_course_exercises/content/">https://chyyuu.gitbooks.io/os_course_exercises/content/</a></li><li>操作系统题库：<a href="https://github.com/chyyuu/os_course_exercise_library">https://github.com/chyyuu/os_course_exercise_library</a></li><li>清华ucore笔记：<a href="https://github.com/XuSiyuan-cn/lcore">https://github.com/XuSiyuan-cn/lcore</a></li><li>注意看学堂在线慕课讨论区：pizza</li><li>清华操作系统课程问答：<a href="https://xuyongjiande.gitbooks.io/os-qa/content/index.html">https://xuyongjiande.gitbooks.io/os-qa/content/index.html</a></li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="⭐计算机网络"><a href="#⭐计算机网络" class="headerlink" title="⭐计算机网络"></a><FONT COLOR = Cyan>⭐计算机网络</font></h2><p>学习的时候记得配套：清华计算机系详情：<a href="https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT">https://github.com/XuSiyuan-cn/REKCARC-TSC-UHT</a></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>预习</strong></font>：</p><ul><li>新东方操作系统（淘宝、PDD、咸鱼，买去年的）：巩固阶段视频+强化演练（先做题在看视频）+冲刺模考（先做题）</li><li>文都（到时候可能去找最新的）：文都强化课+真题精讲（先做真题看看）+习题特训（先做题）+阶段测试（先做题）</li><li>王道：视频+书</li><li>黑书+《TCP/IP详解卷1：协议》+谢希仁学习指导</li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>清华</strong></font>：</p><ul><li>清华大学徐明伟老师的计算机网络课程的课件</li><li>MIT6.033</li><li>斯坦福大学计算机网络 CS144</li></ul><p><strong>红笔记录清华相关事宜</strong></p><h2 id="912阶段性总结"><a href="#912阶段性总结" class="headerlink" title="912阶段性总结"></a><FONT COLOR = Cyan>912阶段性总结</font></h2><ul><li>N诺专业题库</li><li>N诺兑换中心机考两本书</li><li>N诺历年真题</li></ul><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><FONT COLOR = Cyan>数据库系统</font></h2><ul><li>疾风计划</li><li>数据库系统原理与开发</li><li>哈工大 数据库系统概念</li><li>尚硅谷：BV12b411K7Zu</li><li>伯克利 CS186 BV12x411n7AC</li><li>前沿论文集锦：《Architecture of a Database System》</li></ul><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a><FONT COLOR = Cyan>编译原理</font></h2><p>《Crafting Interpreters》：<a href="https://craftinginterpreters.com/contents.html">https://craftinginterpreters.com/contents.html</a></p><ul><li>疾风计划</li><li>哈工大慕课</li></ul><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a><FONT COLOR = Cyan>软件工程</font></h2><h2 id="算法竞赛预备"><a href="#算法竞赛预备" class="headerlink" title="算法竞赛预备"></a><FONT COLOR = Cyan>算法竞赛预备</font></h2><ul><li>刘汝佳算法三件套  </li><li>《剑指offer》 牛客网上有OJ  </li><li>《编程珠玑》  </li><li>《编程之美》</li><li>LeetCode 刷题+《LeetCode刷题手册（@ PC）》</li><li>考浙大PAT、CCF认证，PAT笔记：<a href="https://ivenwang.com/2019/09/05/pat/">https://ivenwang.com/2019/09/05/pat/</a></li></ul><h1 id="专业选修"><a href="#专业选修" class="headerlink" title="专业选修"></a><FONT COLOR = SpringGreen>专业选修</font></h1><h2 id="linux操作系统"><a href="#linux操作系统" class="headerlink" title="linux操作系统"></a><FONT COLOR = Cyan>linux操作系统</font></h2><ul><li>《C语言中文网学学linux教程》   </li><li>慕课：操作系统与Linux内核</li><li>学堂在线：Linux内核分析与应用</li><li>疾风计划</li><li>《linux内核设计与实现》<br>《鸟哥的linux私房菜》   </li></ul><h2 id="嵌入式系统"><a href="#嵌入式系统" class="headerlink" title="嵌入式系统"></a><FONT COLOR = Cyan>嵌入式系统</font></h2><p>　　微控制器与嵌入式系统</p><h2 id="网络安全技术"><a href="#网络安全技术" class="headerlink" title="网络安全技术"></a><FONT COLOR = Cyan>网络安全技术</font></h2><h2 id="软件理论基础"><a href="#软件理论基础" class="headerlink" title="软件理论基础"></a><FONT COLOR = Cyan>软件理论基础</font></h2><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a><FONT COLOR = Cyan>软件测试</font></h2><h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a><FONT COLOR = Cyan>数据挖掘</font></h2><p>　　数据挖掘：理论与算法</p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a><FONT COLOR = Cyan>人工智能</font></h2><p>《人工智能 一种现代方法》 + 伯克利AI：<a href="http://ai.berkeley.edu/home.html">http://ai.berkeley.edu/home.html</a>  </p><ul><li>大数据机器学习</li><li>人工智能原理</li><li>深度学习基础</li></ul><h2 id="大数据系统"><a href="#大数据系统" class="headerlink" title="大数据系统"></a><FONT COLOR = Cyan>大数据系统</font></h2><p>　　大数据平台核心技术</p><h2 id="物联网概论"><a href="#物联网概论" class="headerlink" title="物联网概论"></a><FONT COLOR = Cyan>物联网概论</font></h2><h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a><FONT COLOR = Cyan>组合数学</font></h2><h1 id="综合实践"><a href="#综合实践" class="headerlink" title="综合实践"></a><FONT COLOR = SpringGreen>综合实践</font></h1><h2 id="科研预备"><a href="#科研预备" class="headerlink" title="科研预备"></a><FONT COLOR = Cyan>科研预备</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>西瓜书</strong></font>：  </p><ul><li>《西瓜书手推笔记》（@PC）</li><li>一起啃书：BV17J411C7zZ  </li><li>南瓜书： <a href="https://github.com/datawhalechina/pumpkin-book%E3%80%81">https://github.com/datawhalechina/pumpkin-book、</a>  </li><li>吴恩达机器学习：<a href="https://study.163.com/course/courseLearn.htm?courseId=1004570029#/learn/video?lessonId=1049052745&amp;courseId=1004570029">https://study.163.com/course/courseLearn.htm?courseId=1004570029#/learn/video?lessonId=1049052745&amp;courseId=1004570029</a>  </li><li>吴恩达笔记：<a href="https://github.com/fengdu78/deeplearning_ai_books">https://github.com/fengdu78/deeplearning_ai_books</a>  </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>统计学习方法</strong></font>：  </p><ul><li>算法实现：<a href="https://github.com/WenDesi/lihang_book_algorithm">https://github.com/WenDesi/lihang_book_algorithm</a>  </li><li>深度之眼视频：BV1i4411G7Xv  </li></ul><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>花书</strong></font>：  </p><ul><li>一起啃书：BV1HJ41177E9  </li><li>深度之眼：BV1kE4119726  </li><li>李宏毅的《深度学习》  +《李宏毅深度学习PPT》@PC+《一天搞懂深度学习（台大李宏毅）》@PC</li></ul><h2 id="斯坦福套餐："><a href="#斯坦福套餐：" class="headerlink" title="斯坦福套餐："></a><FONT COLOR = Cyan>斯坦福套餐</font>：</h2><ul><li>CS231N(计算机视觉)<br>计算机图形学：伯克利CS 184；《计算机图形学 原理及实践》</li><li>CS224D(自然语言处理)</li><li>CS229(机器学习)</li><li>CS230（深度学习）</li><li>CS234（强化学习）</li></ul><h2 id="算法提升"><a href="#算法提升" class="headerlink" title="算法提升"></a><FONT COLOR = Cyan>算法提升</font></h2><ul><li>邓俊辉算法训练营第一期（PC）</li><li>北大算法专项课程（收藏夹）</li><li>斯坦福数算专项（收藏夹）</li><li>加州大学数算专项（收藏夹）</li><li>约翰霍普金斯数据科学专项课程（收藏夹）</li><li>华盛顿大学机器学习专项（收藏夹）</li><li>密歇根大学Python应用专项（收藏夹）</li><li>MIT：算法设计与分析、算法导论、高级数据结构、MIT高级算法</li><li>普林斯顿：算法</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！注重效率&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年301数学</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/12%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4301%E6%95%B0%E5%AD%A6/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/12%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4301%E6%95%B0%E5%AD%A6/</id>
    <published>2021-05-06T18:00:00.000Z</published>
    <updated>2021-05-07T08:12:54.042Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！学好数学</FONT></p><a id="more"></a><h1 id="数分"><a href="#数分" class="headerlink" title="数分"></a><FONT COLOR = SpringGreen>数分</font></h1><ul><li>北大教材（配徐森林、史贤林、清华丘班讲义）</li><li>浙大课程</li><li>狮子课程+狮子讲义</li><li>浙大辅导书</li><li>史老师数分课</li><li>MIT全家桶（单变量微积分、多变量微积分、微积分重点、微分方程、单变量微积分习题课、多变量微积分习题课）</li></ul><h1 id="线代"><a href="#线代" class="headerlink" title="线代"></a><FONT COLOR = SpringGreen>线代</font></h1><ul><li>复旦教材</li><li>科大课程</li><li>狮子课程+狮子讲义</li><li>人大辅导书</li><li>复旦课程+复旦习题课</li><li>MIT全家桶（线性代数、线性代数习题课）</li></ul><h1 id="概统"><a href="#概统" class="headerlink" title="概统"></a><FONT COLOR = SpringGreen>概统</font></h1><ul><li>科大教材+科大课程</li><li>狮子课程+狮子讲义</li><li>北大辅导书（哈佛统计：BV124411P7Rj）</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a><FONT COLOR = SpringGreen>补充</font></h1><ul><li>高昆仑18讲</li><li>李永乐线代</li><li>方浩概统</li><li>高数证明题专题</li><li>主观综合题串讲</li><li>排位考</li><li>3Blue1Brown 的视频</li></ul><h1 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a><FONT COLOR = SpringGreen>数值分析</font></h1><ul><li>华科教材+华科研究生视频</li><li>清华学堂在线，数值分析与算法</li></ul><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a><FONT COLOR = SpringGreen>数学建模</font></h1><ul><li>谢金星教材+清华B站课程</li></ul><h1 id="复变函数"><a href="#复变函数" class="headerlink" title="复变函数"></a><FONT COLOR = SpringGreen>复变函数</font></h1><ul><li>华科教材+华科复变函数的课</li></ul><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a><FONT COLOR = SpringGreen>离散数学</font></h1><ul><li>北大教材+北大视频</li><li>《计算机科学中的数学》：BV1nx411D7xz，MIT</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！学好数学&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>2021上半年201英语</title>
    <link href="https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/11%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4201%E8%8B%B1%E8%AF%AD/"/>
    <id>https://github.com/XuSiyuan-cn/2021/05/07/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/11%202021%E4%B8%8A%E5%8D%8A%E5%B9%B4201%E8%8B%B1%E8%AF%AD/</id>
    <published>2021-05-06T17:00:00.000Z</published>
    <updated>2021-05-07T08:12:53.027Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>2021一定要有所改变！从认真学英语开始！</FONT></p><a id="more"></a><h1 id="基础段"><a href="#基础段" class="headerlink" title="基础段"></a><FONT COLOR = SpringGreen>基础段</font></h1><p>预习→听课→听写→复习笔记</p><ul><li>新3 裕兴</li><li>新4 蒋军虎</li><li>英语语法新思维初级、中级、高级 课+教材</li></ul><h1 id="考研段"><a href="#考研段" class="headerlink" title="考研段"></a><FONT COLOR = SpringGreen>考研段</font></h1><ul><li>商志传奇背词班+蓝皮书</li><li>商志翻译精讲、陈正康翻译+蓝皮书</li><li>李玉技完型、商志完型+蓝皮书</li><li>商志新题型、李玉技新题型+蓝皮书</li><li>石雷鹏作文+商志作文书+朱伟写作宝典+潘赟九宫格+《见山作文模板》。总结出自己的写作模板</li><li>慕课阅读：英语科技文献阅读、大学英语学术阅读、科技英语语法、科技英语</li><li>慕课写作：大学英语写作基础、英语语法与写作、大学英语过程写作</li><li>慕课口语：大学英语（口语）、学术交流英语、通用学术英语</li><li>自学顾家北雅思写作两本书</li></ul><h1 id="雅思段"><a href="#雅思段" class="headerlink" title="雅思段"></a><FONT COLOR = SpringGreen>雅思段</font></h1><ul><li>王陆听力</li><li>剑雅口语</li><li>新东方雅思7分直达（百度网盘）</li><li>万门大学雅思课（百度网盘）</li><li>剑桥雅思10本书，一周精读一本</li></ul><p><strong>学完后去考雅思，目标7.5分</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;2021一定要有所改变！从认真学英语开始！&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="2021" scheme="https://github.com/XuSiyuan-cn/tags/2021/"/>
    
  </entry>
  
  <entry>
    <title>3月的结束</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/24/05%20%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/10%20%E4%B8%89%E6%9C%88%E7%9A%84%E7%BB%93%E6%9D%9F/</id>
    <published>2021-03-23T18:12:28.075Z</published>
    <updated>2021-03-23T18:12:28.262Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>三月快结束啦</FONT></p><a id="more"></a><p>还没准备好呢，今年就已经过去一个季度了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(P的分数高&amp;&amp;科目不变)&#123;</span><br><span class="line">瞄准一波P;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;三月快结束啦&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="克疾之路" scheme="https://github.com/XuSiyuan-cn/categories/%E5%85%8B%E7%96%BE%E4%B9%8B%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Chapter 16 Interactive Graphic Design</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/16/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2016%20Interactive%20Graphic%20Design/</id>
    <published>2021-03-16T13:59:47.000Z</published>
    <updated>2021-03-29T05:41:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>交互图形设计</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;交互图形设计&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 15 ACLLib</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/15/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2015%20ACLLib/</id>
    <published>2021-03-15T13:59:47.000Z</published>
    <updated>2021-04-06T03:09:29.856Z</updated>
    
    <content type="html"><![CDATA[<p>ACLLib的基本图形函数</p><a id="more"></a><h1 id="ACLLib介绍"><a href="#ACLLib介绍" class="headerlink" title="ACLLib介绍"></a><FONT COLOR = SpringGreen>ACLLib介绍</font></h1><h1 id="Win32API"><a href="#Win32API" class="headerlink" title="Win32API"></a><FONT COLOR = SpringGreen>Win32API</font></h1><h1 id="创建ACLLIB程序"><a href="#创建ACLLIB程序" class="headerlink" title="创建ACLLIB程序"></a><FONT COLOR = SpringGreen>创建ACLLIB程序</font></h1><h1 id="基本绘图函数"><a href="#基本绘图函数" class="headerlink" title="基本绘图函数"></a><FONT COLOR = SpringGreen>基本绘图函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;ACLLib的基本图形函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 14 Linked List</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/14/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2014%20Linked%20List/</id>
    <published>2021-03-14T13:59:47.000Z</published>
    <updated>2021-04-06T03:08:20.467Z</updated>
    
    <content type="html"><![CDATA[<p>链表</p><a id="more"></a><h1 id="可变数组"><a href="#可变数组" class="headerlink" title="可变数组"></a><FONT COLOR = SpringGreen>可变数组</font></h1><h1 id="可变数组数据访问"><a href="#可变数组数据访问" class="headerlink" title="可变数组数据访问"></a><FONT COLOR = SpringGreen>可变数组数据访问</font></h1><h1 id="可变数组自动增长"><a href="#可变数组自动增长" class="headerlink" title="可变数组自动增长"></a><FONT COLOR = SpringGreen>可变数组自动增长</font></h1><h1 id="可变数组的缺陷"><a href="#可变数组的缺陷" class="headerlink" title="可变数组的缺陷"></a><FONT COLOR = SpringGreen>可变数组的缺陷</font></h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a><FONT COLOR = SpringGreen>链表</font></h1><h1 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a><FONT COLOR = SpringGreen>链表的函数</font></h1><h1 id="链表的搜索"><a href="#链表的搜索" class="headerlink" title="链表的搜索"></a><FONT COLOR = SpringGreen>链表的搜索</font></h1><h1 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a><FONT COLOR = SpringGreen>链表的删除</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;链表&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 13 File</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/13/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2013%20File/</id>
    <published>2021-03-13T13:59:47.000Z</published>
    <updated>2021-04-06T03:06:42.074Z</updated>
    
    <content type="html"><![CDATA[<p>文件</p><a id="more"></a><h1 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a><FONT COLOR = SpringGreen>格式化输入输出</font></h1><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a><FONT COLOR = SpringGreen>文件输入输出</font></h1><h1 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a><FONT COLOR = SpringGreen>二进制文件</font></h1><h1 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a><FONT COLOR = SpringGreen>按位运算</font></h1><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a><FONT COLOR = SpringGreen>移位运算</font></h1><h1 id="位运算例子"><a href="#位运算例子" class="headerlink" title="位运算例子"></a><FONT COLOR = SpringGreen>位运算例子</font></h1><h1 id="位段"><a href="#位段" class="headerlink" title="位段"></a><FONT COLOR = SpringGreen>位段</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 12 Program Structure</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/12/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2012%20Program%20Structure/</id>
    <published>2021-03-12T13:59:47.000Z</published>
    <updated>2021-04-06T03:05:10.506Z</updated>
    
    <content type="html"><![CDATA[<p>程序结构</p><a id="more"></a><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a><FONT COLOR = SpringGreen>全局变量</font></h1><h1 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a><FONT COLOR = SpringGreen>静态本地变量</font></h1><h1 id="全局变量tips"><a href="#全局变量tips" class="headerlink" title="全局变量tips"></a><FONT COLOR = SpringGreen>全局变量tips</font></h1><h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a><FONT COLOR = SpringGreen>宏定义</font></h1><h1 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a><FONT COLOR = SpringGreen>带参数的宏</font></h1><h1 id="大程序"><a href="#大程序" class="headerlink" title="大程序"></a><FONT COLOR = SpringGreen>大程序</font></h1><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><FONT COLOR = SpringGreen>头文件</font></h1><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><FONT COLOR = SpringGreen>声明</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;程序结构&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 11 Structure Type</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2011%20Structure%20Type/</id>
    <published>2021-03-11T13:59:47.000Z</published>
    <updated>2021-04-06T03:03:15.693Z</updated>
    
    <content type="html"><![CDATA[<p>结构类型</p><a id="more"></a><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><FONT COLOR = SpringGreen>枚举</font></h1><h1 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a><FONT COLOR = SpringGreen>结构类型</font></h1><h1 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a><FONT COLOR = SpringGreen>结构与函数</font></h1><h1 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a><FONT COLOR = SpringGreen>结构中的结构</font></h1><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a><FONT COLOR = SpringGreen>类型定义</font></h1><h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a><FONT COLOR = SpringGreen>联合</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;结构类型&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 10 Strings</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/11/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2010%20Strings/</id>
    <published>2021-03-11T12:59:47.000Z</published>
    <updated>2021-04-27T10:34:56.413Z</updated>
    
    <content type="html"><![CDATA[<p>字符串</p><a id="more"></a><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><FONT COLOR = SpringGreen>字符串</font></h1><p>　　首先尝试定义一个字符数组：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;&#125; ;</code>。但这个东西只能算是字符数组，不是字符串，因为不能用字符串的方式做计算。</p><img src="https://www.hualigs.cn/image/606f00ffc435f.jpg" style="zoom:50%;" /><p>　　于是在字符数组上加点东西就变成了字符串：<code>char word[] = &#123; &#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;!&#39;,&#39;\0&#39;&#125; ;</code>    在数组初始化的最后加一个<code>&#39;\0&#39;</code>或者<code>0</code>。此时字符数组一共有七个单元，最后的单元是一个0，此时这个东西即是字符数组，也是字符串。</p><img src="https://www.hualigs.cn/image/606f017eb0c38.jpg" style="zoom:50%;" /><p>　　<FONT COLOR = LimeGreen>何为字符串</font>：</p><p>　　字符串是以 0 （整数0）结尾的一串字符。0 和 ‘\0’ 是一样的，但是和 ‘0’ 不同。非要说差别，0 表示一个 int （整数，四个字节）；‘\0’ 表示数组里面的一个元素，是一个 char ，是一个字节； ‘0’是一个字符， 这个字符表示Acall码里面的 0 ，是<code>0x30</code>，是48。<br>　　0 标志着字符串的结束，但它不是字符串的一部分。计算<u>字符串</u>长度的时候不包含这个0。<br>　　字符串在内存中以数组的形式存在，以数组或指针的形式去访问。更多的是以指针的形式。<br>　　<code>&lt;string.h&gt;</code>里有很多处理字符串的函数。</p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a><FONT COLOR = Cyan>字符串常量</font></h2><p>　　“hello”像这样子的东西，由双引号括起来的，就叫做字符串常量，或者字符串字面量。他会被编译器变成一个字符数组放在某处，这个数组的长度是 6 ，结尾还有表示结束的 0 。<br>　　两个相邻的字符串常量会被自动连接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，&quot;</span></span><br><span class="line"><span class="string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　<img src="https://www.hualigs.cn/image/606f08bde26b4.jpg"></p><p>　　可以看见，这是两个字符串，中间什么都没有，但是输出的时候自动连接在了一起。对于C语言来说，如果有两个相邻的字符串，中间没有任何其他符号，他会自动把这两个字符串连接起来。<br>　　也可以如此输入，将两端字符串接起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，\</span></span><br><span class="line"><span class="string">如输入\&quot;5 7\&quot;表示5英尺7英寸:&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　把第一行末尾表示字符串结束的引号去掉，加一个反斜杠，然后把下面两个 tab 去掉，然后把引号去掉，也会输入像上面那样的结果。</p><p>　　总的来说，C语言的字符串是以字符数组的形态存在的。所以不能用常规的运算符加减乘除对字符串进行运算。可以通过数组的方式来遍历字符串。<br>　　唯一特殊的地方，就是可以通过字符串字面量（双引号的东西）来初始化字符数组。</p><h1 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a><FONT COLOR = SpringGreen>字符串变量</font></h1><p>　　首先是如何定义去定义一个变量，让这个变量去表达字符串？字符串也是数组，所以下面的变量本质上也是字符数组的变量，只不过有特殊的表现形式。：<br>　　<code>char *str = &quot;hello&quot; ;</code>定义一个指针 str，初始化为指向一个字符串常量，该字符串常量里的内容是 hello。<br>　　<code>char word[] = &quot;hello&quot; ;</code>在这个地方定义一个字符数组，里面的内容是 hello<br>　　<code>char line[10] = &quot;hello&quot; ;</code>在这里定义一个字符数组 line，长度为10（10个字节），在这个数组里面放了 hello 。hello 是五个字符，在数组里要占据6个字节的空间（结尾有一个0）。<Font Size = 2>字符串变量写出来之后，编译器会自己在末尾加一个0</font></p><p>　　试图对字符串变量做一点点修改，尝试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;B&#x27;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here s[0] = %c\n&quot;</span>,s[<span class="number">0</span>]) ;</span><br></pre></td></tr></table></figure><p>　　这段代码尝试把首字母改一下，有的编译器会通过编译；有的编译器不会报错，但是运行时会出错：</p><blockquote><p>Bus error : 10 </p><p>segmentation fault</p></blockquote><p>　　尝试一件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> * s2 = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br></pre></td></tr></table></figure><p>　　此时会发现一件神奇的事情：</p><p><img src="https://www.hualigs.cn/image/606f9f6d014fe.jpg"></p><p>　　s 和 s2 指向的地址是一样的，都是<code>0x1</code>。做了两个字符串变量，用了相同的字面量来初始化，结果他们指向的地址是相同的。然后相比之下，i 的地址非常的大，而 s 的地址非常的小，相距非常远。i s s2 本身是非常正常的，紧紧挨在一起：</p><p><img src="https://ae01.alicdn.com/kf/U292c7faeb71e4800be85aead7eeac31fg.jpg"></p><p>　　i s s2 这些东西在大地址上，称之为本地变量。hello world 在一个很小的地址上，这个很小的地址叫做代码端，而且这个地址一旦定义完毕后，是只读的。如果在代码端的东西进行写入动作，比如<code>s[0] = &#39;B&#39; ;</code>，此时操作系统就会启动自动保护机制，让程序崩溃。<br>　　<FONT COLOR = LimeGreen>所以字符串常量所在的地方，实际上是<code>const char *s = “hello world” ；</code>。但是由于历史的原因，编译器接受不带<code>const</code>的写法，但是试图对 s 所指的字符串做写入，会导致严重的后果。</font></p><p>　　如果想要修改字符串，应该使用数组：<code>char s[] = &quot;hello world&quot; ;</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">char</span> * s = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> s2[] = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,s2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s = %p\n&quot;</span>,&amp;s) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s2= %p\n&quot;</span>,&amp;s2) ;</span><br></pre></td></tr></table></figure><p>　　这两种写法的区别就在于，定义指针的意思是，在代码端有这么个字符串常量，s 指向那里。定义数组的意思是，我这里有一个字符串常量，就在这里：</p><p><img src="https://www.hualigs.cn/image/60704315a20fe.jpg"></p><p>　　<FONT COLOR = LimeGreen>如果合理选择指针定义还是数组定义呢？</font></p><p>　　<code>char s[] = &quot;hello world&quot; ;</code>数组定义：这个字符串在这里，将来会作为本地变量空间自动被回收。<br>　　<code>char *s = &quot;hello world&quot; ;</code>指针定义：这个字符串不知道在哪里。<br>　　用来表达只读文件；<br>　　处理函数的参数。当作为函数参数时，数组 == 指针，反正进去的都是指针。<br>　　动态分配空间。如果字符串的空间是 <code>malloc</code> 得到的，此时字符串只能用指针。</p><p>　　总之，如果要构造一个字符串——数组；如果要处理一个字符串——指针。</p><p>　　有一个文字游戏，<code>char *</code>就一定是字符串吗？显然不是。<br>　　字符串可以表达为<code>char *</code>的形式。但<code>char *</code>不一定是字符串。因为它本意是指向字符的指针，可能指向的是字符的数组（和<code>int *</code>一样）。只有它所指的字符数组有结尾的 0 ，才能说它指的是字符串。</p><h1 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a><FONT COLOR = SpringGreen>字符串输入输出</font></h1><p>　　C语言对字符串的处理，是C语言最大的短板，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *t = <span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="keyword">char</span> *s ;</span><br><span class="line">s = t ;</span><br></pre></td></tr></table></figure><p>　　此时启示并没有产生新的字符串，只是让指针 s 指向了 t 所指的字符串，对 s 的任何操作就是对 t 做的。</p><p><img src="https://www.hualigs.cn/image/60705d3504e85.jpg"></p><h2 id="s-输入输出"><a href="#s-输入输出" class="headerlink" title="%s 输入输出"></a><FONT COLOR = Cyan>%s 输入输出</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ; <span class="comment">//定义长度为 8 的字符的数组</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ; <span class="comment">//由于定义了数组，这里不用加 &amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##\n&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　如果输入 hello world。会看到只会输出 hello## ，而后面的 world 不会输出。而且读入hello的时候，没有包含输入的那个空格。如果稍微改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br></pre></td></tr></table></figure><p>　　如果输入<code>hello world</code>，此时会输出<code>hello##world##</code>。可以刻按到，第一个<code>scanf</code>读到的是 hello 不带空格，第二个<code>scanf</code>读到的是 world 也不带空格。因为用户输入的空格在这里是分隔符。同理，如果输入<code>hello 回车 world</code>，此时会输出<code>hello##world##</code>。因为此时的空格、回车，在 %s 眼里都只是分隔符：<br>　　<FONT COLOR = LimeGreen><code>%s</code>读入一个单词（不是语言上的单词，而是读一串字母，到空格、tab、回车为止）</font>。此时的<code>scanf</code>是非常不安全的，因为不知道要读入的内容的长度。</p><h2 id="安全输入"><a href="#安全输入" class="headerlink" title="安全输入"></a><FONT COLOR = Cyan>安全输入</font></h2><p>　　<code>scanf(&quot;%7s&quot;,string)</code>，在 % 和 s 之间的数字表示最多允许读入的字符的数量，这个数字应该要比数组的大小小1（最后一位要放0）。如果就读了那么多个，比如说此时<code>scanf</code>就读到了7个数，那么<code>scanf</code>就此停止，不再依据空格或者回车来判断单词。<br>　　如果输入的数量超过了规定的个数，那么剩下的东西交给下一个<code>scanf</code>来做。<br>　　比如上述程序，定义的字符数组是8个单位，实际上只能写入7个字符，比如输入12345678：程序可能会出现输入错误（不同编译器表现错误的方式不一样）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果是严格的编译器，此时会报错：</p><blockquote><p>about trap: 6</p><p>数组越界导致程序崩溃</p></blockquote><p>　　解决办法，限定输入大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">8</span>] ;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">8</span>] ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,<span class="built_in">string</span>) ;<span class="comment">//最多只能读前 7 个字符，超过 7 个字符就不要了。</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%7s&quot;</span>,string2) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s##%s##\n&quot;</span>,<span class="built_in">string</span>,string2) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果此时输入<code>12345678</code>。会发现输出结果是<code>1234567##8##</code>。因为第一个<code>scanf</code>取了前七个数，第八个数就自动去满足下一个<code>scanf</code>。此时程序会只读入一次。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>char *</code>的本质是指针</strong></font></p><p>　　误以为，<code>char *</code>就是字符串类型，误以为这样就是定义了一个字符串变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> ;<span class="comment">//本质是定义一个指针变量</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时这个指针变量没有被初始化，不知道这个指针去指向哪里，如果此时这个指针指向了“只读的地方”，这种不能写入的地方，就会出错。<br>　　此时就是有可能错，有可能正常。</p><p>　　此时应该先让指针指向一个有效的地址。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>空字符串</strong></font></p><p>　　<code>char buffer[100] = &quot;&quot; ;</code>，此时这个字符串是一个空的字符串，<code>buffer[0] == &#39;\0&#39;</code><br>　　如果写成：<code>char buffer[] = &quot;&quot; ;</code>，此时这个数组的长度只有1，<code>buffer[0] == &#39;\0&#39;</code>，除此之外就没有元素了，无法写入任何东西。</p><h1 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a><FONT COLOR = SpringGreen>字符串数组</font></h1><p>　　如果想让一个数组去表示很多字符串，如何表示？</p><h2 id="char-a"><a href="#char-a" class="headerlink" title="char **a"></a><FONT COLOR = Cyan><code>char **a</code></font></h2><p>　　这句话的意思是，a 是一个指针， 这个指针指向另一个指针，那个指针指向一个字符，或者字符串。</p><h2 id="char-a-1"><a href="#char-a-1" class="headerlink" title="char a[][]"></a><FONT COLOR = Cyan><code>char a[][]</code></font></h2><p>　　这句话是定义一个二维数组，并且根据C语言的规则，行数可以由编译器来数，但列数一定要明确给出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　此时编译器会报错：</p><blockquote><p>[Error] array type has incomplete element type</p><p>该数组没有完备的类型。</p></blockquote><p>　　所以要明确给出这个二维数组的列数，比如修改为：<code>char a[][10] ;</code><br>　　<FONT COLOR = LimeGreen>这句话的本质</font>：是定义一个数组，该数组每一个单元都是 <code>char[10]</code>，<code>a[0]</code>是一个<code>char[10]</code>，<code>a[1]</code>也是一个<code>char[10]</code>。所以就会出现下面情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">8</span>] = &#123;</span><br><span class="line"><span class="string">&quot;hello&quot;</span> ,</span><br><span class="line"><span class="string">&quot;world&quot;</span> ,</span><br><span class="line"><span class="string">&quot;1234567890&quot;</span> ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　定义 hello 和 world 的时候没有错，但是在定义 <code>a[2]</code>的时候出错了：</p><blockquote><p>[Warning] initializer-string for array of chars is too long [enabled by default] 这个东西太长了<br>[Warning] (near initialization for ‘a[2]’) [enabled by default]</p></blockquote><h2 id="char-a-2"><a href="#char-a-2" class="headerlink" title="char *a[]"></a><FONT COLOR = Cyan><code>char *a[]</code></font></h2><p>　　这样写才是真正的去定义一个字符串数组，这个数组里面每一个元素都是一个<code>char *</code>：  </p><p><img src="https://gitee.com/XuSiyuan-cn/PhotosOfMyBlog/raw/master/20210420182315.png" alt="图表1"></p><p>　　在<code>switch-case</code>里面，我们曾经尝试过一个月份的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入月份\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :<span class="built_in">printf</span>(<span class="string">&quot;january&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :<span class="built_in">printf</span>(<span class="string">&quot;feb&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :<span class="built_in">printf</span>(<span class="string">&quot;march&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :<span class="built_in">printf</span>(<span class="string">&quot;april&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :<span class="built_in">printf</span>(<span class="string">&quot;may&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span> :<span class="built_in">printf</span>(<span class="string">&quot;june&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> :<span class="built_in">printf</span>(<span class="string">&quot;july&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span> :<span class="built_in">printf</span>(<span class="string">&quot;august&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span> :<span class="built_in">printf</span>(<span class="string">&quot;september&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span> :<span class="built_in">printf</span>(<span class="string">&quot;october&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span> :<span class="built_in">printf</span>(<span class="string">&quot;november&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span> :<span class="built_in">printf</span>(<span class="string">&quot;december&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序非常的简单，也可以用字符串数组来实现这个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[][<span class="number">10</span>] = &#123; <span class="comment">//定义字符串数组</span></span><br><span class="line"><span class="string">&quot;January&quot;</span> ,</span><br><span class="line"><span class="string">&quot;february&quot;</span> ,</span><br><span class="line"><span class="string">&quot;march&quot;</span> ,</span><br><span class="line"><span class="string">&quot;april&quot;</span> ,</span><br><span class="line"><span class="string">&quot;may&quot;</span> ,</span><br><span class="line"><span class="string">&quot;june&quot;</span> ,</span><br><span class="line"><span class="string">&quot;july&quot;</span> ,</span><br><span class="line"><span class="string">&quot;august&quot;</span> ,</span><br><span class="line"><span class="string">&quot;september&quot;</span> ,</span><br><span class="line"><span class="string">&quot;october&quot;</span> ,</span><br><span class="line"><span class="string">&quot;november&quot;</span> ,</span><br><span class="line"><span class="string">&quot;december&quot;</span> ,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> month ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;month) ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">12</span> ; i++)&#123; <span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( i + <span class="number">1</span> == month )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main的真相"><a href="#main的真相" class="headerlink" title="main的真相"></a><FONT COLOR = Cyan>main的真相</font></h2><p>在比较严格的编译器中，main 的样子是这样的：<code>int main( int argc, char* argv[], char **env ) </code>。 </p><p>　　第一个参数，int型的<code>argc</code>，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，一般默认为1。  </p><p>　　第二个参数，char*型的<code>argv[]</code>，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：<br>    <code>argv[0]</code>指向程序运行的全路径名<br>    <code>argv[1]</code>指向在DOS命令行中执行程序名后的第一个字符串<br>    <code>argv[2]</code>指向执行程序名后的第二个字符串<br>    <code>argv[3]</code>指向执行程序名后的第三个字符串<br>    <code>argv[argc]</code>为NULL </p><p>　　第三个参数，char**型的<code>env</code>，为字符串数组。<code>env[]</code>的每一个元素都包含<code>ENVVAR=value</code>形式的字符串，其中<code>ENVVAR</code>为环境变量，value为其对应的值。平时使用到的比较少。</p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>,argc) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d is %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　输出为：</p><blockquote><p>argc = 1 </p><p>argument 0 is F:\Caches\desktop\Mr.Weng.exe</p></blockquote><p>　　如果在调试—命令参数中，输入多个命令参数，比如“a b c d”此时输出值就会变成</p><blockquote><p><code>argc</code> = 5<br>argument 0 is F:\Caches\desktop\Mr.Weng.exe<br>argument 1 is a<br>argument 2 is b<br>argument 3 is c<br>argument 4 is d</p></blockquote><p>　　在Unix里面，这里还有更复杂的东西</p><h1 id="单字符输入输出"><a href="#单字符输入输出" class="headerlink" title="单字符输入输出"></a><FONT COLOR = SpringGreen>单字符输入输出</font></h1><h2 id="函数putchar"><a href="#函数putchar" class="headerlink" title="函数putchar"></a><FONT COLOR = Cyan>函数<code>putchar</code></font></h2><p>　　<code>int putchar(int c) ;</code>把一个字符输出到标准输出上（终端）。但这个函数的输入参数不是<code>char</code>，而是<code>int</code>，但是这个<code>int</code>所能接受的，也仅仅是一个字符而已。这个函数返回类型也是一个<code>int</code>，表示这一次到底写出去几个字符。如果某时候这个输出不能用了，此时会返回一个 <code>EOF（-1） = end of file</code>；这个 <code>EOF</code> 是一个宏，这个宏的值是 -1 。<br>　　一般来说，不用在意<code>putchar</code>的返回。</p><h2 id="函数getchar"><a href="#函数getchar" class="headerlink" title="函数getchar"></a><FONT COLOR = Cyan>函数<code>getchar</code></font></h2><p>　　<code>int getchar(void)</code>它的作用是从终端中读入一个字符，也就是说，如果终端有数据的话不用输入它就可以直接读取了。第一次调用<code>getchar()</code>时，确实需要人工的输入，但是如果输了多个字符，以后的<code>getchar()</code>再执行时就会直接从缓冲区中读取了。<br>　　返回类型也是<code>int</code>,</p><p>　　试一下以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != EOF )&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOF\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>ch = getchar()) != EOF </code>，首先把终端里面的字符用<code>getchar</code>读取出来，然后赋值给 ch ，然后判断这个值是不是 <code>EOF</code> 。如果不是，那么用<code>putchar</code>输出这个值。</p><h1 id="函数STRLEN"><a href="#函数STRLEN" class="headerlink" title="函数STRLEN"></a><FONT COLOR = SpringGreen>函数<code>STRLEN</code></font></h1><h1 id="函数STRCMP"><a href="#函数STRCMP" class="headerlink" title="函数STRCMP"></a><FONT COLOR = SpringGreen>函数<code>STRCMP</code></font></h1><h1 id="函数STRCPY"><a href="#函数STRCPY" class="headerlink" title="函数STRCPY"></a><FONT COLOR = SpringGreen>函数<code>STRCPY</code></font></h1><h1 id="函数STRCAT"><a href="#函数STRCAT" class="headerlink" title="函数STRCAT"></a><FONT COLOR = SpringGreen>函数<code>STRCAT</code></font></h1><h1 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a><FONT COLOR = SpringGreen>字符串搜索函数</font></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;字符串&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers II</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/10/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20II/</id>
    <published>2021-03-10T13:59:47.000Z</published>
    <updated>2021-04-08T10:16:01.696Z</updated>
    
    <content type="html"><![CDATA[<p>指针（下）</p><a id="more"></a><h1 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a><FONT COLOR = SpringGreen>指针与const</font></h1><p>　　C 99 only<br>　　指针和 const 在一起就有点小复杂，因为指针本身可以是 const，而指针所指向的变量的值，也可以是 const。</p><h2 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a><FONT COLOR = Cyan>指针是const</font></h2><p>　　此时表示指针一旦得到了某个变量的地址，就不能再指向其他变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> q = &amp;i; <span class="comment">// 此时 q 是 const，q 的值不能被改变，q 指向 i 这个事实不能被改变，q 不能再指向别的量了。</span></span><br><span class="line">*q = <span class="number">26</span> ; <span class="comment">//访问指针地址上的值，赋值，OK。因为 q 所指向的 i 不是const</span></span><br><span class="line">q++ ; <span class="comment">//改变指针的位置，ERROR</span></span><br></pre></td></tr></table></figure><h2 id="所指的是const"><a href="#所指的是const" class="headerlink" title="所指的是const"></a><FONT COLOR = Cyan>所指的是const</font></h2><p>　　表示不能通过这个指针去修改那个变量（并不能使那个变量成为const）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;i ;</span><br><span class="line">*p = <span class="number">26</span> ; <span class="comment">// ERROR！因为 (*p)是const，此时不能通过指针去修改那个地址上的量，此时不能通过 *p 去赋值。</span></span><br><span class="line">i = <span class="number">26</span> ; <span class="comment">//OK</span></span><br><span class="line">p = &amp;j ; <span class="comment">//OK，可以修改 p 的指向，让 p 指向 j</span></span><br></pre></td></tr></table></figure><h2 id="const的位置"><a href="#const的位置" class="headerlink" title="const的位置"></a><FONT COLOR = Cyan>const的位置</font></h2><p>　　const 可以一共出现三个位置，但是只有两个功能：要么是指针不可修改，要么是通过指针不可修改。<FONT COLOR = LimeGreen>判断哪个被 const 了的标志，是 const 在 * 的前面还是后面。</font>如果是指针不可修改，则 const 在变量前面，在 * 后面；如果是通过指针不可修改，则 const 在 * 前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p1 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * p2 = &amp;i ; <span class="comment">//通过指针不可修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;i ; <span class="comment">//指针不可修改</span></span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a><FONT COLOR = Cyan>转换</font></h2><p>　　总是可以把一个非 const 的值转换成 const </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * x)</span> </span>;<span class="comment">//该函数需要一个“通过指针不可修改”的指针来进行输入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line">f(&amp;a) ; <span class="comment">//此时给函数一个非 cconst 的指针，是没问题的！</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a ;</span><br><span class="line">f(&amp;b) ; <span class="comment">//此时给函数一个 const 的指针，也是没问题的。</span></span><br><span class="line">b = a + <span class="number">1</span> ;<span class="comment">//[Error] assignment of read-only variable &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数原型的意思是，给我一个指针，我保证在函数内部不会通过指针去修改地址上的值。所以至于交给他的参数是不是 const ，其实是无所谓的。</p><p>　　这种做法主要用来，当要传递的参数的类型比地址大的时候（在结构的时候常用），这是常用的手段：既能用比较少的字节数传值给参数，又能避免函数对外面的变量的修改。类似于传数组，数组可以很大，但实际上传给函数的只有一个<code>*int</code>大小的地址，传进去的实际上是指针。</p><h2 id="const数组"><a href="#const数组" class="headerlink" title="const数组"></a><FONT COLOR = Cyan>const数组</font></h2><p>　　在《指针与数组》中，我们可以看出来，数组本质上就是一个 const 的指针，那么再次对数组进行 const会发生什么？比如<code>const int a[] = &#123; 1, 2, 3, 4, 5, 6&#125; ;</code><br>　　数组变量已经是 const 的指针了，这里的const表明数组的每个单元都是 const int。所以必须通过初始化进行赋值。</p><p><FONT COLOR = LimeGreen>　　这种做法可以用来保护数组值：</font></p><p>　　因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值。为了保护数组不被破坏，可以设置函数的参数为const：</p><p>　　<code>int sum(const int a[],int length);</code><br>　　这句话的意思是要求函数接受一个const的数组，那么在函数内部，函数不会对数组有任何修改！</p><h1 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a><FONT COLOR = SpringGreen>指针运算</font></h1><h2 id="1-1-2？"><a href="#1-1-2？" class="headerlink" title="1 + 1 = 2？"></a><FONT COLOR = Cyan>1 + 1 = 2？</font></h2><p> 　　对指针变量进行自加一的话，会是什么呢？用代码尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc = ac ;<span class="comment">//&amp;可加可不加</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc  =%p\n&quot;</span>,pc) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc+1=%p\n&quot;</span>,pc+<span class="number">1</span>) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi  =%p\n&quot;</span>,pi) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi+1=%p\n&quot;</span>,pi+<span class="number">1</span>) ;</span><br></pre></td></tr></table></figure><p>　　输出结果为：</p><blockquote><p>pc    = 0x22FE30<br>pc+1= 0x22FE31  此时结果相差1</p><p>pi     = 0x22FE00<br>pi+1= 0x22FE04  此时结果相差4 </p></blockquote><p>　　为什么呢？因为<code>sizeof(char) = 1 , sizeof(int) = 4</code>。所以对于指针变量 + 1，不是让地址 + 1，而是让指针 + 1个 sizeof 。 对于 char 类型，如果第一个地址在 30 上，那执行指针 +1后，地址在31上。对于 int 类型，如果第一个地址在00上，因为一个 int 型占据 4 个字节，所以执行指针 +1后，地址在 04 上。</p><p><img src="https://www.hualigs.cn/image/606d14a05b596.jpg"></p><p>　　对指针变量 + 1，本质是让指针所指向的地址往后面移动一格。这一点在数组里面体现的尤为明显：<br>　　对于 char 类型数组<code>*pc -&gt; ac[0] ; *(pc+1) -&gt; ac[1]</code>。<br>　　对于 int 类型数组<code>*pi -&gt; ai[0] ; *(pi+1) -&gt; ai[1]</code>。<br>　　对于任何类型的数组，<code>*p -&gt; a[0] ; *(p+n) -&gt; a[n]</code>。<br>　　<FONT COLOR = LimeGreen>给一个指针加1表示要让指针指向下一个变量</font>，如果指针不是指向一片连续分配的空间，如数组，则这种运算是没有意义的。</p><h2 id="指针的加减"><a href="#指针的加减" class="headerlink" title="指针的加减"></a><FONT COLOR = Cyan>指针的加减</font></h2><p>　　加减可以对指针做。<br>　　指针 + n：指针往后移 n 个<code>sizeof</code>单元<br>　　指针 - n：指针往前移 n 个<code>sizeof</code>单元<br>　　两个指针相减：类似于坐标相减，指的是他们中间有多少个<code>sizeof</code>单元。用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">char</span> *pc1 = &amp;ac[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">char</span> *pc7 = &amp;ac[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1  =%p\n&quot;</span>,pc1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc7  =%p\n&quot;</span>,pc7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc1 - pc7 = %d\n&quot;</span>,pc1-pc7) ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi1 = &amp;ai[<span class="number">1</span>] ; <span class="comment">//这里必须要有&amp; </span></span><br><span class="line"><span class="keyword">int</span> *pi7 = &amp;ai[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1  =%p\n&quot;</span>,pi1) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi7  =%p\n&quot;</span>,pi7) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi1 - pi7 = %d\n&quot;</span>,pi1-pi7) ; </span><br></pre></td></tr></table></figure><p>　　运行结果如下：</p><blockquote><p>pc1           = 0x22FE21<br>pc7           = 0x22FE27<br>pc1 - pc7 = -6</p><p>pi1           = 0x22FDF4<br>pi7           = 0x22FE0C<br>pi1 - pi7 = -6<br>在16进制下，这两个地址相差24，刚好是 6 个sizeof(int)</p></blockquote><p>　　所以两个指针相减的时候，给的不是地址差，给的是地址之间相差多少个单元，中间还能放几个这样类型的元素。</p><h2 id="p"><a href="#p" class="headerlink" title="*p++"></a><FONT COLOR = Cyan>*p++</font></h2><p>　　　<code>*</code>的优先级是非常高的，但是没有++高。所以是先进行后缀的自加1，再取<code>*</code> ，<FONT COLOR = LimeGreen>p++ 的结果，是p+1以前的结果</font>。所以这句话的操作是：<FONT COLOR = LimeGreen>取出指针 p 所指的数据，完事后顺便把 p 移到下一个位置去。</font><br>　　该操作常用于数组类的连续空间操作。比如遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i&lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;<span class="comment">//在数组末尾放一个不可能的多余数据 </span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;b[<span class="number">0</span>] ;<span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>( ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　如果使用指针挪位的方法来遍历，则需要在遍历的数组后面加一个不可能的多余数据，达成循环终止的条件。其中指针的初始化可以用以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p  ;</span><br><span class="line"><span class="keyword">for</span>( p = b ; *p != <span class="number">-1</span> ; p++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,*p) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　在上一讲提过，数组就是特殊的指针，对于初始化，以下几种方式都是可以的：<br>　　<code>int *p = b ;</code> 或者 <code>int *p ; p = b ;</code> 或者 <code>int *p = &amp;b[0] ;</code> </p><p>　　在某些CPU上，<code>*p++</code>可以直接被翻译成一条汇编指令。</p><h2 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a><FONT COLOR = Cyan>指针比较</font></h2><p>　　<code>&lt; , &lt;= , == , &gt; , &gt;= , !=</code>都可以对指针做，用来比较他们在内存中的地址。数组中的单元地址是线性递增的。</p><h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a><FONT COLOR = Cyan>0地址</font></h2><p>　　  现代的操作系统都是多进程的操作系统，对于每一个进程，操作系统会给他一个虚拟的地址空间，所以所有的程序在运行的时候都以为自己有从0开始的一片连续的地址空间。<FONT COLOR = LimeGreen>所以任何程序都有0地址，但是0地址通常是个不能随便碰的地址，所以我们的指针不应该具有0值。</font><br>　　所以可以用这个特性来做一些特殊的事情：<br>　　用 0 地址表示返回的指针是无效的，指针没有被真正的初始化（先初始化为0）……<br>　　在C语言里，有的编译器不愿意用 0 来表示 0 地址。所以使用 <code>NULL</code>为预定定义的符号，表示 0 地址。</p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a><FONT COLOR = Cyan>指针类型</font></h2><p>　　无论指向什么类型，所有的指针的大小都是一样的，他们都是地址。但是指向不同类型的指针是不能直接互相赋值的，比如上面的<code>int *pi</code>和<code>char *pc</code>。这是为了避免用错指针。<br>　　如果赋值了会怎么样？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ai[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, &#125; ;</span><br><span class="line"><span class="keyword">int</span> *pi = ai;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pi = %p\n&quot;</span>,pi) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ac[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *pc = ac ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br><span class="line"></span><br><span class="line">pi = pc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pc = %p\n&quot;</span>,pc) ;</span><br></pre></td></tr></table></figure><p>　　此时会有一个 warning：</p><blockquote><p>[Warning] initialization from incompatible pointer type [enabled by default]</p><p>指针类型不匹配</p></blockquote><p>　　如果忽视掉 warning 强行运行的话，会发现，还是成功地把 pi 所指向的地址，赋给了 pc。所以此时 pc 和 pi 指向同一个地址。这个和数据类型不一样，比如 double 和 int。强行把 double 的值放给 int 的话，因为 double 占据空间比 int 大，所以强行放进去会出现问题。但不管是什么类型的指针，他们本质上都是地址，而且大小都相同，东西是放的进去的，这样做有问题的原因如下：</p><p><img src="https://www.hualigs.cn/image/606d53bb62f4d.jpg"></p><p> 　　如果让<code>pi = pc</code>，然后操作 *pi ，比如让<code>*pi = 0</code>，本来 pi 是指向 4 个字节，那么就会让 30、31、32、33四个位置上全部为0。 所以编译器报 warning 的原因，是为了防止用错指针。</p><h2 id="void"><a href="#void" class="headerlink" title="void *"></a><FONT COLOR = Cyan>void *</font></h2><p>　　如果想要强制让不同类型的指针去赋值，就需要强制类型转换：<br>　　<code>void *</code> 表示不知道指向什么东西的指针，先定义这个指针指向“void”，这片空间里是什么类型，是 int 还是 double，先不用去知道，不用去管。这种指针可以直接去访问内存地址，或者某个内存地址所代表的外部设备等。计算时与<code>char *</code>相同（但不相通）<br>　　指针也可以转换类型。<code>int *p = &amp;i ; void *q = (void *)p</code>这里就是把一个 int 型的指针 p ，强制转换为了 void 型，并且交给了 <code>void *p</code>。此时实际上这并没有改变 p 所指的变量的类型，p 是指向 i 的，i 也任然是 int 。只不过是通过 q 去看 i 的时候，眼光变了；通过 p 去看 i ，i 是 int ；通过 q 去看 i ，i 是 void 。</p><p>　　让后人用不同的眼光通过 p 来看它所指的变量 i，我不再当你是 int 了，我认为你就是个 void。</p><h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a><FONT COLOR = SpringGreen>动态内存分配</font></h1><p>　　如何用变量来定义数组？除了<code>const int number ； int a[number]</code>这种方法外，还有没有？利用 malloc 函数对指针进行动态内存分配，比如：<code>int *a = (int*)malloc(n*sizeof(int));</code></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><FONT COLOR = Cyan>malloc</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>属于标准库函数</strong></font></p><p>　　malloc 全称是 memory allocation ，是 C 标准库里面的函数，所以使用 malloc 前要加一个头文件<code>#include&lt;stdlib.h&gt;</code></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>描述</strong></font></p><p>　　该函数分配他想要的一个内存空间，并返回一个指向它的指针。<FONT COLOR = LimeGreen>向 malloc 申请的空间大小是以字节为单位的</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>声明</strong></font></p><p>　　下面是 malloc() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>参数</strong></font></p><p>　　size – 内存块的大小，以字节为单位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>返回值</strong></font></p><p>　　该函数返回一个指针 void * ，指向已分配大小的内存。<FONT COLOR = LimeGreen>返回的指针需要类型转换为自己需要的类型</font>比如：<code>(int *)malloc( n * sizeof(int) )</code>。<br>　　如果空间用完了，则请求分配空间失败，则返回 0，或者NULL。</p><p>　　用“变量”定义数组，方法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"><span class="keyword">int</span> a[number] ;</span><br></pre></td></tr></table></figure><p>　　用“变量”定义数组，方法2，malloc 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br></pre></td></tr></table></figure><p>　　malloc 需要的参数不是有多少个 int，不是这个数组有多少个单元，而是这个数组需要多少空间（字节），所以在括号里面需要乘以一个<code>sizeof(int)</code>。此外，malloc 他返回的是一个 void* ，而 a 是一个 int *。所以这里需要使用一下类型强制转换，前面需要一个<code>( int *)</code><br>　　指针和数组的本质是相同的，所以接下来，这个指针 a ，就可以完全当做数组来使用：</p><p>　　<Font Size = 2 color = DeepSkyBlue><strong>特别注意的是，虽然指针可以当做数组来用，但他还是指针，所以对于这种东西是不能用 <code>sizeof</code>的，如果去用 <code>sizeof</code>，得到的是指针的长度（占据多少个字节）。所以对于这种“数组”的 length 也不能使用<code>sizeof(a)/sizeof(a[0])</code>，应该直接使用 number。</strong></font></p><p>　　尝试对这种数组做点操作：遍历输入，遍历逆序输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数量\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *a ;</span><br><span class="line">a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(number * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = number - <span class="number">1</span> ; i &gt; <span class="number">-1</span> ; i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(a) ;<span class="comment">//释放内存很重要</span></span><br></pre></td></tr></table></figure><p>　　可以利用一下 malloc 看一下自己的系统能给多大的空间，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>( ( p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>)) )&#123;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分配了%d00MB的空间\n&quot;</span>,count) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>1、定义指针的时候，定义的是 void 类指针，这里也可以定义 int 型，如果定义 int 型，那么后面使用 malloc 的时候前面就要加一句<code>int *</code>。<br>　　2、<code> p = malloc(100*1024*1024)</code>这句话有三个作用：<br>　　第一，利用 malloc 去申请空间，并且把字节换算成了MB，1 mb = 1024 kb = 1024 * 1024 b。所以这里没申请一次相当于申请了 100 mb。<br>　　第二，把函数返回值交给指针 p 。<br>　　第三，这句话也是循环继续的条件，如果 malloc 申请空间成功，则成功赋值；如果 malloc 申请空间失败，由 malloc 的操作手册可知，malloc 会返回 0，或者 NULL。所以这句话也可以当做循环的条件，当申请空间失败的时候，就是表达式为 0 的时候，就是循环终止的时候。</font></p><h2 id="free"><a href="#free" class="headerlink" title="free( )"></a><FONT COLOR = Cyan>free( )</font></h2><p>　　malloc 函数是向系统申请内存空间，而<code>free()</code>就是把申请来的空间还给“系统”。<br>　　申请过来的空间最终都应该归还，只能还申请来的空间的首地址，用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>) ;<span class="comment">//要个100MB的空间</span></span><br><span class="line">p++ ;<span class="comment">//把指针的地址往下面去放一位</span></span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时程序会报错，有可能不报错，但程序会崩溃，也不会运行到“here”那里。如果是严格的编译器此时会编译出错：</p><blockquote><p>error: Access violation in freeing invalid address （提示非法访问）</p><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　如果 free 的指针不是 malloc 来的，也会报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">free</span>(p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;here&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　此时指针 p 的空间不是 malloc 来的，dev C++ 没有报错，但是程序运行时会崩溃，不会运行到 “here” 那里。如果是严格的编译器，会报错：</p><blockquote><p>error: pointer being freed was not allocated （要释放的指针（空间），不是申请来的）</p></blockquote><p>　　由这两个错误可以看出，系统可以记住，哪些内存是 malloc 来的，必须要严格记住 malloc 的地址，对这个地址 free 才有效。<code>free(NULL)</code>也是可以执行的，就是什么都不做。</p><p>　　如果申请了内存空间，不去 free ，长时间运行的话就会使内存逐渐下降。对操作系统来说，当程序结束后，曾经使用过的内存会全部清除干净。<br>　　如果 free 过了再去 free，也会出错。</p><hr><p>指针的主要用途：</p><p>需要传入较大的数据时，用指针作为参数，比如数组。<br>传入数组后对数组做操作。<br>函数返回不止一个结果，需要用指针带出来<br>需要用函数来修改不止一个变量<br>动态申请的内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（下）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 09 Pointers I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/09/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2009%20Pointers%20I/</id>
    <published>2021-03-09T13:59:47.000Z</published>
    <updated>2021-04-06T13:47:42.447Z</updated>
    
    <content type="html"><![CDATA[<p>指针（上）</p><a id="more"></a><h1 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a><FONT COLOR = SpringGreen>取地址运算</font></h1><h2 id="运算符-amp"><a href="#运算符-amp" class="headerlink" title="运算符&amp;"></a><FONT COLOR = Cyan>运算符&amp;</font></h2><p>　　在C里面，&amp;也是运算符，为取地址运算，最典型的就是<code>scanf(&quot;%d&quot;,&amp;i)</code>里面的 &amp;<br>　　<FONT COLOR = LimeGreen>&amp; ：作为运算符，是获得变量的地址，它的操作数必须是变量！</font>C语言里的变量是放在内存里面的，每一个变量都会在内存中占据一定的位置和大小。比如 int 是四个字节，这个变量有大小，内存需要有一个地方放置，放置变量这个地方就是地址。&amp; 就是把这个变量的地址拿出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　地址用16进制表达起来比较方便，所以在输出 %x 前面加一个<code>0x</code>，其中 %x 表示以十六进制数形式输出整数，对于地址的表达，用16进制比较方便。把 i 的地址取出来，用<code>printf</code>输出。此时程序给出的结果是：<code>0x22fe4c</code>。<br>　　有的编译器可能会给一个warning：</p><blockquote><p>warning: format specifies type ‘unsigned int’ but the argument has type ‘ int * ‘</p></blockquote><p>　　这个warning的意思是，如果你想要<code>printf</code>给你输出一个地址，输出的时候不应该用 %x ，而是使用 %p。：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen><code>%p</code>的意思是把这个值作为一个地址来输出，输出的时候自己会在前面加<code>0x</code>，是以16进制的方式输出这个地址， 如果输出数据不够8位数，则左边补零。  </font>此时输出值是：<code>000000000022fe4c</code>。<Font Size = 2>这里我补了16位数，有可能是因为的我的编译器为64位</font></p><p>　　这两个地址实际上表达的是一个位置，看起来像是一个数，尝试能不能对这个数进行操作？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时编译器会有一个 warning:</p><blockquote><p>[Warning] assignment makes integer from pointer without a cast [enabled by default]</p></blockquote><p>　　这个 warning 是需要类型转换的意思，需要从指针型转换为 int 型，若忽视 warning 强行输出，则结果为：<code>000000000022fe48</code>。解决掉这个 warning ，只需要一次强行类型转换即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;<span class="comment">//我的电脑在编译的时候这里任然有类型转换的 warning，初步认为是编译器的问题，换成更加严格的在线编译器之后通过！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br></pre></td></tr></table></figure><p>　　此时两条代码的编译结果都是<code>0x22fe48</code>。<br>　　注：<Font Size = 2>特别的，关于 &amp;i 和 int 类型的东西，在32位架构下，两者大小是相同的，但是在64位架构下，两者并不相同。</font>所以关于这段代码的编译结果，对于 32 位系统，编译结果相同；对于64位系统，编译结果可能不同，但是后 8 位是一模一样的，比如结果可能是<code>0x5c961d28</code>和<code>0x7fff5c961d28</code>。还有一个例子更好地说明在 64 位架构下，<code>int</code>和<code>&amp;i</code>的区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> p ;</span><br><span class="line">p = (<span class="keyword">int</span>) &amp;i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x\n&quot;</span>,p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;i));</span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>0x22fe48、000000000x22fe48、4、8</code>。说明在64位架构下，int 的大小是4，而 &amp;i 的大小是8。在32位架构下，int 的大小是4 ，&amp;i 的大小也是4。</p><p>　　综上：一个变量，它的地址的大小是否与 int 相同取决于编译器，取决于系统是64位架构还是32位架构。地址和整数并不永远是相同的，所以对于地址的输出，我们采用 %p 的方式。</p><h2 id="不能取的地址"><a href="#不能取的地址" class="headerlink" title="不能取的地址"></a><FONT COLOR = Cyan>不能取的地址</font></h2><p>　　<FONT COLOR = LimeGreen>&amp; 不能对没有地址的东西取地址</font>。如果右边不是一个变量，则不能取地址！<br>　　<code>&amp;(a+b)</code>、<code>&amp;(a++)</code>、<code>&amp;(++a)</code>此时右边是一个表达式，所以不能取地址</p><blockquote><p>[Error] lvalue required as unary ‘&amp;’ operand</p><p>error: cannot take the address of an rvalue of type ‘int’</p></blockquote><h2 id="常见的地址"><a href="#常见的地址" class="headerlink" title="常见的地址"></a><FONT COLOR = Cyan>常见的地址</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>变量的地址</strong></font></p><p>　　上面已经阐述过，不再赘述</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的变量的地址</strong></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br></pre></td></tr></table></figure><p>　　输出结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>可以看出来，定义的相邻的变量，地址也是相邻的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;i) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;j) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;k) ;</span><br></pre></td></tr></table></figure><p>　　输出的结果分别是：<code>0x22FE4C</code>、<code>0x22FE48</code>、<code>0x22FE44</code>说明在内存里面，他们都是紧挨着的。<br>　　其中也可以看出来，最先定义的 i 占据比较位置比较大，然后是后面定义的 j 然后是后面定义的 k 。</p><p><img src="https://www.hualigs.cn/image/606930106c1cd.jpg"></p><p>　　在内存中，最先定义的 i 在最高的地方，然后是 j  最低的地方是最后定义的 k 。C 的内存模型会将本地变量分配在“堆栈 stack”，在堆栈中，分配变量是“自顶向下”分配的。先写的变量地址最高，后写的变量地址变低，依次紧挨着排列。他们的地址相差一个<code>sizeof(int)</code>。<font color = red>为什么这里相差一个<code>sizeof(int)</code>而不是一个<code>sizeof(&amp;i)</code>?</font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong><code>&amp;</code>的结果和 <code>sizeof</code></strong></font></p><p>　　前面已经讨论过，不同编译器和不同架构下，<code>sizeof</code>的结果不一样，32位占据4，64位占据8。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组单元的地址</strong></font></p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>相邻的数组单元的地址</strong></font></p><p>　　用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;<span class="comment">//数组的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">0</span>]) ;<span class="comment">//数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a[<span class="number">1</span>] );<span class="comment">//相邻的数组单元的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//试图直接把a交给printf输出地址</span></span><br></pre></td></tr></table></figure><p>　　结果分别是：<code>22FE20、22FE20、22FE24、22FE20</code>。相邻数组单元的地址相差永远是 4 。说明他们是紧挨着的。</p><p><img src="https://www.hualigs.cn/image/606b06c98d387.jpg"></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a><FONT COLOR = SpringGreen>指针</font></h1><h2 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a><FONT COLOR = Cyan>指针变量</font></h2><p>　　如果能够将取得的变量的地址，然后将这个地址作为一个值传递给一个函数，那么这个函数能否通过这个地址访问到这个变量呢？比如函数<code>scanf(&quot;%d&quot;,&amp;i)</code>，他到底是如何工作的？<br>　　在使用<code>scanf</code>的时候，会传给这个函数一个变量的地址，然后<code>scanf</code>拿我们传给它的这个地址，放到我们指定的变量中去。这些功能是如何实现的？<code>scanf</code>的原型应该是怎样的？如果我们需要一个参数能够保存别的变量的地址，如何表达能够保存地址的变量？</p><p>　　从分析<code>scanf</code>的功能可以看出来，<code>scanf</code>一定有办法，可以接受用户输入变量的地址。有前面尝试可以知道，不能把地址交给整数，因为 int 和 地址 长度不一样，在不同编译情况下，他们可能不相等。所以在C语言里，用指针来保存地址。</p><p>　　在C语言里，指针就是保存地址的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;i ;<span class="comment">//*p就表示p是一个指针变量，用来保存 i 的地址</span></span><br><span class="line"><span class="keyword">int</span>* p,q ;<span class="comment">//*作用在p上，无法作用在q上。</span></span><br><span class="line"><span class="keyword">int</span> *p,q ;<span class="comment">//这句话和上面那句是一样的。</span></span><br></pre></td></tr></table></figure><p>　　<code>int* p = &amp;i</code> p 是指针，指向 i 的地址，如果说“ p 指向 i ”意思就是指针变量 p 里面保存的是 i 的地址。</p><p><FONT COLOR = LimeGreen>　　指针变量的值就是内存的地址。普通变量的值是实际的值，指针变量的值是具有实际值的变量的地址。</font>指针变量里面不会储存实际的值，只会放别的变量的地址。</p><h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a><FONT COLOR = Cyan>函数与指针</font></h2><p>　　如果把指针作为函数的参数会怎么样？就像<code>scanf(&quot;%d&quot;,&amp;i)</code>：<br>　　<code>void f(int *p)</code>此时表示函数 f 需要一个指针，如果要调用这个函数，就需要交给他一个地址：<code>int i = 0 ； f(&amp;i)</code>。此时不能交给 f 这个变量本身，必须要用 &amp; 取得 i 的地址交给 f ，函数才会生效。比如如下例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ; <span class="comment">//直接输出 i 的地址</span></span><br><span class="line">f(&amp;i) ;<span class="comment">//把 i 的地址交给 f 函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;  <span class="comment">//让函数输出 p 的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　可以看到，两个值是一样的。此时就可以说 p 是一个指针，指向 i 。此时在 f 函数里面，可以得到 main 函数里面变量的地址了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;</span><br><span class="line">f(&amp;i) ;</span><br><span class="line">g(i) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> *p )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">int</span> k )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; k = %d\n&quot;</span>,k) ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>　　此时 f 拿到了 i 的地址，但是 g 只拿到了 i 的值。g 这个函数里面拿到的值和 main 函数是没有关系的，g 函数无法访问 main 函数。但是 f 是可以通过指针来访问 main 函数。</p><h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a><FONT COLOR = Cyan>访问地址</font></h2><p>　　有了指针之后，有了地址之后，如何访问这个地址上的变量呢？<FONT COLOR = LimeGreen>使用 * ，用 * 来访问指针所指向的那个地址上的变量。此时 * 是一个单目运算符，用来访问指针的值所表示的低智商的变量。</font>可以做右值，也可以做左值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i ;<span class="comment">// p 指向 i</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>,&amp;i) ;<span class="comment">//查看 i 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; p = %p\n&quot;</span>,p) ;<span class="comment">//查看 p 的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>,&amp;p) ;<span class="comment">//查看 p 的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;<span class="comment">//*p 作为一个整体，表示的是 i 的值，所以是一个整数，此时 *p 作为右值</span></span><br><span class="line">*p =  <span class="number">1</span> ;<span class="comment">//此时 *p作为左值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; i = %d\n&quot;</span>,i) ; <span class="comment">//查看 i 的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　最后的结果是：</p><blockquote><p>&amp;i = 0x100010<br> p = 0x100010<br>&amp;p = 0x100018<br>*p = 0<br>i = 1</p></blockquote><p>　　1、把 i 的地址交给 p 后，p 的值就是 i 的地址，而 p 的地址和 i 的地址不相同<br>　　2、<code>printf(&quot;*p = %d\n&quot;,*p)</code>这一步相当于是<code>int k = *p ; printf(&quot;k = %d\n&quot;,k </code>，所以也就证明了，*p 读取了 i 的值。说明 *p 可以作为右值，读取地址上的值，成功。<br>　　3、<code>*p =  1</code>就是修改地址上的值，最后可以看到<code> i = 1</code>，所以修改地址上的值也成功。</p><p>　　综上，<code>*p</code>可以访问地址上的值，也可以修改地址上的值。 </p><h2 id="左值"><a href="#左值" class="headerlink" title="左值"></a><FONT COLOR = Cyan>左值</font></h2><p>　　在做赋值运算的时候，赋值号左边可以不是变量，左边可以是值。这种可以被赋值的值，称之为左值：<br>　　<code>a[0] = 2 ；</code>这里左边不是变量，是值，是表达式计算的结果，[ ] 是特殊的运算符，用来取数组的下标。<br>　　<code>*p = 2 ；</code>这里左边也不是变量，而是指向变量的值，是表达式计算的结果， 但是他也能赋值。<br>　　所以严格意义上来说，赋值号左边不一定是变量，所以称之为左值；赋值号右边称之为右值。</p><h2 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp; 和 *"></a><FONT COLOR = Cyan>&amp; 和 *</font></h2><p>　　在指针中，有两个运算符，他们是互为相反作用的：<br>　　&amp;：取变量的地址。*：访问地址上的变量。可以说他们是互为逆运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*a = &amp;A</span><br><span class="line">*&amp;A → *(&amp;A) → *(A的地址) → 得到那个地址上的值 → A的值      </span><br><span class="line">&amp;*a → &amp;(*a) → &amp;(地址上的值，就是A) →得到A的地址→ A的地址就是a</span><br></pre></td></tr></table></figure><h2 id="scanf的”不合理”"><a href="#scanf的”不合理”" class="headerlink" title="scanf的”不合理”"></a><FONT COLOR = Cyan><code>scanf</code>的”不合理”</font></h2><p>　　为什么像这种代码编译器不会报错：<code>int i ;scanf(&quot;%d&quot;,i);</code>。此时 i 是整数，而在32位架构下，整数和地址是一样大的，所以当这么写的时候，把一个整数传进去，或者把一个地址传进去，他们长的是一样的， <code>scanf</code>无法辨别其区别。<br>　　所以此时编译不一定会报错，但是运行一定会出错。运行一定出错是因为<code>scanf</code>把他读入的量写在了内存其他地方，写在了不该写的地方。</p><h1 id="指针应用"><a href="#指针应用" class="headerlink" title="指针应用"></a><FONT COLOR = SpringGreen>指针应用</font></h1><h2 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a><FONT COLOR = Cyan>返回多个值</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景1：函数需要返回多个值！</font>函数是只能返回一个值的，如果需要返回多个值，那就只能通过指针返回。传入的参数的地址，然后利用这个地址把函数里面变量的值带出来。<Font Size = 2>（这句话感觉很绕，但仔细体会体会，能明白的）</font>传入的参数，实际上是需要返回值的地址以及变量。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Exchange</strong></font></h3><p>　　当时在《函数》那章的时候，曾经有一个问题，就是是否可以编写一个函数，用来交换 a 和 b 的值。当时的答案是不行的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为 main 和函数是参数和值的关系，main 提供参数给函数，而函数把值传给 main。所以当需要返回多个值的时候，单纯靠函数是做不到的，但是有了指针就不一样了！因为在函数可以利用指针来访问 main 里面变量的地址，从而达到交换变量值的目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a , b ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line">exchange( &amp;a , &amp;b ) ; <span class="comment">//对于指针变量的函数，调用的时候注意，传的是地址，而不是值！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> *pa , <span class="keyword">int</span> *pb )</span></span>&#123;<span class="comment">//此时函数拿到 a b 的地址</span></span><br><span class="line"><span class="keyword">int</span> t = *pb ;<span class="comment">//访问 b 地址上的值，并且把该值传给 t</span></span><br><span class="line">*pb = *pa ;<span class="comment">//访问 a 地址上的值，并且把该值传给 b</span></span><br><span class="line">*pa = t ;<span class="comment">//把 t 的值传给 a 地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Max-和-Min"><a href="#Max-和-Min" class="headerlink" title="Max 和 Min"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>Max 和 Min</strong></font></h3><p>　　编写一个函数，可以判断一个数组里面的最大值和最小值。此时显然函数需要返回两个结果，所以必须要用指针来完成这件事情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//这四个参数一个都不能少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> , <span class="number">56</span> , <span class="number">74</span> , <span class="number">12</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );<span class="comment">// &amp;min 和 &amp;max 是从 main 传进函数的参数，他们的作用是把函数里面的值带出来！！！！！！！！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;max = %d , min = %d&quot;</span>,max ,min) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//对于传进来的地址，定义函数的时候得是指针变量</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;<span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q 1：能不能不要 length ，直接在函数里面使用<code>sizeof(a)/sizeof(a[0])</code>？<br>　　不能，如果调用函数的时候，参数没有<code>sizeof(a)/sizeof(a[0])</code>，那么函数里面是访问不了 a 的。</p><blockquote><p>[Error] ‘a’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>Q 2：传值的时候能不能不传数组 a？<br>　　不能，原因同上！只要是函数要用的参数，调用函数的时候都要传值给函数，不然函数无法访问 main 的变量。错误也同上。</p><p>Q 3：调用函数的时候，数组写成了 a[ ] 怎么办？<code>minmax( a[] , &amp;min , &amp;max ,length );</code><br>　　[ ] 实际上是一个运算符，在数组里面索引，所以此时<code>a[]</code>是空的，因为没有值，此时会发生奇奇怪怪的错误：</p><blockquote><p>[Error] expected expression before ‘]’ token</p></blockquote><h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a><FONT COLOR = Cyan>返回结果</font></h2><p>　　<FONT COLOR = LimeGreen>指针应用场景2：函数返回运算的状态，结果通过指针返回</font>。函数在运行的过程中，可能会遇到一些特殊的状态，此时函数无法得到正确的结果。<br>　　此时常用的套路就是让函数返回特殊的，不属于有效范围内的值，来表示出错；在文件操作中，常见的就是让函数返回 -1 或 0 来表示函数出错。<br>　　但是如果函数返回的任何数值都是有效的可能结果时，此时无法通过返回值来判断函数是否运行正确，此时就只能让函数的结果，和需要用的结果分开返回。<FONT COLOR = LimeGreen>一般函数的状态用 return 来返回，而实际的值通过指针来返回。</font></p><h3 id="除法函数"><a href="#除法函数" class="headerlink" title="除法函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>除法函数</strong></font></h3><p>　　对于<code>divide()</code>函数，如果除法成功，函数返回值为 1 ；如果除法失败，函数返回值为 0 。此时函数需要两个东西，一个是除法是否成功，一个是除法的值；所以函数的状态用函数的 return 来返回，除法的值用指针带出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a , b , result ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( divide( a , b , &amp;result) == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;除数不能为0\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">( <span class="keyword">int</span> A , <span class="keyword">int</span> B , <span class="keyword">int</span> *Result)</span></span>&#123;<span class="comment">//需要函数返回值的时候，就不能用void </span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span>( B == <span class="number">0</span> )&#123;<span class="comment">//如果除数是0，此时指针里是没有任何有用的结果</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">*Result = A / B ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当运算可能会出错的时候，C只能通过指针来解决。在后续的语言（C++、Java）采用了异常机制来解决这个问题</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a><FONT COLOR = Cyan>常见错误</font></h2><p>　　<FONT COLOR = LimeGreen>定义了指针变量，还没有指向任何变量，就开始使用指针。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p ;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">12</span> ;</span><br><span class="line">*p = <span class="number">12</span> ;</span><br></pre></td></tr></table></figure><p>　　这种做法编译器不会报错，因为 *p 在编译器里就是可以看做一个整数。</p><p>　　所有的本地变量在没有初始化的时候，是不会有默认的初始值的，这个本地变量所在的地址上有什么，他就是什么。对于指针，如果没有指向任何变量的时候就开始使用它，比如这段代码的<code>*p = 12 </code>；他可能指向一片莫名其妙的地方，然后在那片奇怪的地方写入12。如果那块地方是个不能写的地方，此时会报错；如果那块地方可以写，此时不会报错。但这个指针变量也是没意义的，因为没有储存地址！</p><h1 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a><FONT COLOR = SpringGreen>指针与数组</font></h1><p>　　如果把一个普通的变量传入函数，函数接收到的是值；如果把一个指针传入函数，函数接受到的也是值，只不过这个值是一个地址；给函数传入数组的话，到底传入函数的数组成了什么？函数接收到的是什么？ 为什么上面的 Max 和Min   程序里面，不能在函数里使用 <code>sizeof(a)</code>？用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在 main 里数组的大小 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a) = %lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;<span class="comment">//查看在minmax函数里数组的大小</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　结果分别是40、8。 这个 8 刚好和一个指针的大小是相同的！如果对于比较严格的编译器，会出现一个 warning：</p><blockquote><p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [ ] ‘.</p></blockquote><p>　　这个警告的意思是，对于函数的数组的 <code>sizeof </code> 返回的是‘int *’的大小，而不是数组的大小。说明在函数里面的数组，实际上是一个指针！用以下代码验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在 main 里数组 a 的地址 </span></span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;minmax a = %p\n&quot;</span>,&amp;a) ;<span class="comment">//查看在函数里数组 a 的地址 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时可以发现，在 main 和函数里面，a 的地址是相同的。这说明在函数里面数组a和 main 里面的数组a是一个东西。再用以下代码来验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; <span class="comment">//查看a[0]的值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> a[] , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里会发现，a[0] 的数值变了。<FONT COLOR = LimeGreen>一般来说，函数里一个变量的值变化了，是不会改变 main 里面这个变量的值。除非是指针。从这里就可以看出来，数组的本质就是指针</font>。<br>　　所以在函数定义的时候，如果是数组变量一定得写<code>a[ ]</code>，方括号里不能加数；函数里不能使用<code>sizeof</code>。因为他的本质就是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>;<span class="comment">//原型里，把数组改成指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span> , <span class="number">11</span> , <span class="number">332</span> ,<span class="number">1324</span> , <span class="number">12</span> , <span class="number">34</span> &#125; ;</span><br><span class="line"><span class="keyword">int</span> min = a [<span class="number">0</span>] , max = a [<span class="number">0</span>] ;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ;</span><br><span class="line">minmax( a , &amp;min , &amp;max ,length );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[<span class="number">0</span>]) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax</span><span class="params">( <span class="keyword">int</span> *a , <span class="keyword">int</span> *MAX , <span class="keyword">int</span> *MIN , <span class="keyword">int</span> Length)</span></span>&#123;<span class="comment">//定义里，把数组写成指针</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1000</span> ; <span class="comment">//尝试在函数里去给数组单元赋值 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; Length  ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; *MAX)&#123;</span><br><span class="line">*MAX = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( a[i] &lt; *MIN)&#123;</span><br><span class="line">*MIN = a[i] ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　编译成功！运行正确！</p><p>　　所以我们可以说<FONT COLOR = LimeGreen>函数参数表中的数组实际上就是指针</font>。<code>sizeof(a) == sizeof(*int)</code>；但是可以用数组的运算符<code>[]</code>进行运算。<br>　　<FONT COLOR = LimeGreen>所以以下四种函数原型是等价的：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *ar , <span class="keyword">int</span> n )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * , <span class="keyword">int</span> )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[] , <span class="keyword">int</span> n )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">( <span class="keyword">int</span> [] ,<span class="keyword">int</span>)</span> </span>;</span><br></pre></td></tr></table></figure><p>　　 <FONT COLOR = LimeGreen>数组变量是特殊的指针</font><br>　　1、数组变量本身就表达地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> *p = a ;<span class="comment">//无需使用 &amp; 取地址，就能够把地址交给指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,a) ;<span class="comment">//无需使用 &amp; 取地址，就可以吧地址交给 printf 输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;<span class="comment">//两者结果相同</span></span><br></pre></td></tr></table></figure><p>　　但是数组的单元表达的是变量，需要用 &amp; 取地址。</p><p>　　2、数组的地址和第一个元素的地址相同<code>a == &amp;a[0]</code></p><p>　　3、<code>[]</code>使运算符，可以对数组做，也可以对指针做。 p [ 0 ] 相当于 *p</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>,*p) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[0] = %d\n&quot;</span>,p[<span class="number">0</span>]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;a) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p) ;</span><br></pre></td></tr></table></figure><p>　　4、* 运算符可以对指针做，也可以对数组做：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span> , <span class="number">2</span> &#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*a = %d\n&quot;</span>,*a) ;</span><br></pre></td></tr></table></figure><p>　　此时<code>*a</code>的值是<code>a[0]</code>的值。和指针一样，可以对这个值进行读写操作。</p><p>　　5、数组变量是 const 的指针，所以不能被赋值。<br>　　前面学过，像这种数组给数组赋值，是不被允许的<code>int b[] = a []</code>。数组变量间是不允许相互赋值的。因为<code>int b[] </code>相当于是<code>int * const b ;</code>相当于这个 b 是一个常数，是不可以被改变的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指针（上）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 08 Array</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/08/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2008%20Array/</id>
    <published>2021-03-08T13:59:47.000Z</published>
    <updated>2021-04-03T07:48:20.734Z</updated>
    
    <content type="html"><![CDATA[<p>数组</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><FONT COLOR = SpringGreen>数组</font></h1><p>　　数据可以存放在变量里，每一个变量有一个名字，有一个类型，还有它的生存空间。如果我们需要保存一些相同类型、相似含义、相同生存空间的数据，我们可以用数组来保存这些数据，而不是用很多个独立的变量。数组是长度固定的数据结构，用来存放指定的类型的数据。一个数组里可以有很多个数据，所有的数据的类型都是相同的。</p><h2 id="初见数组"><a href="#初见数组" class="headerlink" title="初见数组"></a><FONT COLOR = Cyan>初见数组</font></h2><p>　　如何写一个程序计算用户输入的数字的平均数？并且输出所有大于平均数的数？——即如何写一个程序用来记录用户输入的所有的数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , sum = <span class="number">0</span> , i = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> average ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="comment">//定义一个数组，大小是100，每个单元都是int，所以这个数组最多可以放100个int </span></span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="comment">//i是递增的，于是恰好可以用i来作为指示位置的参数 </span></span><br><span class="line"><span class="comment">//以这种形式对数组中的每个元素赋值</span></span><br><span class="line">sum = sum + x ;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> )&#123; <span class="comment">//这里i大于0就说嘛至少读入了一个数 </span></span><br><span class="line">average = <span class="number">1.0</span> * sum / i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, average ) ;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; i ; j++)&#123; </span><br><span class="line"><span class="comment">//这个 for 循环目的是为了遍历数组number里面所有的元素 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,number[j]) ;</span><br><span class="line"><span class="comment">//输出number里所有的元素</span></span><br><span class="line"><span class="keyword">if</span>( number[j] &gt; average )&#123;</span><br><span class="line"><span class="comment">//使用数组中的元素</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,number[j]) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　可以用一下代码查看一下，程序中，数组具体的运行情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span> , x ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; <span class="number">5</span> ; i++ ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line">number[i] = x ;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>,i) ;</span><br><span class="line"><span class="keyword">for</span>(; j &lt;= i ; j++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,number[j]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其运行结果如下：</p><p><img src="https://www.hualigs.cn/image/6052e612d5a00.jpg"></p><p>　　可以看出来，第一轮在数组0的位置上放了1，第二轮在数组1的位置上放了2……</p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a><FONT COLOR = Cyan>定义数组</font></h2><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的定义</strong></font>：<br>　　<FONT COLOR = LimeGreen>&lt; 类型 &gt; 变量名称 [ 元素数量 ]</font>。这个类型并不是指的数组的类型，严格意义来说而是数组中每一个单元的类型。<br>　　<code>int grades [100];</code>这个数组里面有100个元素，每个元素都是 int 型。<br>　　<code>double weight [20]</code> 这个数组里面有20个元素，每个元素都是double型。<br>　　元素的数量一定要是整数。<br>　　<Font Size = 2>C99以前，元素的数量一定要是常数。但是C99以后，元素的数量也可以是变量。</font></p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>数组的宏观感受</strong></font>：类似一种容器，有三个特点：<br>　　1、所有的元素都有相同的数据类型<br>　　2、一旦创建，就不能改变大小<br>　　3、数组中的元素在内存中是连续依次排序的。</p><p>　　以 <code>int a [10]</code>为例：<br>　　这是一个 int 型的数组，这个数组里有10个元素，每个单元都是一个 int 型的变量，分别是：a[0]、a[1],……,a[9]。<br>　　数组的每个单元就是数组类型的一个变量，使用数组时，放在 [ ] 中的数字叫做下标或索引，下标是从 0 开始计数。所以最大的下标是数组大小减一。<br>　　数组的元素可以出现在赋值的左边或者右边。<code>a[2] = a[1] + 6 ;</code>是可以这么写的。赋值左边称为左值，在指针里面会知道，左值和右值是有区别的。</p><p>　　<Font Color = DarkCyan size = 4 Face = 仿宋><strong>有效的下标范围</strong></font><br>　　编译器和运行环境都不会去检查数组下标<Font Size = 2>（也可以叫做索引）</font>是否越界，无论是对数组单元做读还是写。<br>　　一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃：</p><blockquote><p>segmentation fault</p><p>array index _ is past the end of the array</p></blockquote><p>　　也有可能运气好，没造成严重地后果，程序运行正常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　比如这种情况，<code>a[10] = 0 ;</code>实际上已经出错了，但是编译器并没有报错，实际上，这段代码把 0 写到了不该写的地方，带来的后果是，程序实际上没有运行。比如有以下手段来检验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">f() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main here\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A here\n&quot;</span>) ;</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;B here\n&quot;</span>) ; <span class="comment">//这种技巧常常用来判断程序运行状况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　P.S. 不同的编译器要求不一定相同，但这样的写法是不安全的。</p><p>　　所以一个好的习惯，<FONT COLOR = LimeGreen>就是保证程序只去使用有效的下标值：0 ~ 数组大小-1。</font></p><p>　　所以上面那个计算平均数的程序是有一定风险的，因为一旦用户输入的数字超过100个，程序就报错了。解决办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数字的数量： \n&quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;count) ;</span><br><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">int</span> number[count] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　让用户先想好要输入数字的数量，然后定义数组的大小，这种写法，是C99 Only。</p><p>　　<Font Size = 2><code>int a [0] ;</code>这种东西可以存在，但是毫无用处，因为此时数组的大小是空的，即便是 a [0] 也越界了。</font></p><h2 id="例子：统计个数"><a href="#例子：统计个数" class="headerlink" title="例子：统计个数"></a><FONT COLOR = Cyan>例子：统计个数</font></h2><p>　　写一个程序，输入数量不确定的 [ 0 , 9 ] 范围内的整数，统计每一种数字出现的次数，输入 -1 表示结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ; <span class="comment">//c99 only ，为了避免程序出现magic number</span></span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> count[ number ] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">count[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个for循环的目的是定义10个变量，且每个变量的初始值都是0 </span></span><br><span class="line"><span class="comment">//这个循环是使用数组的时候常用的，初始化数组循环 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">9</span> )&#123;</span><br><span class="line">count[ x ]++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个循环的目的是计数，仔细思考下</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span> , i , count[i]) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//这个循环就是对数组 count 的遍历 </span></span><br></pre></td></tr></table></figure><h1 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a><FONT COLOR = SpringGreen>数组运算</font></h1><p>　　如何去写一个   搜索的程序？先看看以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组集成初始化"><a href="#数组集成初始化" class="headerlink" title="数组集成初始化"></a><FONT COLOR = Cyan>数组集成初始化</font></h2><p>　　<code>int a[] = &#123;2,4,6,7,1,3,5,9,11,13,23,14,32&#125; ;</code>这段代码是<FONT COLOR = LimeGreen>数组的集成初始化</font>。定义数组时有两种办法，第一种是不去初始化它，第二种方法就是这样，直接用大括号给出数组的所有元素的初始值——给他一组数字，用这组数字去初始化数组。<br>　　使用这种办法的时候，不用给出数组的具体大小，[ ] 里没有数字，让编译器来数数。<br>　　如果强行去给数组的大小，而且后面的值不匹配怎么办？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">13</span>] = &#123;<span class="number">2</span>&#125;;<span class="comment">//这里就是强行定义数组大小，且大于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">13</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种情况下，输出值如下：</p><p><img src="https://www.hualigs.cn/image/6061a78f25d41.jpg"></p><p>　　可以说，这种情况下，其实就是给<code>a[0]</code>赋值，其余没有赋值，编译器则用0来补充。所以以下两种写法是相同的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　反过来呢？如果定义的数组长度小于集成初始化给的长度呢？看下面代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ;<span class="comment">//强行规定数组大小，且小于后面的集合</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]<br>[Warning] excess elements in array initializer [enabled by default]<br>[Warning] (near initialization for ‘a’) [enabled by default]</p></blockquote><p>　　此时会有如上警告。</p><p>　　还有一个小问题，如果对于大小为3个的数组，在遍历输出的时候，如果不小心输出的长度大于3会如何？看下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061c5e0007d3.jpg"></p><p>　　可以看出来，前三位是正常的，分别是<code>a[0] a[1] a[2]</code>但是后面的数，就是程序不存在的东西，实际上是内存原有的东西。</p><h2 id="集成初始化定位"><a href="#集成初始化定位" class="headerlink" title="集成初始化定位"></a><FONT COLOR = Cyan>集成初始化定位</font></h2><p>　　C99 only！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>　　用<code>[n]</code>在初始化数据中给出定位。<br>　　没有定位的数据接在前面的位置后面，比如这个定义，实际上<code>a[3] = 6</code>。<br>　　其他位置的值补零。<br>　　也可以不给出数组大小，让编译器自己算，比如这个数组，如果不给出长度为10，那么编译器会认为他的长度为3。<br>　　特别适合初始数据稀疏的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6061d836cd5cb.jpg"></p><h2 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a><FONT COLOR = Cyan>数组的大小</font></h2><p>　　<code>sizeof</code>是一个运算符，可以告诉我们这个量有多大。对数组使用<code>sizeof</code>可以给出整个数组所占据的内容大小，单位是字节。可以求出这个数组占据多少个字节。<br>　　比如上条程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n&quot;</span>,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>])) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时就会输出40、4。说明在改数组中，一个元素占据4个字节，一共占据40个字节，所以一共有十个元素。</p><p><FONT COLOR = LimeGreen>　　所以对于任何一个数组，可以使用<code>sizeof(a)/sizeof(a[0])</code>来计算数组中的元素。</font>这样的代码，最大的好处是：一旦修改数组中初始的数据，不需要修改遍历的代码，比如把遍历的代码改成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;</span><br><span class="line">[<span class="number">0</span>] = <span class="number">2</span> , [<span class="number">2</span>] = <span class="number">3</span> , <span class="number">6</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ; i++ )&#123;<span class="comment">//这样就安全多了，也不会出现 magic number</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a><FONT COLOR = Cyan>数组的赋值</font></h2><p>　　已知一个数组<code>a[]</code>，能不能用这个数组直接给另外一个数组赋值？比如说;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,&#125; ;<span class="comment">//最末尾这个逗号可有可无</span></span><br><span class="line"><span class="keyword">int</span> b[] = a ; <span class="comment">//无效的初始值设定项</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时会报错：</p><blockquote><p>[Error] invalid initializer</p></blockquote><p>　　<FONT COLOR = LimeGreen>数组变量本身不能被赋值，要把一个数组的所有元素交给另一个数组，必须采用遍历</font></p><p>　　以下就是目前接触的遍历数组的情况。<br>　　其中<code>length = sizeof(a)/sizeof(a[0])</code></p><p>　　把数组 a 的值全都赋值给数组 b ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line">b[i] = a[i] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　把数组 a 全部赋值为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length; i++ )&#123;</span><br><span class="line">a[i] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有和关键字相同的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++  )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　判断数组中是否有大于平均数的数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a[i] &gt; average)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , a[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　遍历数组，并且将他们全部输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,i,a[i]) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>对于数组的遍历，通常是使用 for 循环，让循环变量 i 从 0 到（&lt;） 数组的长度</font>，这样循环体内的 i 正好是数组最大的有效下标（length -1）。<br>　　<FONT COLOR = LimeGreen>常见错误</font>：<br>　　循环结束条件是 &lt;= 数组长度。此时刚好会多输出一个量，此时程序会超过数组的长度（非常危险）。<br>　　离开循环后，继续用 i 的值来做数组元素的下标。此时 i 的值是 length 也就是说已经超过数组范围了。</p><h2 id="搜索程序解读"><a href="#搜索程序解读" class="headerlink" title="搜索程序解读"></a><FONT COLOR = Cyan>搜索程序解读</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>主程序</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">23</span>,<span class="number">14</span>,<span class="number">32</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="keyword">int</span> loc ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字： &quot;</span>) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">loc = search( x , a , <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]) ) ;</span><br><span class="line"><span class="keyword">if</span>( loc != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>,x,loc) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　其中，主程序会调用 search 这个函数，并且返回一个值给 loc 。如果返回值是 -1 ，则说明输入的数字不在数组中；否则，则输出该数字在改数组的第几位。</p><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>search 函数</strong></font>：</p><p>　　找出 key 在数组 a 中的位置，其中该函数有三个参数：<br>　　key ：要寻找的数字。a 要寻找的数组。length 数组a 的长度。<br>　　ret 是函数最后的返回值，如果找到，则让 ret 返回为 key 在 a 的位置。如果找不到就返回 -1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">( <span class="keyword">int</span> key , <span class="keyword">int</span> a[] , <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; length ; i++)&#123;<span class="comment">//对数组遍历，每次遍历是拿出一个单元，判断和 key 是否相等。</span></span><br><span class="line"><span class="keyword">if</span>( a[i] == key )&#123;</span><br><span class="line">ret = i ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>当函数的参数是数组的时候</font>，比如这个 search 函数，往往必须再用另一个参数传入数组的大小，此时不太好用 <code>sizeof(a)/sizeof(a[0])</code>。<br>　　此时不能在 [ ] 中直接给出数组的大小，也不能利用 sizeof 计算数组的元素个数。<br>　　所以这里引入 length 。</p><h1 id="例子：素数"><a href="#例子：素数" class="headerlink" title="例子：素数"></a><FONT COLOR = SpringGreen>例子：素数</font></h1><p>　　先复习一下，之前用 if - else 判断素数的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">int</span> x , i ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; i &lt; x ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isPrime)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是素数&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数&quot;</span>) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序有个缺陷，对于 n 可能要循环 n - 1 遍，如果 n 非常大，则程序效率不高。</p><h2 id="算法改进1"><a href="#算法改进1" class="headerlink" title="算法改进1"></a><FONT COLOR = Cyan>算法改进1</font></h2><p>　　首先判断 x 是否为偶数，如果是偶数，立马认为其不是素数。去掉偶数后，让 i 从 3 到 x - 1 ，每次都加 2。具体操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt; x ; i = i + <span class="number">2</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　由于几乎去掉了所有的偶数，所以和原来相比，我们只需要走一半的循环即可。</p><h2 id="算法改进2"><a href="#算法改进2" class="headerlink" title="算法改进2"></a><FONT COLOR = Cyan>算法改进2</font></h2><p>　　不需要到 x - 1，到 <code>sqrt(X)</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x == <span class="number">1</span> || ( x % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">2</span>))&#123; <span class="comment">//注意这个逻辑表达</span></span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">3</span> ; i &lt;= <span class="built_in">sqrt</span>(x) ; i = i + <span class="number">2</span> )&#123;<span class="comment">//这里老师写成了小于，我认为应该是小于等于。</span></span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　为什么只要算到根号x即可？因为整除嘛。这样大大提高了效率。</p><h2 id="算法改进3：构造素数数组"><a href="#算法改进3：构造素数数组" class="headerlink" title="算法改进3：构造素数数组"></a><FONT COLOR = Cyan>算法改进3：构造素数数组</font></h2><p>　　只要拿比 x 小的素数除一除就可以了（分解质因数原理），所以要先构造一张已经有了的素数的表。</p><p>　　比如先要构造一张前100个素数的表（数组），main 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>其中这里的<code>prime[count++] = i ;</code>是一个套路。</font>对于这个大小为100的数组，[ 0 ] 上已经放了 2 。所以接下来就是让 [ 1 ] 这个位置上放置接下来的一个素数。<code>prime[count++] = i ;</code>实际上是，现在自加 1 之前的位置上，放置 i ，然后再对count 自加 1 。所以，如果这里 count 的初始值是 0 ，那么就应该是<code>++count</code>。</p><p>　　其中，判断素数的函数 <code>isPrime()</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123; <span class="comment">//这个for循环实际上是对数组 knownPrimes[] 的遍历</span></span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　该函数需要三个参数，分别是 x 、已经判断过的素数、素数排行（是第几个素数）。该函数里面的 i 和 main 函数里面的 i 是不同的，这个 i 是独立的。<br>　　<code>x</code>，就是我们需要判断的数，这个函数就是用来判断 x 是不是素数。<br>　　<code>knownPrimes[ ]</code> ，可以看到，第二个参数是一个数组，这个数组就是 main 函数里的 prime 。<FONT COLOR = RED>这里有个问题，为什么 main 里面调用函数的时候第二个参数给的是 prime ，这里的 prime 值是多少？</font>总而言之，这个数组应该是一个素数集合。<br>　　<code>numberofKnowPrimes</code>就是目前已经有了多少个素数。注意 for 里面的，是小于号。</p><p>　　为了更好地了解这两段代码的运行模式，可以加一段调试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d \t count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>　　为了美观，可以用同样调试的技巧，在<code>while</code>前面加一段表头的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">10</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;</span><br><span class="line">&#123;<span class="comment">//为了美观，输出几个表头与后面的调试代码对齐</span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 和外面的 i 无关 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>) ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i ) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;  </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="comment">//这段代码起调试作用 </span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot; i = %d count = %d\t&quot;</span> , i , count) ;<span class="comment">//输出当前的 i ，当前的 count（调试前的值） </span></span><br><span class="line"><span class="keyword">int</span> i ;<span class="comment">//这个 i 会覆盖掉外面的 i，且离开大括号后会消失 ,在程序遇到这个i之后，就会覆盖掉外面的i </span></span><br><span class="line"> <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123; <span class="comment">//遍历 prime[] 并且输出 </span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]) ;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;<span class="comment">//调试一次后换行</span></span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后遍历并且输出 <code>prime[ ] </code>这个数组，并且为了美观，每个数都输出一个制表符，然后每五个数换一次行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123; <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后构造前100个素数的数组程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] = &#123;<span class="number">2</span>&#125; ;<span class="comment">//这里写int prime[number] 会报错，C++才能这么写</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span> ;<span class="comment">//从3开始判断这个数是不是素数。</span></span><br><span class="line"><span class="keyword">while</span>( count &lt; number )&#123;</span><br><span class="line"><span class="keyword">if</span>( isPrime( i , prime , count))&#123;</span><br><span class="line">prime[count++] = i ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//这里不能自作聪明写 i = i + 2 。有很多素数相差只有2。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]) ;</span><br><span class="line"><span class="keyword">if</span>( ( i + <span class="number">1</span> ) % <span class="number">5</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> knownPrimes[] , <span class="keyword">int</span> numberofKnowPrimes)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; numberofKnowPrimes ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % knownPrimes[i] == <span class="number">0</span> )&#123;</span><br><span class="line">ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但这里只是构造了一个素数数组，具体如何用这个数组来做素数判断？我以后再研究？初步思路是：<br>　　1、判断这个数是否和数组里面的数相同，如果有相同的，直接判断为素数。<br>　　2、否则的话，让这个数和数组里的数做除法，如果能除尽，直接判断为合数。<br>　　3、否则的话，<Font Size = 2><em>这种情况就比较复杂，这个素数数组里最后两个数是 523 和 541。也就是说，比 <code>523 * 541 </code>大的数，这个数组就判断不了了。</em></font>我目前想着，int 型最大的数是 (2^31)-1，是十位数，所以让 number = 10000，就基本在 int 不爆炸的情况下，用第二步算完了。</p><p>　　<font color = red> 但是这样子，每次都要循环遍历检验一次数组，这样真的会加快效率吗？存疑</font></p><h2 id="算法改进4：构造素数表"><a href="#算法改进4：构造素数表" class="headerlink" title="算法改进4：构造素数表"></a><FONT COLOR = Cyan>算法改进4：构造素数表</font></h2><p>　　欲构造 n 以内的素数表：<br>　　1、令 x 为2<br>　　2、将 2x、3x、4x 直到 ax &lt; n 全部标记为非素数。<br>　　3、令x为下一个没有被标记为非素数的数，重复2；直到所有的数全部尝试完毕。</p><p>　　这个算法，相当于从 2 开始，一直到 n，一个个把素数的倍数给划掉。最后留在表里面的，全是素数。伪代码如下：</p><p>　　欲构造 n 以内（不含）的素数表：<br>　　1、开辟<code>prime[n]</code>，初始化所有元素为1，<code>prime[x]</code>为1就表示 x 是素数。<br>　　2、令 x = 2<br>　　3、如果 x 是素数，则对于<code>( i = 2 ; x * i &lt; n ; i++ )</code>令<code>prime[x * i] = 0</code><br>　　4、令 x++ ，如果 x &lt; n ，重复3，否则结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历初始化</span></span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;<span class="comment">//遍历输出，这样会使得0，1一定会输出，可以让i从2开始。</span></span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　翁老师还改进了一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>] ;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line">prime[i] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x ; </span><br><span class="line"><span class="keyword">for</span>( x = <span class="number">2</span> ; x &lt; number ; x++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[x] )&#123;<span class="comment">//这里加一个 if 之后，比如当 x 是15的时候，程序就不会进入这个if了，因为早在 x 是3的时候，prime[15]就被赋值为0.</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">2</span> ; x * i &lt; number ; i++ )&#123;</span><br><span class="line">prime[ x * i ] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">2</span> ; i &lt; number ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( prime[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><FONT COLOR = SpringGreen>二维数组</font></h1><p>　　<code>int a[10]</code>这个数组只有一个下标，可以看做是一维数组，线性的。<br>　　<code>int a[3][5]</code>就是二维数组，对于二维数组，可以理解为 a 是一个3行5列的矩阵：</p><table><thead><tr><th><code>a[0][0]</code></th><th><code>a[0][1]</code></th><th><code>a[0][2]</code></th><th><code>a[0][3]</code></th><th><code>a[0][4]</code></th></tr></thead><tbody><tr><td><code>a[1][0]</code></td><td><code>a[1][1]</code></td><td><code>a[1][2]</code></td><td><code>a[1][3]</code></td><td><code>a[1][4]</code></td></tr><tr><td><code>a[2][0]</code></td><td><code>a[2][1]</code></td><td><code>a[2][2]</code></td><td><code>a[2][3]</code></td><td><code>a[2][4]</code></td></tr></tbody></table><p><Font Size = 2>　　如果不考虑数组在计算机内存中是如何排列的，那么把它看成5行3列也没关系小，但是不建议这么做。倾向于第一个下标为行数，第二个下标为列数</font></p><h2 id="二维数组遍历"><a href="#二维数组遍历" class="headerlink" title="二维数组遍历"></a><FONT COLOR = Cyan>二维数组遍历</font></h2><p>　　用两个 for 循环就可以遍历二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; <span class="number">5</span> ; j++ )&#123;</span><br><span class="line">a[i][j] = i*j ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　　以<code>int a[i][j]</code>为例，该数组里所有的元素都是 int 型。特别注意的是，<code>a[i,j]</code>在C语言里表示<code>a[j]</code>，因为此时逗号是运算符。</p><h2 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a><FONT COLOR = Cyan>二维数组的初始化</font></h2><p><Font Color = DarkCyan size = 4 Face = 仿宋><strong>集成初始化</strong></font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">5</span>] =  &#123;<span class="comment">//列数是不能省略的！！</span></span><br><span class="line">&#123; <span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span> , <span class="number">4</span>&#125; ,</span><br><span class="line">&#123; <span class="number">2</span> , <span class="number">3</span> , <span class="number">3</span> , <span class="number">4</span> , <span class="number">5</span>&#125; ,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　列数是必须给出的，行数可以让编译器来数。<br>　　每行一个 ｛ ｝ ，用逗号分离<br>　　最后的逗号可以存在（古老的传统）<br>　　如果省略，表示补零，和一维数组相同。<br>　　也可以用初始化定位，和一维数组相同（ C99 Only）</p><h2 id="三连棋"><a href="#三连棋" class="headerlink" title="三连棋"></a><FONT COLOR = Cyan>三连棋</font></h2><p>　　读入一个 3 × 3 的矩阵，矩阵中的数字 1 则表示这个位置上有一个 X，数字 0 则表示位置上有一个 O。只要有一方的棋子连成一条线了，则获胜。程序然后判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符 X or O，或输出无人获胜。</p><p>　　读入矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> numOfX , numOfY ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，2：Y赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>　　检查行是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查列是否出现胜利条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　显然这两个循环长得差不多，那么问题来了，能不能用一个两重循环来检查行和列？把他们合并起来？</p><p>　　检查对角线：<br>　　主对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　检查副对角线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;<span class="comment">//这是一个表示副对角线的套路，记忆一下。</span></span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　最后的程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">3</span> ;</span><br><span class="line"><span class="keyword">int</span> board[size][size] ;</span><br><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">-1</span> ;<span class="comment">//-1:没人赢，1：X赢，0：O赢了</span></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numOfX , numOfO ;<span class="comment">//分别表示×O的数量 </span></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size &amp;&amp; result == <span class="number">-1</span> ; i++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; <span class="comment">//每次数一行的时候，都要让这两个东西的初始值是0 </span></span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size ; j++ )&#123; <span class="comment">//固定主行之后，对每一列的元素进行遍历，每出现一次 X就让numOfX加1，否则让numOfO加1 </span></span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;<span class="comment">//行号不变，列号从 0 ~ size </span></span><br><span class="line">numOfX ++ ;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每检查1行，就判断一次是否出现胜负 </span></span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查列</span></span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span> ; j &lt; size &amp;&amp; result == <span class="number">-1</span> ; j++ )&#123;</span><br><span class="line">numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][j] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查对角线</span></span><br><span class="line"> <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][i] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查副对角线</span></span><br><span class="line">  <span class="keyword">if</span>( result == <span class="number">-1</span> )&#123;</span><br><span class="line"> numOfX = numOfO = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; size ; i++ )&#123; </span><br><span class="line"><span class="keyword">if</span>( board[i][size-i<span class="number">-1</span>] == <span class="number">1</span> ) &#123;</span><br><span class="line">numOfX ++ ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">numOfO ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( numOfO == size )&#123;</span><br><span class="line">result = <span class="number">0</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">result = <span class="number">1</span> ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( result == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;X赢了&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>( result == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;O赢了&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不分胜负&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>chapter 07 Function</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/07/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2007%20Function/</id>
    <published>2021-03-07T13:59:47.000Z</published>
    <updated>2021-04-02T09:01:38.438Z</updated>
    
    <content type="html"><![CDATA[<p>函数</p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><FONT COLOR = SpringGreen>函数</font></h1><p>　　不要从数学的意义来理解函数，要从 function（功能）的意义来理解函数。</p><h2 id="初见函数"><a href="#初见函数" class="headerlink" title="初见函数"></a><FONT COLOR = Cyan>初见函数</font></h2><h3 id="求素数和"><a href="#求素数和" class="headerlink" title="求素数和"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>求素数和</strong></font></h3><p>　　求 m ~ n 之间所有素数的和：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i - <span class="number">1</span> ; k++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( isPrime == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br></pre></td></tr></table></figure><p>　　对于里面判断素数的循环，功能是非常单一的——就是判断循环。对于这种功能单一的代码，可以做成一个函数（function），那样既可以让程序变得简洁，也提高了可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m , n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span> , &amp;m , &amp;n ) ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m == <span class="number">1</span> )&#123;</span><br><span class="line">m = <span class="number">2</span> ;</span><br><span class="line">&#125;<span class="comment">//如果没有这段if，那当m为1的时候，下列程序就会把1当素数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>( i = m ; i &lt;= n ; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( Ret(i) == <span class="number">1</span> )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;count = %d sum = %d&quot;</span>,count , sum ) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　### <Font Color = DarkCyan size = 4 Face = 仿宋><strong>多次求和</strong></font></p><p>　　求出1<del>10、20</del>30、35~45 的三个和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i , sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">10</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">20</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">30</span>; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">35</span> , sum = <span class="number">0</span> ; i &lt;= <span class="number">45</span> ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , sum );</span><br></pre></td></tr></table></figure><p>　　这三段是几乎一模一样的。<br>　　Code Duplication，“代码复制”是程序质量不良的表现：<br>　　1、如果将来要做修改维护的时候，会使得维护的地方变得很多。<br>　　2、使代码特别冗长。</p><p>　　对于这种需要重复使用到的“功能function”，不如做成求和函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的定义与使用"><a href="#函数的定义与使用" class="headerlink" title="函数的定义与使用"></a><FONT COLOR = Cyan>函数的定义与使用</font></h2><p>　　函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>定义函数</strong></font></h3><p>　　以下列代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　<FONT COLOR = LimeGreen>　<code>void sum(int begin , int end )</code>称为函数头；<br>　　<code>void</code>是返回类型（空类型，不返回结果）；<br>　　<code>sum</code>是函数名；<br>　　<code>(int begin , int end )</code>是参数表。<br>　　<br>大括号里面的称为函数体，大括号是必须的。</font></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>调用函数</strong></font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">sum(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">sum(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　调用函数时，要首先给出：函数名（参数值）。该函数有多少个参数，就需要传递多少个参数，而且要传递正确的数据类型、给出正确的数量和顺序。这些值会被按照顺序依次用来初始化函数中的参数。<br>　　如果调用的参数少了，或者小括号里没有逗号，就会出现以下错误：</p><blockquote><p>error: too few arguments to function</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数名后的 ( ) 非常重要</font>，这个小括号起到了表示函数调用的重要作用，即使没有参数也需要有小括号。<br>　　比如说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers() ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是如果没有这个小括号，就会报错（有的编译器不会报错，但此时也不会调用函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;干杯&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">cheers ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>warning: expression result unused cheer ;</p></blockquote><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a><FONT COLOR = Cyan>Return</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Ret</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> k ;</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">2</span> ; k &lt; i<span class="number">-1</span> ; k++)&#123;</span><br><span class="line"><span class="keyword">if</span>( i % k == <span class="number">0</span> )&#123;</span><br><span class="line">isPrime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isPrime ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个函数用来判断素数，最后会返回一个值：isPrime。这个返回的结果，最后会返回给调用它的地方。这个函数 Ret 的类型是 int ，所以有一个返回的int的结果。</p><p>　　return 表示停止函数的执行，并且返回一个函数值。return 有两种写法：<br>　　<code>return ;</code>直接结束<br>　　<code>return 表达式</code>把这个值交给函数调用它的地方</p><p>　　比如上段代码，函数运行之后，return 会使得 isPrime 有一个值。后面程序在调用函数的时候，就会把这个值作为运算结果。<Font Size = 2>（讲起来有点绕，后面再看看其他资料）</font></p><p>　　一个函数里可以出现多个return。但是如果一个函数里去使用多个return的话，那么这个函数就会有多个出口，不符合<FONT COLOR = LimeGreen>单一出口原则</font>。</p><p>　　函数的返回值可以赋值给变量、可以再传递给函数、甚至可以丢掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;</span><br><span class="line">c = MAX( a , b ) ;</span><br><span class="line">c = MAX( c , <span class="number">23</span> ) ;</span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;</span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　上述所有写法都是对的，其中所有 MAX 的值，都是函数最后 return 得到的值。<br>　　其中这个<code>MAX(12,34)</code>做了一次调用，但是没有把值交给任何人，就是把函数运行的结果丢掉了。——有时候调用函数的目的并不是要看函数返回的结果，而是要函数的副作用（比如输出一个什么东西）</p><h2 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a><FONT COLOR = Cyan>无返回值的函数</font></h2><p>　　如果我们需要一个没有返回值的函数，以以下代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>void 函数名(参数表)</font></p><p>　　不能使用带值得 return ，如果使用了，会出现以下错误：</p><blockquote><p>[Warning] ‘return’ with a value, in function returning void [enabled by default]</p></blockquote><p>　　可以没有 return ，到函数最后一行，函数自动结束。</p><p>　　调用的时候不能做返回值得赋值。此时 SUM 不会返回值，比如以下程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,SUM) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时的<code>SUM(1,10) </code>就是不需要SUM的值，只需要他的副作用——输出一个和。此时SUM的值如下：</p><p><img src="https://www.hualigs.cn/image/605e9f1b1cb95.jpg"></p><h1 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a><FONT COLOR = SpringGreen>函数的参数和变量</font></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><FONT COLOR = Cyan>函数原型</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C的编译器是自上而下分析代码。所以要把函数的定义像这样写在程序的最开始。<br>　　在看到<code>SUM(1,10) ;</code>的时候，程序需要知道 <code>SUM( )</code> 的样子——<FONT COLOR = LimeGreen>函数的名字、函数需要几个参数，每个参数的类型、返回什么类型</font>。这样编译器才能检查程序对 <code>SUM()</code>的调用是否正确。</p><p>　　如果不这样会发生什么？把要调用的函数放在 <code>main()</code>的下面试一试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ; <span class="comment">//int SUM(int,int)</span></span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下错误：</p><blockquote><p>[Warning] conflicting types for ‘SUM’ [enabled by default]<br>[Note] previous implicit declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>特别注意，不同编译器对C语言的要求都不同，有的严格有的宽松，具体报错的信息不一定相同</font><br>　　conflicting types 意思是类型冲突。</p><p>　　对于C99以前的标准，程序读到<code>SUM(1,10) ;</code>时，发现此时没有定义 <code>SUM()</code>这个函数，程序会去猜 <code>SUM()</code>的情况，会去假设<code>SUM()</code>里的类型是两个int，并且会返回一个 int 值：<code>int SUM(int,int)</code>。这种做法叫做隐式声明，C99以后就不用了。</p><blockquote><p>warning: implicit declaration of function ‘SUM’ is invalid in C99</p></blockquote><p>　　那么当程序读到<code>SUM(1,10) ;</code>时候，程序会猜这个函数是<code>int SUM(int,int)</code>，但后面对函数定义的时候，又定义其为<code>void SUM(int, int)</code>，所以后面程序会 warning： conflicting types </p><p>　　在实际的工程项目中，很多时候都希望第一眼能看到<code>main()</code>的样子，而不是一大堆函数的定义。所以就有了<FONT COLOR = LimeGreen>原型声明——把函数头+分号放到程序最开头。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>; <span class="comment">//原型声明，在 main 函数之前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义，在main函数以后</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　程序看到原型声明后，会先记住函数的样子，然后遇到<code>main</code>里面的函数调用的时候，会先采取原型声明里面的定义，最后读到下面函数定义的时候，再一次检查函数调用是否正确。</p><p>　　如果原型和定义冲突怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　和上面隐式声明一样，出现类型冲突的错误：</p><blockquote><p>[Error] conflicting types for ‘SUM’<br>[Note] previous declaration of ‘SUM’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>函数原型</font><br>　　<code>函数头；</code>函数头以分号结尾就构成了函数原型<br>　　函数原型的目的是告诉编译器这个函数长什么样：<br>　　名称；<br>　　参数数量以及参数类型<br>　　返回类型</p><p>　　函数原型的主要目的是告诉编译器函数长什么样，所以对待具体参数的变量名不做检查和要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>; <span class="comment">//原型声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">SUM(<span class="number">1</span>,<span class="number">10</span>) ;</span><br><span class="line">SUM(<span class="number">20</span>,<span class="number">30</span>) ;</span><br><span class="line">SUM(<span class="number">35</span>,<span class="number">45</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SUM</span><span class="params">(<span class="keyword">int</span> begin , <span class="keyword">int</span> end )</span></span>&#123; <span class="comment">//函数定义</span></span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( i = begin ; i &lt;= end ; i++ )&#123;</span><br><span class="line">sum = sum + i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d ~ %d 的和是%d\n&quot;</span>,begin,end,sum) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时原型声明可以写成：<br>　　<code>void SUM(int, int) ; </code><br>　　<code>void SUM(int a , int b ) ;</code><br>　　都可以，没有关系，因为编译器在原型声明检查的时候不会检查参数名称，只会检查函数名称、返回类型、参数数量和类型。但为了阅读起来方便，最好是直接把函数头复制过来加分号会好一点，因为要方便人去阅读和修改。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><FONT COLOR = Cyan>参数传递</font></h2><p>　　如果函数有参数，调用函数时必须传递给它数量、类型正确的值。可以传递给函数的值是表达式的结果，包括：字面量、变量、函数的返回值、计算结果。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MAX</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">max = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">max = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span>, c ;</span><br><span class="line">c = MAX( <span class="number">10</span> , <span class="number">12</span> ) ;<span class="comment">//字面量</span></span><br><span class="line">c = MAX( a , b ) ;<span class="comment">//变量</span></span><br><span class="line">c = MAX( c+<span class="number">3</span> , <span class="number">23</span> ) ;<span class="comment">//计算的结果</span></span><br><span class="line">c = MAX( MAX( c , a ) , <span class="number">5</span> ) ;<span class="comment">//函数返回值</span></span><br><span class="line">MAX(<span class="number">12</span>,<span class="number">34</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , MAX(a,b)) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是因为C语言对于表达式的定义非常宽，单一的字面量、单一的变量、进行计算的结果、赋值全部都是表达式。函数调用本身、函数调用结果，全部都是表达式。</p><h3 id="类型不匹配"><a href="#类型不匹配" class="headerlink" title="类型不匹配"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>类型不匹配</strong></font></h3><p>　　如果参数传递类型不匹配会怎么样？<br>　　<FONT COLOR = LimeGreen>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞。<br>　　编译器总是悄悄替你把类型转换好，但是这可能不是你所期望的。<br>　　后续的语言，C++/Java 在这方面要求非常严格。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个程序就是非常简单的函数定义以及函数调用，如果调用时参数传递类型不匹配怎么办？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line">cheer(<span class="number">1.1</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时程序实际上是出错了，因为<code>cheer()</code>函数要求参数是整型，而调用时的参数是浮点数。此时编译会有两种情况：<br>　　情况1：编译器给出warning，编译器在执行过程中，故意把double型的1.1转化为了整型的1。</p><blockquote><p>warning: implicit conversion from ‘double’ to ‘int’ change value form 1.1 to 1</p><p>此处出现了一个隐含的转化，从 double 转化为 int。</p></blockquote><p>　　情况2：编译器连 warning 都没有，直接通过了编译。</p><p>　　对于绝大多数编译器，以下写法不会出现 warning。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cheer</span><span class="params">( <span class="keyword">int</span> i )</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;cheers %d\n&quot;</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> f = <span class="number">1.1</span> ;</span><br><span class="line">cheer(f) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　C语言做不到类型匹配的自动检查！！！</p><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>传值</strong></font></h3><p>　　能不能写一个交换 a b 值的函数？试试看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,exchange(a,b)) ;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样的代码可以交换 a 和 b 的值吗？答案是不能的。可以用调试查看一下各个变量的值：</p><p><a href="https://imgtu.com/i/6z6nET"><img src="https://z3.ax1x.com/2021/03/27/6z6nET.png" alt="6z6nET.png"></a></p><p>　　这里可以看出来，当程序运行到 <code>exchange()</code>函数里面的时候，变量 a ，b 的状态都是</p><blockquote><p>Not found in current context。</p><p>在当前上下文找不到</p></blockquote><p>　　也就是说，当程序运行到  <code>exchange()</code>函数里面的时候，变量 a b 都是不存在的。同理，当程序运行到<code>main()</code>函数里面的时候，x y t 也都是不存在的：</p><p><a href="https://imgtu.com/i/6z67q0"><img src="https://z3.ax1x.com/2021/03/27/6z67q0.png" alt="6z67q0.png"></a></p><p>　　尝试一下查看<code>exchange( a , b ) ;</code>的值，看清楚这一步到底是干什么的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exchange(a,b)=%d\n&quot;</span>,exchange(a,b)) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> a , <span class="keyword">int</span> b )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a ;</span><br><span class="line">a = b ;</span><br><span class="line">b = t ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/605f014f01a82.jpg"></p><p>　　可以看出来，<code>exchange( a , b ) ;</code>实际上是进入exchange函数，然后返回 exchange 的值，对于第一段代码<code>void exchange( int a , int b ) ; </code>此时 exchange 不返回值，对于第二段代码<code>int exchange( int a , int b ) ; </code>返回的就是 return 的值。<br>　　除此之外，<code>exchange( a , b ) ;</code>并不能实际上改变 a 和 b 的值。<br>　　所以这样的函数不能交换 a 和 b 的值。</p><p>　　每个函数都有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。<br><FONT COLOR = LimeGreen>　　函数和<code>main</code>的关系是参数和值得关系，C语言在调用函数的时候，永远只能传值给函数。</font></p><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a><FONT COLOR = Cyan>本地变量</font></h2><p>　　Local variables 也翻译成局部变量。<br>　　函数的每一次运行就会产生一个独立的变量空间，在这个空间中的变量是函数的这次运行所独有的，称作本地变量。<br>　　所有定义在函数内部的变量就是本地变量。<br>　　参数也是本地变量。</p><h3 id="生存期和作用域"><a href="#生存期和作用域" class="headerlink" title="生存期和作用域"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>生存期和作用域</strong></font></h3><p>　　生存期：什么时候变量开始出现，到什么时候变量消亡。<br>　　作用域：在代码的什么范围内可以访问这个变量（这个变量可以起作用的领域）<br>　　对于本地变量，这两个答案是统一的：<FONT COLOR = LimeGreen>大括号——块</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当程序运行在<code>main()</code>里面时，t x y 是不存在的：<code>Not found in current context</code>。当程序运行在<code>exchange()</code>里面时，a b也是不存在的，<code>Not found in current context</code>。</p><h3 id="本地变量规则"><a href="#本地变量规则" class="headerlink" title="本地变量规则"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>本地变量规则</strong></font></h3><p>　　<FONT COLOR = LimeGreen>本地变量是定义在块（一组大括号）内的</font><br>　　这个块可以使函数的块，也可以是语句的块，甚至可以随便拉一对大括号来定义变量。比如下面的 if 语句块里面对 i 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;<span class="comment">//这个i生存期和作用域就在这个块里面，离开这个块，i就不存在了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个 i 的生存期和作用域都在 if 控制的这个块里面，所以每次进入<code>main()</code>，这个 i 都不一定存在（因为 if 不一定执行）。如果此时想要在 if 块外面使用 i ，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a &lt; b )&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;<span class="comment">//在i的生存期和作用域之外使用它</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　报错：</p><blockquote><p>[Error] ‘i’ undeclared (first use in this function)<br>[Note] each undeclared identifier is reported only once for each function it appears in</p></blockquote><p>　　<FONT COLOR = LimeGreen>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中变量就消失了</font></p><p>　　对上面程序进行调试就可以知道，进入 if 的时候 i 是存在的，出大括号后 i 就是<code>Notfound in current context</code>。</p><p>　　<FONT COLOR = LimeGreen>在块外面定义的变量在块里面任然有效。</font>里面定义的变量出来就不存在了。</p><p>　　同样对上面程序进行调试，在 if 所控制的块里面， a 和 b 都是可以读到的。</p><p>　　<FONT COLOR = LimeGreen>若块里面定义了和外面同名的变量，则里面的变量会掩盖外面的变量。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其中输出的值为：</p><p><a href="https://imgtu.com/i/cSKYCQ"><img src="https://z3.ax1x.com/2021/03/27/cSKYCQ.png" alt="cSKYCQ.png"></a></p><p>　　可以看出来在 if 控制的块里面，a 的值覆盖了外面 a 的值。但是出来之后，里面的 a 不存在了，a 又回到了初始的状态。</p><p>　　不是所有的编程语言都是这么干的！！！</p><p>　　<FONT COLOR = LimeGreen>不能再一个块里面定义同名的变量</font></p><blockquote><p>[Error] redefinition of ‘a’<br>[Note] previous definition of ‘a’ was here</p></blockquote><p>　　<FONT COLOR = LimeGreen>本地变量不会被默认初始化</font></p><p>　　<FONT COLOR = LimeGreen>参数在进入函数的时候会被初始化</font></p><h2 id="函数庶事"><a href="#函数庶事" class="headerlink" title="函数庶事"></a><FONT COLOR = Cyan>函数庶事</font></h2><h3 id="没有参数时"><a href="#没有参数时" class="headerlink" title="没有参数时"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>没有参数时</strong></font></h3><p>　　<code>void f(void)</code>还是<code>void f()</code><br>　　<code>void f(void)</code>明确告诉编译器，f 函数不接受任何参数。在传统的C中，<code>void f()</code>表示 f 函数的参数未知，并不表示没有参数；现在编译器如何处理呢？尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;<span class="comment">//到这一行的时候，编译器猜测exchange需要两个int型参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">int</span> x , <span class="keyword">int</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　此时编译通过。编译器理解为，遇到函数原型时，知道有一个函数 <code>void exchange</code>，但不太确定他的参数个数和参数类型。于是编译器根据下面，猜想为双变量，int 型。<br>　　如果此时编译器猜错了呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">()</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这段程序通过编译了！<br>　　此时程序输出：<br>　　in exchange ， a = 0.000000，b = 0.000000<br>　　in main ，a = 5 b = 6。<br>　　可以看出来，虽然编译器在语法上没有发现这段程序出错，但实际上程序第一次运行到<code>exchange( a , b ) ;</code>时，是认为 exchange 是 int 型。等到运行完下面的函数部分，第二次运行到<code>exchange( a , b )</code>时，把两个整型的量交给<code>exchange</code>，此时就出错了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">double</span> x , <span class="keyword">double</span> y )</span> </span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">6</span> ;</span><br><span class="line">exchange( a , b ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in main , a=%d b=%d\n&quot;</span>,a,b) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">( <span class="keyword">double</span> x , <span class="keyword">double</span> y )</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = x ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in exchange,a=%f,b=%f\n&quot;</span>,x,y) ;</span><br><span class="line">x = y ;</span><br><span class="line">y = t ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是这种写法就是正确的，此时虽然也是把两个整型交给 exchange 。但是一开始原型声明就正确了，使得后面整型变量会自动转化为 double 型。</p><p>　　<FONT COLOR = LimeGreen>所以，不要这么些函数原型<code>void f()</code></font></p><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>逗号运算符</strong></font></h3><p>　　在C语言里，逗号也是一种运算符，比如<code>(a,b)</code>，此时右边的 b 就是其运算的结果。那么调用函数时的逗号和逗号运算符如何区分？<br>　　<code>F(a,b)</code>调用函数时，小括号的逗号是标点符号，不是运算符。<br>　　<code>F((a,b))</code>此时逗号是运算符，此时函数的参数只有1个，</p><h3 id="不可嵌套定义函数"><a href="#不可嵌套定义函数" class="headerlink" title="不可嵌套定义函数"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>不可嵌套定义函数</strong></font></h3><p>　　C语言里不允许函数的嵌套定义，也就是说函数内部不能再定义函数。可以放函数的声明，但不能放函数体（body）</p><h3 id="糟糕的写法"><a href="#糟糕的写法" class="headerlink" title="糟糕的写法"></a><Font Color = DarkCyan size = 4 Face = 仿宋><strong>糟糕的写法</strong></font></h3><p>　　<code>int i , j , sum( int a , int b )</code>这种写法等同于<code>int i , j ; int sum( int a , int b )</code>不推荐这种写法，不利于阅读。<br>　　<code>return（i）</code>这个 (i) 可有可无，但这会让人误解 return 是一个函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;函数&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 06 Data Type</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/06/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2006%20Data%20Type/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/06/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2006%20Data%20Type/</id>
    <published>2021-03-06T13:59:47.000Z</published>
    <updated>2021-03-29T05:39:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型</p><a id="more"></a><h1 id="逻辑类型和运算"><a href="#逻辑类型和运算" class="headerlink" title="逻辑类型和运算"></a><FONT COLOR = SpringGreen>逻辑类型和运算</font></h1><h2 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a><FONT COLOR = Cyan>逻辑类型</font></h2><p>　　抬头加入<code>#include&lt;stdbool.h&gt;</code>之后，就可以使用 bool、true、 false。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a><FONT COLOR = Cyan>逻辑运算</font></h2><p>　　逻辑运算是对逻辑进行的运算，结果只有0、1。<br>　　！——逻辑非——！a——如果 a 是true，则结果是false；如果 a 是false，则结果是true。<br>　　&amp;&amp;——逻辑与——a&amp;&amp;b——如果 a 和 b 都是true，则结果是true；否则结果是false。<br>　　||——逻辑或——a||b——如果 a 和 b 至少有一个是true，则结果是true；如果 a 和 b 两个都是false，则结果是false。</p><p>　　有了逻辑运算后，就可以非常方便地表示数学里面的区间：<br>　　如果要表示数学中的区间，如：x∈(4，6)，有人会习惯性地写成4&lt;x&lt;6；但这样实际上是首先算4&lt;x，答案是0或者1，然后判断1&lt;6。正确的做法是<code>x &gt; 4 &amp;&amp; x &lt; 6</code>。<br>　　<code>a &gt; 20 &amp;&amp; a &lt; 30</code> 意思是20 &lt; a &lt; 30。<br>　　<code>a &lt; 0 || a &gt; 99</code> 意思是 a＜0 或者 a＞99。<br>　　<code>!a &lt; 20</code> <FONT COLOR = LimeGreen>注意，！是单目运算符，所以！的优先级要比＜要高。</font>因此这句话 ！a 会先做。如果 a 是 0 ，则！a 会变成1，然后和 20 作比较。如果 a 不是 0，则 ！a 会变成0，然后和 20 作比较。所以整个表达式永远都是1。如果非要表示 a 不小于 20 ，应该用括号：<code>!( a &lt; 20)</code></p><p>　　也可以通过逻辑运算很简单地判断一个字符 c 是否是大写字母：<br>　　<code>c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;</code></p><p><FONT COLOR = PowderBlue size = 4><strong>优先级</strong></font></p><p>　　逻辑运算优先级，单目的非！最高，其次是与&amp;&amp;，最后是或 ||。详情见《第二周 计算》中的表格。</p><h2 id="短路"><a href="#短路" class="headerlink" title="短路"></a><FONT COLOR = Cyan>短路</font></h2><p>　　逻辑运算是从左往右进行的，如果左边的结果已经能够决定最终结果了的话，就不会做右边的计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> , b = <span class="number">0</span> ;</span><br><span class="line">a == <span class="number">6</span> &amp;&amp; (b += <span class="number">1</span>)  ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,b) ;</span><br></pre></td></tr></table></figure><p>　　这里“与”的左边是判断 a 是否等于6。对于“与”来说，当左边是 false 的时候，右边的计算就没必要进行下去了。所以此时 b 的值任然是 0 。</p><p>　　<FONT COLOR = LimeGreen>对于&amp;&amp;，左边是 false 时就不做右边了。对于 ||，左边是 true 时就不做右边了。</font><br>　　<FONT COLOR = LimeGreen>所以，千万不要把赋值，以及复合赋值的组合写进表达式。</font></p><h2 id="条件运算"><a href="#条件运算" class="headerlink" title="条件运算"></a><FONT COLOR = Cyan>条件运算</font></h2><p>　　<code>count = ( count &gt; 20 ) ? count - 10 : count + 10</code><br>　　类似于这种代码，问号之前的是条件，问号之后是条件满足的值，冒号之后是条件不满足的值。等价于一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">20</span> )&#123;</span><br><span class="line">count = count - <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">count = count + <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这种条件运算会带来阅读上的麻烦。表面上会使程序变得简洁，但实际上很容易出错。<br>　　条件运算符的优先级高于赋值运算符，但是低于其他运算符。于是就可以有如下几种写法：</p><p>　　<code>m &lt; n ? x : a + 5</code>，如果 m &lt; n 的话，值是 x ，否则的话值是 a + 5。<br>　　<code>a++ &gt;= 1 &amp;&amp; b-- &gt; 2 ? a : b</code>，如果 a++ 的结果大于等于1<Font Size = 2><em>（此时a = 1 满足条件，a=0不满足条件）</em></font>，并且 b– 的结果大于<Font Size = 2><em>（此时 b = 3 满足条件）</em></font>；则结果是 a ，否则是 b 。</p><h2 id="逗号运算"><a href="#逗号运算" class="headerlink" title="逗号运算"></a><FONT COLOR = Cyan>逗号运算</font></h2><p>　　逗号用来连接两个表达式，并且以右边的表达式的值作为它的结果。逗号的优先级是所有运算符中最低的（低于赋值），所以它两边的表达式会先计算，逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line">i = ( <span class="number">3</span>+<span class="number">4</span> , <span class="number">5</span>+<span class="number">6</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i) ;</span><br></pre></td></tr></table></figure><p>　　此时输出 i 的结果是11。<br>　　逗号运算主要用在 for 循环中，比如：<br>　　<code>for ( i = 0 , j = 10 ; i &lt; j ; i++ , j--)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i , j ;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> , j = <span class="number">10</span> ; i &lt; j ; i++ , j--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d,j=%d\n&quot;</span>,i,j) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;out loop i=%d,j=%d\n&quot;</span>,i,j) ;</span><br></pre></td></tr></table></figure><p>　　<a href="https://imgtu.com/i/cSGJeA"><img src="https://z3.ax1x.com/2021/03/27/cSGJeA.png" alt="cSGJeA.png"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据类型&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 05 Loop I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/05/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2005%20Loop%20II/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/05/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2005%20Loop%20II/</id>
    <published>2021-03-05T13:59:47.000Z</published>
    <updated>2021-03-29T05:39:48.358Z</updated>
    
    <content type="html"><![CDATA[<p>循环（下）</p><a id="more"></a><h1 id="循环控制-break-amp-continue"><a href="#循环控制-break-amp-continue" class="headerlink" title="循环控制:break &amp; continue"></a><FONT COLOR = SpringGreen>循环控制:break &amp; continue</font></h1><h2 id="判断素数"><a href="#判断素数" class="headerlink" title="判断素数"></a><FONT COLOR = Cyan>判断素数</font></h2><p>　　只能被1和自己整除的数就是素数，1不是素数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;不是素数\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　如果代码是这么写，如果输入素数，则结果是正常的；如果输入合数，则结果就不正常。那么对于这种循环的控制，可以考虑引入一个新的变量。<br>　　定义一个新的变量 Prime，初始值为1，然后只要 <code>x % i == 0</code>成立一次，那么 Prime 为0，最后判断 Prime 的值来判断素数还是合数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是合数\n&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;是素数\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里引入一个变量，来判断循环是否进入过 if ，从而对循环发起控制。</p><p>　　<FONT COLOR = LimeGreen>特别注意的是 break ，break 指跳出当前的循环。</font><br>　　如果没有这个 break，程序要跑一个比较大的数，比如199988，其实进入循环的第一轮就已经确定是合数了。但因为没有break，所以程序要一直跑到 i = 199987，要多跑很多轮。<br>　　如果这里加一个 break，程序第一轮就可以出来了，极大地提高了程序的运行效率。</p><p>　　和 break 相对的还有 continue。<FONT COLOR = LimeGreen>continue：跳过循环这一轮剩下语句，直接进入下一轮。</font><br>　　比如上述判断素数的题目中，可以利用 continue 求出所有的非因子（实在不知道如何表述这些东西）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt; x ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">continue</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因为这个 continue 的存在，所以当程序进入 if ，执行 continue 的时候，下面的 printf 就不会执行了。</p><p><img src="https://ae01.alicdn.com/kf/U5715dd804e49409f95a0e002a76f73d7i.jpg"></p><p>　　break，continue 都只能对本层循环做。</p><h1 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a><FONT COLOR = SpringGreen>多重循环</font></h1><h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a><FONT COLOR = Cyan>嵌套循环</font></h2><h3 id="100以内的素数"><a href="#100以内的素数" class="headerlink" title="100以内的素数"></a><FONT COLOR = PowderBlue size = 4>100以内的素数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( x &lt; <span class="number">100</span> )&#123;</span><br><span class="line"><span class="keyword">while</span>( i &lt; x )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x) ;</span><br><span class="line">&#125;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line">i = <span class="number">2</span> ;</span><br><span class="line">x++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　循环里面还有循环就是嵌套循环。</p><h3 id="前50个素数"><a href="#前50个素数" class="headerlink" title="前50个素数"></a><FONT COLOR = PowderBlue size = 4>前50个素数</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>( count &lt; <span class="number">50</span> )&#123;</span><br><span class="line"><span class="keyword">while</span>( i &lt; x )&#123;</span><br><span class="line"><span class="keyword">if</span>( x % i == <span class="number">0</span>)&#123;</span><br><span class="line">Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( Prime == <span class="number">1</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x) ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line">i = <span class="number">2</span> ;</span><br><span class="line">x++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　基本的思路和上一段代码一模一样，只不过多加了一个变量 count 用来计数，每成功输出一次 count 自加1。然后循环条件由 x &lt; 100 变成了 count == 50。 </p><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a><FONT COLOR = Cyan>跳出循环</font></h2><h3 id="凑硬币"><a href="#凑硬币" class="headerlink" title="凑硬币"></a><FONT COLOR = PowderBlue >凑硬币</font></h3><p>　　如何用一角、两角、五角的硬币凑出10元以下金额？主要思路是利用 for 循环，对一角、两角、五角全都遍历一遍：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这三个 for 循环的嵌套实际上是对三个变量的遍历，分别是 one 从0到10x；two 从0到5x；five 从0到2x。</p><h3 id="接力break"><a href="#接力break" class="headerlink" title="接力break"></a><FONT COLOR = PowderBlue >接力break</font></h3><p>　　对于凑硬币，如果我们只需要一个结果，即出现一次结果就停，如何是好？如果只用一个break，那只能跳出一层循环，因此我们要多个 break。<FONT COLOR = LimeGreen>即：当满足什么样的条件下，执行 break——引入类似于判断素数 Prime 的变量</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> Prime = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line">Prime = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Prime) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Prime) <span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a><FONT COLOR = PowderBlue >goto</font></h3><p>　　使用接力 break 会使得程序非常清楚，还有一个办法可以直接跳出所有循环：goto。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> one , two , five ;</span><br><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">for</span>( one = <span class="number">0</span> ; one &lt;= x * <span class="number">10</span> ; one++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( two = <span class="number">0</span> ; two &lt;= x * <span class="number">10</span> / <span class="number">2</span>  ; two++ )&#123;</span><br><span class="line"><span class="keyword">for</span>( five = <span class="number">0</span> ; five &lt;= x * <span class="number">10</span> / <span class="number">5</span> ; five++ ) &#123;</span><br><span class="line"><span class="keyword">if</span>(one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角%d个两角%d个五角\n&quot;</span>,one,two,five) ;</span><br><span class="line"><span class="keyword">goto</span> out ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>　　goto后面接一个标号，程序执行到 goto 时候会直接跳转到标号处。本段代码的标号是 out ，程序执行到 goto 时会直接跳转到 <code>out:</code>后面的那句中，即跳到 <code>return 0 ;</code></p><p>　　goto 会破坏程序的结构性、逻辑性，慎用。尽量仅在多重循环跳转的时候使用。</p><h1 id="循环习题解析"><a href="#循环习题解析" class="headerlink" title="循环习题解析"></a><FONT COLOR = SpringGreen>循环习题解析</font></h1><h2 id="前n项求和"><a href="#前n项求和" class="headerlink" title="前n项求和"></a><FONT COLOR = Cyan>前n项求和</font></h2><p><FONT COLOR = PowderBlue size = 4><strong>调和级数</strong></font><br>$$<br>f(n）=\sum_{i=1}^{n}\frac{1}{i}=1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+…+\frac{1}{n}<br>$$</p><p>像这种起点和终点都非常明确的程序，用 for 循环是最佳选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">double</span> fn = <span class="number">0.0</span> ;</span><br><span class="line"><span class="keyword">double</span> i = <span class="number">1.0</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt;= n  ; i++)&#123;</span><br><span class="line">fn = fn + <span class="number">1</span> / i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f&quot;</span>,n,fn) ;</span><br></pre></td></tr></table></figure><p><FONT COLOR = PowderBlue size = 4><strong>交错调和级数</strong></font><br>$$<br>g(n）=\sum_{i=1}^{n}(-1)^{n-1}\frac{1}{i}=1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+…+\frac{1}{n}<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="keyword">double</span> fn = <span class="number">0.0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">double</span> i = <span class="number">1.0</span> ;</span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; i &lt;= n  ; i++)&#123;</span><br><span class="line">fn = fn + sign * <span class="number">1</span> / i ;</span><br><span class="line">sign = -sign ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f&quot;</span>,n,fn) ;</span><br></pre></td></tr></table></figure><p>　　这个正负正负正负交错就是用辅助变量 sign 来实现。</p><h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a><FONT COLOR = Cyan>求最大公约数</font></h2><p>给两个数，如何求最大公约数？</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><FONT COLOR = PowderBlue >枚举</font></h3><p>1、输入两个数 a b 。首先判断两个数中最小的是哪个。<br>2、设 t 为2。<br>3、如果 a b 都能被 t 整除，则记下这个 t 。<br>4、t 自加1后重复步骤3，直到 t 等于 min｛a，b｝。<br>5、记下的 t 中最大的就是我们要求的最大公约数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b , min ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b) ;</span><br><span class="line"><span class="keyword">if</span>( a&lt;=b ) &#123;</span><br><span class="line">min = a ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">min = b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>( ; t &lt;= min ; t++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( a % t == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">if</span>( b % t == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , t ) ;</span><br><span class="line">ret = t ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大公约数是%d&quot;</span>,ret) ;</span><br></pre></td></tr></table></figure><p>　　1、为什么 t 要从1开始？我一开始是让 t 从2开始。从2开始的话，互质的两个数就没办法算公约数了。<br>　　2、ret 的作用就是记录所有的公约数，然后因为 t 是逐步上升的，所以 ret 最后输出的值也一定是最大值。</p><p>　　这种方法很直观，但是缺点是程序要循环很多轮，从1开始，一直到最小的数结束。于是欧几里得发明出更加效率的求最大公约数的算法：欧几里得算法——辗转相除法。</p><h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a><FONT COLOR = PowderBlue >辗转相除法</font></h3><p>　　假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>　　1997 / 615 = 3 (余 152)</p><p>　　615 / 152 = 4(余7)</p><p>　　152 / 7 = 21(余5)</p><p>　　7 / 5 = 1 (余2)</p><p>　　5 / 2 = 2 (余1)</p><p>　　2 / 1 = 2 (余0)</p><p>　　至此，最大公约数为1。以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><p>　　<FONT COLOR = LimeGreen>定理</font>：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。<br>　　<FONT COLOR = LimeGreen>证明</font>：<br>　　设 a b 两个数，a &gt; b。a 可以表示成 a = k * b + r ，且r&lt;b。显然，r 就是 a / b的余数，k就是商。<br>　　假设 d 是 a、b 的一个公约数，且 r = a - k * b ，所以 d 也是 r 的约数。所以 a、b 与 b 、r 的公约数相等，所以他们的最大公约数也相等。<br>　　<FONT COLOR = LimeGreen>算法</font>：任意两个数a ，b。假设 t 为余数。<br>　　1、如果 b 等于0，则计算结束，a 就是最大公约数。<br>　　2、否则，t = a % b ，并且令 a = b ， b = t 。<br>　　3、回到第一步。<br>　　<FONT COLOR = LimeGreen>算法解析</font>：<br>　　1、如果 a &gt; b 。则第二步的目的就是把 b 的值赋给 a ，把余数赋给 b 。然后开始辗转相除，直到 t == 0，即余数为 0 ，此时再进行一次 第二步，则把 b 的值赋给 a ，把  t 的值赋给 b ，此时 b == 0 ，计算结束。<br>　　2、为什么没有求 min｛a，b｝的步骤，如果 a &lt; b ，经过第二步后，a 和 b会交换值，则 a &gt; b 了。<br>　　3、不妨假设 a = 12 ， b = 18 看看每步的结果：<br>　　　　 a    b    t<br>　　　　12 18 12<br>　　　　18 12  6<br>　　　　12  6   0<br>　　　　6    0   0<br>　　<FONT COLOR = LimeGreen>代码：</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b , t ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b) ;</span><br><span class="line"><span class="keyword">while</span>( b != <span class="number">0</span> )&#123;</span><br><span class="line">t = a % b ;</span><br><span class="line">a = b ;</span><br><span class="line">b = t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;最大公约数是%d&quot;</span>,a) ;</span><br></pre></td></tr></table></figure><h2 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a><FONT COLOR = Cyan>整数分解</font></h2><h3 id="逆序分解整数"><a href="#逆序分解整数" class="headerlink" title="逆序分解整数"></a><FONT COLOR = PowderBlue >逆序分解整数</font></h3><p>　　输入一个非负整数。逆序输出它的每一位数字。比如：输入12345，输出5 4 3 2 1。<br>　　算法：<br>　　1、输入x<br>　　2、<FONT COLOR = LimeGreen>x%10，就得到了最后一位数字</font>，输出。<FONT COLOR = LimeGreen>x = x /10 ，去除了最后一位数字</font><br>　　3、x ！= 0 的话，重复步骤2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t ) ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这样做的话，是大差不差的，但是还是有两个细节。<br>　　第一个，如果 x 是 0 怎么办，因为题目要求 x 是非负，这段程序当 x = 0 时是不输出任何东西的。<br>　　第二个，题目给的要求里最后一个数字是没有空格的。而我这段程序输出会是5 4 3 2 1 ，1后面有个空格。</p><p>　　解决办法：<br>　　1、改 while 为 do - while ，必须要循环一轮。<br>　　2、加一个判断，每一轮都输出一个空格，除了最后一轮。最后一轮x一定是个位数，根据这个来写程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t ) ;</span><br><span class="line"><span class="keyword">if</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><h3 id="正序分解整数"><a href="#正序分解整数" class="headerlink" title="正序分解整数"></a><FONT COLOR = PowderBlue >正序分解整数</font></h3><p>　　输入一个非负整数，正序输出它的每一位数字。比如输入12345，输出1 2 3 4 5 。</p><p><FONT COLOR = LimeGreen>思路一</font>：<br>　　对于一个非负整数，首先把它逆序一遍，然后把它逆序分解，不就成了正序分解？<br>　　如何逆序一个数？算法如下：<br>　　1、引入d，p = 0。<br>　　2、d = x % 10 。这样 d 就取到了 x 的最后一位数。<FONT COLOR = LimeGreen>p = p * 10 + d </font>，x = x / 10 。这样就把 x 的末尾加到了 p 上，且 x 去掉最后一位数。<br>　　3、当 x &gt; 0 时，重复 2 。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;x) ;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span> , d ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">d = x % <span class="number">10</span> ;</span><br><span class="line">p = p * <span class="number">10</span> + d ; </span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125; <span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;逆序的结果是%d\n&quot;</span>,p) ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = p % <span class="number">10</span> ;</span><br><span class="line">p = p / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ;</span><br><span class="line"><span class="keyword">if</span>( p &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>( p &gt; <span class="number">0</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br></pre></td></tr></table></figure><p>　　但这个方法有一个巨大的缺陷：当输入 700，710。等末尾有0的数时，输出会错误，主要原因是逆序的时候会出问题。</p><p>　<FONT COLOR = LimeGreen>思路2：</font><br>　　1、数出输入的数 x 有多少为，比如是5位数，于是构造 mask = 10^(5-1)。<br>　　2、利用 mask 和 x 写出循环，不再是去尾巴，而是去头。</p><p>　　以 5 位数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">10000</span> ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br></pre></td></tr></table></figure><p>　　这段程序有个问题，就是如果输入 x = 700 ，那么 mask = 100 。输出就会变成7。而不是要求的 7 0 0 。<br>　　原因是循环条件有问题，如果输入 700 ，那么循环只会进行一轮，第二轮就结束了，改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">700</span> ;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">100</span> ;</span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( mask &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( mask &gt; <span class="number">0</span> ) ;</span><br></pre></td></tr></table></figure><p>　　不用 x 作为条件，用 mask 。最后一轮的特点是，x 是个位数，mask 是 1。循环结束后 mask 会变成 0 。 </p><p>　　那么如何得到这个mask呢？或者说，如何计算整数的位数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">0</span> ) ;</span><br><span class="line">mask = mask / <span class="number">10</span> ; <span class="comment">//这里mask会多走一位，所以这里除以10 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mask) ;</span><br></pre></td></tr></table></figure><p>　　其实 mask 从0.1开始更好，但这样就会让 mask 变成浮点数。翁老师的做法不是让 mask 最后自除一个零，而是让循环少跑一轮，改变循环的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( x &gt; <span class="number">9</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mask) ;</span><br></pre></td></tr></table></figure><p>　　但这样，当 x 是个位数的时候，mask 就会判断错误，所以我还是采取我的办法，即最后让 mask 自除 10 。<br>　　这样数位数的程序就做完了，于是完整的正序分解整数程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , mask = <span class="number">1</span> , number ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ; </span><br><span class="line">number = x ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">number = number / <span class="number">10</span> ;</span><br><span class="line">mask = mask * <span class="number">10</span> ;</span><br><span class="line">&#125;<span class="keyword">while</span>( number &gt; <span class="number">0</span> ) ;</span><br><span class="line">mask = mask / <span class="number">10</span> ; <span class="comment">//这里mask会多走一位，所以这里除以10 </span></span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,mask) ;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t ;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">t = x / mask ;<span class="comment">//取出首位 </span></span><br><span class="line">x = x % mask ;<span class="comment">//去掉首位</span></span><br><span class="line">mask = mask / <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , t) ;</span><br><span class="line"><span class="keyword">if</span>( mask &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">while</span>( mask &gt; <span class="number">0</span> ) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;flag\n&quot;</span>) ;<span class="comment">//这个flag是看看尾巴有没有空格</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环（下）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>汉高祖04率先入关</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/04/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9604%E7%8E%87%E5%85%88%E5%85%A5%E5%85%B3/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/04/04%20%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/03%E6%B1%89%E9%AB%98%E7%A5%96/%E6%B1%89%E9%AB%98%E7%A5%9604%E7%8E%87%E5%85%88%E5%85%A5%E5%85%B3/</id>
    <published>2021-03-04T14:14:01.000Z</published>
    <updated>2021-04-13T04:40:43.069Z</updated>
    
    <content type="html"><![CDATA[<p><FONT SIZE = 2>每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。</FONT></p><a id="more"></a><h1 id="顺利入关"><a href="#顺利入关" class="headerlink" title="顺利入关"></a>顺利入关</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;FONT SIZE = 2&gt;每个时代都有不同的时代主题。秦二世元年七月，陈胜吴广起义如晴天霹雳一般，击碎了秦帝国安逸的美梦。至此，反抗秦帝国的暴政就是这个时代的主题。&lt;/FONT&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="历史的天空" scheme="https://github.com/XuSiyuan-cn/categories/%E5%8E%86%E5%8F%B2%E7%9A%84%E5%A4%A9%E7%A9%BA/"/>
    
    
    <category term="汉高祖" scheme="https://github.com/XuSiyuan-cn/tags/%E6%B1%89%E9%AB%98%E7%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Chapter 04 Loop I</title>
    <link href="https://github.com/XuSiyuan-cn/2021/03/04/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2004%20Loop%20I/"/>
    <id>https://github.com/XuSiyuan-cn/2021/03/04/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/01%20C/Chapter%2004%20Loop%20I/</id>
    <published>2021-03-04T13:59:47.000Z</published>
    <updated>2021-03-29T04:01:16.099Z</updated>
    
    <content type="html"><![CDATA[<p>循环（上）</p><a id="more"></a><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a><FONT COLOR = SpringGreen>循环</font></h1><h2 id="while"><a href="#while" class="headerlink" title="while"></a><FONT COLOR = Cyan>while</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 循环条件 )&#123;</span><br><span class="line">循环体语句</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>　　while循环意思是：当条件满足的时候，不断地重复循环体内的语句。</p><p><a href="https://imgtu.com/i/6JjH6H"><img src="https://s3.ax1x.com/2021/03/10/6JjH6H.jpg" alt="6JjH6H.jpg"></a></p><p>　　以计算数字的位数为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , n ) ;</span><br></pre></td></tr></table></figure><p>　　这个程序有一个不完美的地方，就是当 x = 0 时，没办法正常数数。做题的时候学会写一下基本的算法：<br>1、用户输入 x ；<br>2、初始化 n 为0；<br>3、x = x / 10 ，去掉个位 ；<br>4、n++ ；<br>5、如果 x &gt; 0 ，回到3 ；<br>6、否则 n 就是结果。<br>　　如果是上面那种代码，相当于把第五步放到第二步后面，所以应该改成以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x ) ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">n++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span> , n ) ;</span><br></pre></td></tr></table></figure><p>　　其实这个循环就是 do - while 。因为不管是什么数，都要至少数一次，所以用 do - while 比较好。</p><p>　　循环体内一定要有改变条件的机会，不然就会成为死循环，在编译的时候不会出现语法问题，但结果是错的，或者超时。</p><h2 id="do-while"><a href="#do-while" class="headerlink" title="do - while"></a><FONT COLOR = Cyan>do - while</font></h2><p>　　在进入循环的时候不做检查，而是在执行完一轮循环体的代码后，再来检查循环的条件是否满足，如果满足则继续下一轮的循环，不满足则结束循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体语句</span><br><span class="line">&#125;<span class="keyword">while</span>( 循环条件 ) ;</span><br></pre></td></tr></table></figure><p>　　<FONT COLOR = LimeGreen>特别注意的是，while() 后面有一个分号。表示一行语句结束的要么是分号，要么是大括号。</font></p><p><a href="https://imgtu.com/i/6JjbXd"><img src="https://s3.ax1x.com/2021/03/10/6JjbXd.jpg" alt="6JjbXd.jpg"></a></p><p>　　while 循环以及 do - while 循环本质是一样的，特别的，判断循环是否继续的条件是一样的。区别是 do -while 无论如何循环体都会至少执行一遍。</p><h2 id="for"><a href="#for" class="headerlink" title=" for "></a><FONT COLOR = Cyan> for </font></h2><p>计算阶乘：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number , Factorial = <span class="number">1</span> , i = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number ) ;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= number )&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Factorial) ;</span><br></pre></td></tr></table></figure><p>这种循环次数很确定的程序很适合用 for 循环来编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt;= number ; i++)&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　<code>for( 初始条件 ; 循环继续的条件 ; 循环每轮最后要做的动作)</code><br>　　读成：对于一开始的初始条件，当循环条件成立时，重复做循环体，循环体完毕后，执行循环每轮最后要做的动作，然后判断循环条件。</p><p>　　<code>for( count = 10 ; count &gt; 0 ; count-- )</code><br>　　读成：对于一开始的 count = 10，当 count &gt; 0 时，重复做循环体，循环体完毕后，执行 count – ，然后判断 count &gt; 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( 表达式<span class="number">1</span> ; 表达式<span class="number">2</span> ; 表达式<span class="number">3</span>)&#123;</span><br><span class="line">&lt;循环体&gt; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/6JjLnA"><img src="https://s3.ax1x.com/2021/03/10/6JjLnA.jpg" alt="6JjLnA.jpg"></a></p><p>　　表达式1可以没有，也可以在表达式1里面定义变量，比如上述的计算阶乘：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number , Factorial = <span class="number">1</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number ) ;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= number ; i++)&#123;</span><br><span class="line">Factorial = Factorial * i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Factorial) ;</span><br></pre></td></tr></table></figure><p>　　如果在 for 循环表达式1里面定义变量，可能会出现一个警告：</p><blockquote><p>[Error] ‘for’ loop initial declarations are only allowed in C99 mode</p><p>[Note] use option -std=c99 or -std=gnu99 to compile your code</p></blockquote><p>　　这种写法是C99才有的，看编译器的接受程度。<br>　　for 循环像一个计数循环：设定一个计数器，初始化它，然后在计数器到达某值之前，重复执行循环体。相比于其他两种循环，for 循环的次数判断是最简单的。</p><h2 id="循环的选择"><a href="#循环的选择" class="headerlink" title="循环的选择"></a><FONT COLOR = Cyan>循环的选择</font></h2><p>　　如果有固定的次数，用 for<br>　　如果必须执行一次，用 do - while<br>　　其他情况用 while </p><h1 id="循环举例"><a href="#循环举例" class="headerlink" title="循环举例"></a><FONT COLOR = SpringGreen>循环举例</font></h1><h2 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a><FONT COLOR = Cyan>循环计算</font></h2><p>　　计算log2x的近似值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , input ;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">input = x ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">x = x /<span class="number">2</span> ;</span><br><span class="line">ret++ ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;log2 of %d is %d&quot;</span>,input , ret ) ;</span><br></pre></td></tr></table></figure><p>　　这个算法其实很简单，就是把 x 除2，能除多少次就是 2 的多少次方。</p><p>　　<FONT COLOR = LimeGreen>对于边界条件判断的小套路</font>：如果要模拟运行一个很大次数的循环，可以模拟较少的循环次数，然后作出推断。</p><h2 id="算平均数"><a href="#算平均数" class="headerlink" title="算平均数"></a><FONT COLOR = Cyan>算平均数</font></h2><p>$$<br>sum=\frac{\sum_{i=1}^{n}{x_i}}{n}<br>$$</p><p>　　让用户输入一系列的正整数，最后输入 -1 表示输入结束，然后程序计算出这些数字的平均数，最后输出 输入数字的个数和平均数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , i = <span class="number">0</span> , sum = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">double</span> ave ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x ) ;</span><br><span class="line"><span class="keyword">while</span>( x != <span class="number">-1</span>)&#123;</span><br><span class="line">sum = sum + x ;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">&#125;</span><br><span class="line">ave = <span class="number">1.0</span> * sum / i ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;average = %f\n&quot;</span>,ave) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i=%d&quot;</span>,i) ;</span><br></pre></td></tr></table></figure><h2 id="猜数"><a href="#猜数" class="headerlink" title="猜数"></a><FONT COLOR = Cyan>猜数</font></h2><p>　　让计算机来想一个数，然后让用户来猜，用户每输入一个数，就告诉用户大了还是小了，直到用户猜中了为止，还要告诉用户总共猜了多少次。</p><p>　　<FONT COLOR = LimeGreen>召唤随机数</font>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">srand(time(<span class="number">0</span>)) ;</span><br><span class="line"><span class="keyword">int</span> a = rand() ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a) ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　但是这样生成的随机数没有办法确定范围，于是有一个<FONT COLOR = LimeGreen>小操作</font>：<br>　　对于任何正整数 a，a % 100 一定在 0 ~ 100之间。a % 1000 一定在 0 ~ 1000 之间。以此类推，显然成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">srand(time(<span class="number">0</span>)) ;</span><br><span class="line"><span class="keyword">int</span> number = rand() ;</span><br><span class="line">number = number % <span class="number">100</span> ;<span class="comment">//这个数一定在 0~ 100之间.</span></span><br><span class="line"><span class="keyword">int</span> x , count ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">count = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( x != number)&#123;</span><br><span class="line"><span class="keyword">if</span>( x &gt; number )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big\n&quot;</span>) ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;small\n&quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line">count++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the number is %d\n&quot;</span>,x) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d times&quot;</span>,count) ; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数求逆"><a href="#整数求逆" class="headerlink" title="整数求逆"></a><FONT COLOR = Cyan>整数求逆</font></h2><p>一、700输出007：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , t ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = x % <span class="number">10</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ; </span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、700输出7，12345输出54321：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x , t ;</span><br><span class="line">t = <span class="number">0</span> ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x) ;</span><br><span class="line"><span class="keyword">while</span>( x &gt; <span class="number">0</span> )&#123;</span><br><span class="line">t = t * <span class="number">10</span> + x % <span class="number">10</span> ;</span><br><span class="line">x = x / <span class="number">10</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t) ;</span><br></pre></td></tr></table></figure><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><FONT COLOR = SpringGreen>讨论</font></h1><h2 id="会被替换为什么？"><a href="#会被替换为什么？" class="headerlink" title="/* */会被替换为什么？"></a><FONT COLOR = Cyan>/* */会被替换为什么？</font></h2><p>　　编译器在把代码翻译成汇编代码前，还有一个步骤叫预处理。在预处理当中会把注释代码干掉。可以使用以下命令来进行预处理：<br>　　gcc -E hello.c -o hello.i<br>　　hello.i 里面就是预处理后的代码。<br>　　一条语句前的注释 =&gt; 等长的空格；<br>　　一条语句中的注释 =&gt; 一个空格；<br>　　一条语句后的注释 =&gt; 直接删除</p><h2 id="最大的数有多大？"><a href="#最大的数有多大？" class="headerlink" title="最大的数有多大？"></a><FONT COLOR = Cyan>最大的数有多大？</font></h2><p>　　C语言能处理的数字是有上限的。<br>　　首先要搞清楚自己编译器各个数据类型占据多少个字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">char</span>* b; <span class="comment">//指针变量，32位系统与64为系统不一样</span></span><br><span class="line">   <span class="keyword">short</span> <span class="keyword">int</span> c;</span><br><span class="line">   <span class="keyword">int</span> d;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> e;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">double</span> g;</span><br><span class="line">   <span class="keyword">long</span> h;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> j;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char a=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(a));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;char*b=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(b));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;short int c=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(c));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;int d=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(d));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;unsigned int e=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(e));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;float f=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(f));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;double g=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(g));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;long h=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(h));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;long long i=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(i));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;unsiged long j=%d\n&quot;</span>,(<span class="keyword">int</span>)<span class="keyword">sizeof</span>(j));</span><br></pre></td></tr></table></figure><p>　　对整型int来说，一个整数占4个字节，一个字节可以储存8位无符号数，所以一个整数占32bit，其中最高位要表示符号，所以最小的数就是 -2^31。而最大的数是 2^31-1，理由是要减去一个0。</p><h2 id="for很怪吗？"><a href="#for很怪吗？" class="headerlink" title="for很怪吗？"></a><FONT COLOR = Cyan>for很怪吗？</font></h2><p>　　为什么老师说for循环很怪？for循环是高级语言出现的第一种循环，它和现代的程序设计理念是否存在差距？为什么Python语言就没有C语言这种形式的for循环了？</p><p>　　for循环更加偏向于机器理解的指令，不像while语句更容易让人理解。<br>　　Python中用的是 for in 语句，打个比方，for(int i=0;i&lt;10;i++) 在python中表示为 for i in range(0,10)，python的语法更让人理解。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a><FONT COLOR = SpringGreen>习题</font></h1><h2 id="输出所有小于等于n的奇数"><a href="#输出所有小于等于n的奇数" class="headerlink" title="输出所有小于等于n的奇数"></a><FONT COLOR = Cyan>输出所有小于等于n的奇数</font></h2><p><strong>题目内容：</strong><br>　　比如输入8，则要输出1 3 5 7.比如输入9，则要输出1 3 5 7 9.</p><p><strong>输入格式:</strong><br>　　输入一个正整数n，表示班级的人数。</p><p><strong>输出格式：</strong><br>　　每两个数之间用一个空格隔开，最后一个数后面没有空格。</p><p><strong>输入样例：</strong>11</p><p><strong>输出样例：</strong>1 3 5 7 9 11</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) ;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>( i &lt;= n )&#123;</span><br><span class="line"><span class="keyword">if</span>( i % <span class="number">2</span> == <span class="number">0</span> )&#123;</span><br><span class="line">i++ ;</span><br><span class="line"><span class="keyword">continue</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i) ;</span><br><span class="line"><span class="keyword">if</span>( i &lt; n<span class="number">-1</span> )&#123; <span class="comment">//这里我一开始条件是i&lt;n，那样输入偶数就不对了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">i++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;f&quot;) ;//用来看尾巴有没有空格</span></span><br></pre></td></tr></table></figure><h2 id="注意-i-和-i-的区别"><a href="#注意-i-和-i-的区别" class="headerlink" title="注意 i++ 和 ++i 的区别"></a><FONT COLOR = Cyan>注意 i++ 和 ++i 的区别</font></h2><p>　　<code>for ( i=0; i&lt;10; i++ ) &#123;...&#125;</code><br>　　<code>for ( i=0; i&lt;10; ++i ) &#123;...&#125;</code><br>　　<code>for ( i=0; i&lt;=9; i++ ) &#123;...&#125;</code><br>　　以上三者等价。<br>　　<code>for ( i=0; i++&lt;10;  ) &#123;...&#125;</code>，这个不一样：</p><p>　　第一种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i) ;</span><br></pre></td></tr></table></figure><p>　　循环了10轮，循环体是 i 从0 到 9。出循环体时 i 是 10。<br>　　第二种情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i++&lt;<span class="number">10</span>;  ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i) ;</span><br></pre></td></tr></table></figure><p>　　同样是循环了10轮，循环体是 i 从1 到 10。出循环体时 i 是11。</p><h2 id="注意for循环表达式2和表达式3的顺序"><a href="#注意for循环表达式2和表达式3的顺序" class="headerlink" title="注意for循环表达式2和表达式3的顺序"></a><FONT COLOR = Cyan>注意for循环表达式2和表达式3的顺序</font></h2><p>　　口算一下下面这段代码的输出值是多少：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i=<span class="number">10</span>; i&gt; <span class="number">1</span>; i /=<span class="number">2</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　10 5 3 2 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环（上）&lt;/p&gt;</summary>
    
    
    
    <category term="计算机课程" scheme="https://github.com/XuSiyuan-cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%BE%E7%A8%8B/"/>
    
    
    <category term="C语言" scheme="https://github.com/XuSiyuan-cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
